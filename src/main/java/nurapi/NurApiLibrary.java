package nurapi;

import org.bridj.*;
import org.bridj.ann.Library;
import org.bridj.ann.Name;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;

import java.util.Collections;
import java.util.Iterator;

/**
 * Wrapper for library <b>NurApi</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("NurApi")
@Runtime(CRuntime.class)
public class NurApiLibrary {
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h</i>
     */
    public static final int _NURAPI_H_ = (int) 1;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurOs_Linux.h</i>
     */
    public static final int _NUROSLINUX_H_ = (int) 1;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurOs_Linux.h</i>
     */
    public static final int NUR_LINUX = (int) 1;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurOs_Linux.h</i>
     */
    public static final int NUR_SERIAL_TRANSPORT = (int) 1;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurOs_Linux.h</i>
     */
    public static final int NUR_SOCKET_TRANSPORT = (int) 1;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurOs_Linux.h</i>
     */
    public static final int NUR_SERVER_TRANSPORT = (int) 1;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurOs_Linux.h</i>
     */
    public static final int ERROR_SUCCESS = (int) 0;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurOs_Linux.h</i>
     */
    public static final int MAX_PATH = (int) 260;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurOs_Linux.h</i>
     */
    public static final int INVALID_SOCKET = (int) (-1);
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurOs_Linux.h</i>
     */
    public static final int FALSE = (int) 0;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurOs_Linux.h</i>
     */
    public static final int TRUE = (int) 1;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurOs_Linux.h</i>
     */
    public static final int MAXBYTE = (int) 0xFF;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurOs_Linux.h</i>
     */
    public static final int MAXUSHORT = (int) 0xFFFF;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurOs_Linux.h</i>
     */
    public static final int MAXWORD = (int) 0xFFFF;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurOs_Linux.h</i>
     */
    public static final long MAXDWORD = (long) 0xFFFFFFFFL;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int _NURAPI_CONSTANTS_H_ = (int) 1;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_MAX_PATH = (int) (1024);
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_MAX_EPC_LENGTH = (int) (62);
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_MAX_EPC_LENGTH_EX = (int) (64);
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_MAX_IRDATA_LENGTH = (int) (64);
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int MAX_EE_EPCLEN = (int) 16;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int MAX_EE_TIDLEN = (int) 16;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_MAX_SELMASK = (int) (62);
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_MAX_SELMASKBITS = (int) ((62) * 8);
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_DEFAULT_BAUDRATE = (int) (115200);
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_MAX_GPIO = (int) (8);
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_MAX_FILTERS = (int) (8);
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_MAX_CUSTOM_FREQS = (int) 100;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_MAX_BITS_IN_STREAM = (int) 1024;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int SZ_NUR_DEVCAPS = (int) 128;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NR_TUNEBANDS = (int) 6;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int MIN_DEVQUERY_TIMEOUT = (int) 500;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int MAX_DEVQUERY_TIMEOUT = (int) 10000;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int XPC_W1_MASK = (int) 0x0200;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int XPC_EXT_MASK = (int) 0x8000;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_RXSENS_LOW = (int) 1;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_RXSENS_NOMINAL = (int) 0;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_RXSENS_HIGH = (int) 2;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_RFPROFILE_ROBUST = (int) 0;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_RFPROFILE_NOMINAL = (int) 1;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_RFPROFILE_HIGHSPEED = (int) 2;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int MAX_MAPPINGLEN = (int) 16;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int MIN_SCRATCHPAGE = (int) 0;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int MAX_SCRATCHPAGE = (int) 1;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int MIN_SCRATCHBYTES = (int) 1;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int MAX_SCRATCHBYTES = (int) 256;
    ;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int AUTOTUNE_MODE_ENABLE = (int) (1 << 0);
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int AUTOTUNE_MODE_THRESHOLD_ENABLE = (int) (1 << 1);
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_TID_HIDE_NONE = (int) 2;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_TID_HIDE_SOME = (int) 1;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_TID_HIDE_ALL = (int) 2;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_UTRACE_RANGE_NORMAL = (int) 0;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_UTRACE_RANGE_TOGGLE = (int) 1;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_UTRACE_RANGE_REDUCE = (int) 2;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_GEN2V2_MAX_AUTHBYTES = (int) 128;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_GEN2V2_MAX_AUTHBITS = (int) (128 * 8);
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_GEN2V2_MIN_AUTHBITS = (int) 1;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_MAX_AUTHRESPBITS = (int) 1008;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int MAX_V2_RDBUFBITS = (int) 1000;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int VER2_RDBUF_MAXADDR = (int) 0xFFF;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_TAM_KEYLEN = (int) 16;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_TAM_MAXBLOCKS = (int) 4;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_SZ_TAM2_BLOCK = (int) 8;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_SZ_TAM2_CMACLEN = (int) 12;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_MAX_TAM_OFFSET = (int) 0xFFF;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int ISO29167_TAM_CONSTANT = (int) 0x96C5;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int TAM_CHALLENGE_BITLEN = (int) 80;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int TAM_CHALLENGE_BYTELEN = (int) (80 / 8);
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int TAM1_MSG_BITLENGTH = (int) 96;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int TAM2_MSG_BITLENGTH = (int) 120;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int TAM1_MSG_BYTELENGTH = (int) (96 / 8);
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int TAM2_MSG_BYTELENGTH = (int) (120 / 8);
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_IR_XTID_EX_FLAG = (int) 0x80;
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_DC_RXDECMASK = (int) (0x0F);
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_DC_RXDECALL = (int) (0x0F);
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_DC_RXLFMASK = (int) (0xFF << 4);
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h</i>
     */
    public static final int NUR_DC_SENSOR_MASK = (int) (0x03 << 13);
    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPIErrors.h</i>
     */
    public static final int _NURAPI_ERRORS_H_ = (int) 1;

    static {
        BridJ.register();
    }

    /**
     * Get human readable error message for error code
     * <br>
     *
     * @param error     Error code
     *                  <br>
     * @param buffer    Buffer to store message
     *                  <br>
     * @param bufferLen Length of buffer in characters. This should be atleast 128 characters length.
     *                  <br>
     * @return Number of characters stored in buffer.<br>
     * Original signature : <code>int NurApiGetErrorMessage(int, TCHAR*, int)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIErrors.h:72</i>
     */
    public static int NurApiGetErrorMessage(int error, Pointer<Byte> buffer, int bufferLen) {
        return NurApiGetErrorMessage(error, Pointer.getPeer(buffer), bufferLen);
    }

    protected native static int NurApiGetErrorMessage(int error, @Ptr long buffer, int bufferLen);

    /**
     * @fn HANDLE NurApiCreate()
     * <br>
     * Creates new instance of NurApi object.
     * <br>
     * <br>
     * @return Handle to NurApi object or NULL on error.<br>
     * Original signature : <code>HANDLE NurApiCreate()</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:704</i>
     */
    public static Pointer<?> NurApiCreate() {
        return Pointer.pointerToAddress(NurApiCreate$2());
    }

    @Ptr
    @Name("NurApiCreate")
    protected native static long NurApiCreate$2();

    /**
     * @fn int NurApiFree(HANDLE hApi)
     * <br>
     * Free allocated NurApi object.
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiFree(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:712</i>
     */
    public static int NurApiFree(Pointer<?> hApi) {
        return NurApiFree(Pointer.getPeer(hApi));
    }

    protected native static int NurApiFree(@Ptr long hApi);

    /**
     * @fn DWORD NurApiGetTimestamp(HANDLE hApi)
     * <br>
     * Get NurApi internal timestamp. This is time in milliseconds since NurApi was created.
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @return Time in milliseconds since NurApi was created.<br>
     * Original signature : <code>DWORD NurApiGetTimestamp(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:720</i>
     */
    public static int NurApiGetTimestamp(Pointer<?> hApi) {
        return NurApiGetTimestamp(Pointer.getPeer(hApi));
    }

    protected native static int NurApiGetTimestamp(@Ptr long hApi);

    /**
     * @fn BOOL NurApiGetFileVersion(TCHAR *version, int versionSize)
     * <br>
     * Get NurApi DLL version number as string.
     * <br>
     * @param    version            Pointer to a buffer that receives NurApi.dll version string.
     * <br>
     * @param    versionSize        The size of <i>version</i> buffer in TCHARs.
     * <br>
     * @return TRUE on success, otherwise FALSE.<br>
     * Original signature : <code>BOOL NurApiGetFileVersion(TCHAR*, int)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:729</i>
     */
    public static int NurApiGetFileVersion(Pointer<Byte> version, int versionSize) {
        return NurApiGetFileVersion(Pointer.getPeer(version), versionSize);
    }

    protected native static int NurApiGetFileVersion(@Ptr long version, int versionSize);

    /**
     * @fn BOOL NurApiGetImageInfo(HANDLE hApi, TCHAR *fileName, struct NUR_IMAGE_INFO *pInfo)
     * <br>
     * Get NUR module's image file information.
     * <br>
     * <br>
     * @sa NUR_IMAGE_INFO
     * <br>
     *
     * <br>
     * @param    hApi        Valid NUR API handle or NULL.
     * <br>
     * @param    fileName    The file name to inspect.
     * <br>
     * @param    pInfo        Pointer to a NUR_IMAGE_INFO structure.
     * <br>
     * @return Zero on success, non-zero error code otherwise.<br>
     * Original signature : <code>int NurApiGetImageInfo(HANDLE, TCHAR*, NUR_IMAGE_INFO*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:742</i>
     */
    public static int NurApiGetImageInfo(Pointer<?> hApi, Pointer<Byte> fileName, Pointer<NUR_IMAGE_INFO> pInfo) {
        return NurApiGetImageInfo(Pointer.getPeer(hApi), Pointer.getPeer(fileName), Pointer.getPeer(pInfo));
    }

    protected native static int NurApiGetImageInfo(@Ptr long hApi, @Ptr long fileName, @Ptr long pInfo);

    /**
     * @fn int NurApiLoadSetupFile(HANDLE hApi, const TCHAR *filename)
     * <br>
     * Load settings from specific configuration file and apply to module.
     * <br>
     *
     * <br>
     * @sa NurApiSaveSetupFile()
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    filename    Path to configuration file.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiLoadSetupFile(HANDLE, const TCHAR*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:755</i>
     */
    public static int NurApiLoadSetupFile(Pointer<?> hApi, Pointer<Byte> filename) {
        return NurApiLoadSetupFile(Pointer.getPeer(hApi), Pointer.getPeer(filename));
    }

    protected native static int NurApiLoadSetupFile(@Ptr long hApi, @Ptr long filename);

    /**
     * @fn int NurApiLoadHoptable(HANDLE hApi, const TCHAR *filename, DWORD *errFlags)
     * <br>
     * Load custom hoptable configuration from an .INI-file.
     * <br>
     * <br>
     * @sa NUR_CUSTHOP_ERROR.
     * <br>
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    filename    Path to hoptable .INI-file.
     * <br>
     * @param    errFlags    Pointer to parese error flags. Optional.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiLoadHoptable(HANDLE, const TCHAR*, DWORD*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:769</i>
     */
    public static int NurApiLoadHoptable(Pointer<?> hApi, Pointer<Byte> filename, Pointer<Integer> errFlags) {
        return NurApiLoadHoptable(Pointer.getPeer(hApi), Pointer.getPeer(filename), Pointer.getPeer(errFlags));
    }

    protected native static int NurApiLoadHoptable(@Ptr long hApi, @Ptr long filename, @Ptr long errFlags);

    /**
     * @fn int NurApiSaveHoptable(HANDLE hApi, const TCHAR *filename, BOOL comment, BOOL apply)
     * <br>
     * Save currently stored hoptable toan .INI-file.
     * <br>
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    filename    Path to hoptable .INI-file.
     * <br>
     * @param    comment        The output file is commented as per setting.
     * <br>
     * @param    apply        If set to TRUE, then the "Apply" value will be set to 1 in the resulting .INI-file.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiSaveHoptable(HANDLE, const TCHAR*, BOOL, BOOL)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:782</i>
     */
    public static int NurApiSaveHoptable(Pointer<?> hApi, Pointer<Byte> filename, int comment, int apply) {
        return NurApiSaveHoptable(Pointer.getPeer(hApi), Pointer.getPeer(filename), comment, apply);
    }

    protected native static int NurApiSaveHoptable(@Ptr long hApi, @Ptr long filename, int comment, int apply);

    /**
     * @fn int NurApiReadPermalock(HANDLE hApi, DWORD password, BOOL secured, struct NUR_PERMALOCK_RD_PARAM *pLock, struct NUR_PERMALOCK_RD_RESP *pResp)
     * <br>
     * <br>
     * Read permalock status without singulating the tag.
     * <br>
     *
     * <br>
     * @sa NurApiReadPermalockByEPC, NurApiReadPermalockSingulated32, NUR_PERMALOCK_PARAM, NUR_PERMALOCK_RD_RESP
     * <br>
     *
     * <br>
     * @param    password    Passsword for this operation. If secured is FALSE, then this parameter is ignored.
     * <br>
     * @param    secured        When set to TRUE the password parameter is used when accessing the tag.
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    pLock        Pointer to the NUR_PERMALOCK_PARAM structure defining the read conditions.
     * <br>
     * @param    pResp        Pointer to NUR_PERMALOCK_RD_RESP where a successful reponse is decoded into.
     * <br>
     * <br>
     * @return Zero when succeeded, non-zero error code when failed.<br>
     * Original signature : <code>int NurApiReadPermalock(HANDLE, DWORD, BOOL, NUR_PERMALOCK_RD_PARAM*, NUR_PERMALOCK_RD_RESP*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:799</i>
     */
    public static int NurApiReadPermalock(Pointer<?> hApi, int password, int secured, Pointer<NUR_PERMALOCK_RD_PARAM> pLock, Pointer<NUR_PERMALOCK_RD_RESP> pResp) {
        return NurApiReadPermalock(Pointer.getPeer(hApi), password, secured, Pointer.getPeer(pLock), Pointer.getPeer(pResp));
    }

    protected native static int NurApiReadPermalock(@Ptr long hApi, int password, int secured, @Ptr long pLock, @Ptr long pResp);

    /**
     * @fn int NurApiReadPermalockByEPC(HANDLE hApi, DWORD password, BOOL secured, BYTE *epc, DWORD epcLen, struct NUR_PERMALOCK_RD_PARAM *pLock, struct NUR_PERMALOCK_RD_RESP *pResp)
     * <br>
     * <br>
     * Read permalock status by singulating the tag with given EPC data.
     * <br>
     *
     * <br>
     * @sa NurApiReadPermalock, NurApiReadPermalockSingulated32, NUR_PERMALOCK_RD_PARAM, NUR_PERMALOCK_RD_RESP
     * <br>
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    password    Passsword for this operation. If secured is FALSE, then this parameter is ignored.
     * <br>
     * @param    secured        When set to TRUE the password parameter is used when accessing the tag.
     * <br>
     * @param    epc            Pointer to the EPC data.
     * <br>
     * @param    epcLen        Length of the EPC. Maximum length is 64 bytes that correspond to 496 bits. Can be set to 0; in that case @sa NurApiReadPermalockStatus is called.
     * <br>
     * @param    pLock        Pointer to the NUR_PERMALOCK_PARAM structure defining the read conditions.
     * <br>
     * @param    pResp        Pointer to NUR_PERMALOCK_RD_RESP where a successful reponse is decoded into.
     * <br>
     * <br>
     * @return Zero when succeeded, non-zero error code when failed.<br>
     * Original signature : <code>int NurApiReadPermalockByEPC(HANDLE, DWORD, BOOL, BYTE*, DWORD, NUR_PERMALOCK_RD_PARAM*, NUR_PERMALOCK_RD_RESP*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:818</i>
     */
    public static int NurApiReadPermalockByEPC(Pointer<?> hApi, int password, int secured, Pointer<Byte> epc, int epcLen, Pointer<NUR_PERMALOCK_RD_PARAM> pLock, Pointer<NUR_PERMALOCK_RD_RESP> pResp) {
        return NurApiReadPermalockByEPC(Pointer.getPeer(hApi), password, secured, Pointer.getPeer(epc), epcLen, Pointer.getPeer(pLock), Pointer.getPeer(pResp));
    }

    protected native static int NurApiReadPermalockByEPC(@Ptr long hApi, int password, int secured, @Ptr long epc, int epcLen, @Ptr long pLock, @Ptr long pResp);

    /**
     * @fn int NurApiReadPermalockSingulated32(HANDLE hApi, DWORD password, BOOL secured,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask,
     * <br>
     * struct NUR_PERMALOCK_RD_PARAM *pLock, struct NUR_PERMALOCK_RD_RESP *pResp)
     * <br>
     * <br>
     * Read permalock status by singulating the tag with given selection data.
     * <br>
     *
     * <br>
     * @sa NurApiReadPermalock, NurApiReadPermalockByEPC, NUR_PERMALOCK_PARAM, NUR_PERMALOCK_RD_RESP
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    password        Passsword for this operation. If secured is FALSE, then this parameter is ignored.
     * <br>
     * @param    secured            When set to TRUE the password parameter is used when accessing the tag.
     * <br>
     * @param    sBank            Bank to use in tag selection.
     * <br>
     * @param    sAddress        Bit address of the select data.
     * <br>
     * @param    sMaskBitLength    Bit length of the selection mask (sMask) parameter.
     * <br>
     * @param    sMask            Selection mask data.
     * <br>
     * @param    pLock            Pointer to the NUR_PERMALOCK_PARAM structure defining the read conditions.
     * <br>
     * @param    pResp            Pointer to NUR_PERMALOCK_RD_RESP where a successful reponse is decoded into.
     * <br>
     * <br>
     * @return Zero when succeeded, non-zero error code when failed.<br>
     * Original signature : <code>int NurApiReadPermalockSingulated32(HANDLE, DWORD, BOOL, BYTE, DWORD, int, BYTE*, NUR_PERMALOCK_RD_PARAM*, NUR_PERMALOCK_RD_RESP*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:841</i>
     */
    public static int NurApiReadPermalockSingulated32(Pointer<?> hApi, int password, int secured, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, Pointer<NUR_PERMALOCK_RD_PARAM> pLock, Pointer<NUR_PERMALOCK_RD_RESP> pResp) {
        return NurApiReadPermalockSingulated32(Pointer.getPeer(hApi), password, secured, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), Pointer.getPeer(pLock), Pointer.getPeer(pResp));
    }

    protected native static int NurApiReadPermalockSingulated32(@Ptr long hApi, int password, int secured, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, @Ptr long pLock, @Ptr long pResp);

    /**
     * @fn int NurApiPermalock(HANDLE hApi, DWORD password, BOOL secured, struct NUR_PERMALOCK_PARAM *pLock)
     * <br>
     * <br>
     * Permanently lock blocks in a tag without singulating the tag.
     * <br>
     * <br>
     * @sa NurApiPermalockByEPC, NurApiPermalockSingulated32, NUR_PERMALOCK_PARAM, NUR_PERMALOCK_RD_RESP
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    password        Passsword for this operation. If secured is FALSE, then this parameter is ignored.
     * <br>
     * @param    secured            When set to TRUE the password parameter is used when accessing the tag.
     * <br>
     * @param    pLock            Pointer to a NUR_PERMALOCK_PARAM structure specifying the lock definition.
     * <br>
     * <br>
     * @return Zero when succeeded, non-zero error code when failed.<br>
     * Original signature : <code>int NurApiPermalock(HANDLE, DWORD, BOOL, NUR_PERMALOCK_PARAM*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:857</i>
     */
    public static int NurApiPermalock(Pointer<?> hApi, int password, int secured, Pointer<NUR_PERMALOCK_PARAM> pLock) {
        return NurApiPermalock(Pointer.getPeer(hApi), password, secured, Pointer.getPeer(pLock));
    }

    protected native static int NurApiPermalock(@Ptr long hApi, int password, int secured, @Ptr long pLock);

    /**
     * @fn int NurApiPermalockByEPC(HANDLE hApi, DWORD password, BOOL secured, BYTE *epc, DWORD epcLen, struct NUR_PERMALOCK_PARAM *pLock)
     * <br>
     * <br>
     * Permanently lock block in a tag by selecting it with given EPC data.
     * <br>
     * <br>
     * @sa NurApiPermalock, NurApiPermalockSingulated32, NUR_PERMALOCK_PARAM, NUR_PERMALOCK_RD_RESP
     * <br>
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    password    Passsword for this operation. If secured is FALSE, then this parameter is ignored.
     * <br>
     * @param    secured        When set to TRUE the password parameter is used when accessing the tag.
     * <br>
     * @param    epc            Pointer to the EPC data.
     * <br>
     * @param    epcLen        Length of the EPC. Maximum length is 64 bytes that correspond to 496 bits.
     * <br>
     * @param    pLock        Pointer to a NUR_PERMALOCK_PARAM structure specifying the lock definition.
     * <br>
     * <br>
     * @return Zero when succeeded, non-zero error code when failed.<br>
     * Original signature : <code>int NurApiPermalockByEPC(HANDLE, DWORD, BOOL, BYTE*, DWORD, NUR_PERMALOCK_PARAM*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:875</i>
     */
    public static int NurApiPermalockByEPC(Pointer<?> hApi, int password, int secured, Pointer<Byte> epc, int epcLen, Pointer<NUR_PERMALOCK_PARAM> pLock) {
        return NurApiPermalockByEPC(Pointer.getPeer(hApi), password, secured, Pointer.getPeer(epc), epcLen, Pointer.getPeer(pLock));
    }

    protected native static int NurApiPermalockByEPC(@Ptr long hApi, int password, int secured, @Ptr long epc, int epcLen, @Ptr long pLock);

    /**
     * @fn int NurApiPermalockSingulated32(HANDLE hApi, DWORD password, BOOL secured,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask,
     * <br>
     * struct NUR_PERMALOCK_PARAM *pLock)
     * <br>
     * <br>
     * Permanently lock block in a tag by selecting it with given selection data.
     * <br>
     * <br>
     * @sa NurApiPermalock, NurApiPermalockByEPC, NUR_PERMALOCK_PARAM, NUR_PERMALOCK_RD_RESP
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    password        Passsword for this operation. If secured is FALSE, then this parameter is ignored.
     * <br>
     * @param    secured            When set to TRUE the password parameter is used when accessing the tag.
     * <br>
     * @param    sBank            Bank to use in tag selection.
     * <br>
     * @param    sAddress        Bit address of the select data.
     * <br>
     * @param    sMaskBitLength    Bit length of the selection mask (sMask) parameter.
     * <br>
     * @param    sMask            Selection mask data.
     * <br>
     * @param    pLock            Pointer to a NUR_PERMALOCK_PARAM structure specifying the lock definition.
     * <br>
     * <br>
     * @return Zero when succeeded, non-zero error code when failed.<br>
     * Original signature : <code>int NurApiPermalockSingulated32(HANDLE, DWORD, BOOL, BYTE, DWORD, int, BYTE*, NUR_PERMALOCK_PARAM*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:897</i>
     */
    public static int NurApiPermalockSingulated32(Pointer<?> hApi, int password, int secured, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, Pointer<NUR_PERMALOCK_PARAM> pLock) {
        return NurApiPermalockSingulated32(Pointer.getPeer(hApi), password, secured, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), Pointer.getPeer(pLock));
    }

    protected native static int NurApiPermalockSingulated32(@Ptr long hApi, int password, int secured, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, @Ptr long pLock);

    /**
     * @fn int NurApiSaveSetupFile(HANDLE hApi, const TCHAR *filename)
     * <br>
     * Read all module settings and save them to specific configuration file.
     * <br>
     * <br>
     * @sa NurApiLoadSetupFile()
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    filename    Path to configuration file.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiSaveSetupFile(HANDLE, const TCHAR*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:910</i>
     */
    public static int NurApiSaveSetupFile(Pointer<?> hApi, Pointer<Byte> filename) {
        return NurApiSaveSetupFile(Pointer.getPeer(hApi), Pointer.getPeer(filename));
    }

    protected native static int NurApiSaveSetupFile(@Ptr long hApi, @Ptr long filename);

    /**
     * @fn int NurApiSetModuleSetup(HANDLE hApi, DWORD setupFlags, struct NUR_MODULESETUP *setup, DWORD setupSize)
     * <br>
     * <br>
     * Set new setup to NUR module. This will store new setup in volatile memory.
     * <br>
     * If you need persistent setup, you'll need to call NurApiStoreCurrentSetup() or NurApiStoreCurrentSetupEx()
     * <br>
     * <br>
     * @sa NUR_MODULESETUP, NurApiGetModuleSetup(), NUR_MODULESETUP_FLAGS, NurApiStoreCurrentSetup(), NurApiStoreCurrentSetupEx()
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    setupFlags    Defines which flags are valid in <i>setup</i> structure. see enum NUR_MODULESETUP_FLAGS.
     * <br>
     * @param    setup        Pointer to a new module setup. <i>setupFlags</i> defined fields must be valid.
     * <br>
     * @param    setupSize    Size of the <i>setup</i> structure in bytes. Usually: sizeof(struct NUR_MODULESETUP).
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiSetModuleSetup(HANDLE, DWORD, NUR_MODULESETUP*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:927</i>
     */
    public static int NurApiSetModuleSetup(Pointer<?> hApi, int setupFlags, Pointer<NUR_MODULESETUP> setup, int setupSize) {
        return NurApiSetModuleSetup(Pointer.getPeer(hApi), setupFlags, Pointer.getPeer(setup), setupSize);
    }

    protected native static int NurApiSetModuleSetup(@Ptr long hApi, int setupFlags, @Ptr long setup, int setupSize);

    /**
     * @fn int NurApiGetModuleSetup(HANDLE hApi, DWORD setupFlags, struct NUR_MODULESETUP *setup, DWORD setupSize)
     * <br>
     * <br>
     * Get current setup from NUR module.
     * <br>
     * Set <i>setupFlags</i> parameter to wanted setup options to get, use flag NUR_SETUP_ALL to get all.
     * <br>
     * <br>
     * @sa NUR_MODULESETUP, NurApiSetModuleSetup(), enum NUR_MODULESETUP_FLAGS
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    setupFlags    Defines which flags are fetched to <i>setup</i> structure. see enum NUR_MODULESETUP_FLAGS.
     * <br>
     * @param    setup        Pointer to a buffer that receives module current setup defined in <i>setupFlags</i>.
     * <br>
     * @param    setupSize    Size of the <i>setup</i> structure in bytes. Usually: sizeof(struct NUR_MODULESETUP).
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetModuleSetup(HANDLE, DWORD, NUR_MODULESETUP*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:944</i>
     */
    public static int NurApiGetModuleSetup(Pointer<?> hApi, int setupFlags, Pointer<NUR_MODULESETUP> setup, int setupSize) {
        return NurApiGetModuleSetup(Pointer.getPeer(hApi), setupFlags, Pointer.getPeer(setup), setupSize);
    }

    protected native static int NurApiGetModuleSetup(@Ptr long hApi, int setupFlags, @Ptr long setup, int setupSize);

    /**
     * @fn int NurApiStoreCurrentSetup(HANDLE hApi)
     * <br>
     * Store current module full setup, exluding baudrate, to module's non-volatile memory.
     * <br>
     * This is same as NurApiStoreCurrentSetupEx(hApi, NUR_STORE_ALL & ~NUR_STORE_BAUDRATE).
     * <br>
     *
     * <br>
     * @sa NurApiStoreCurrentSetupEx()
     * <br>
     *
     * <br>
     * @param    hApi    Handle to valid NurApi object instance
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiStoreCurrentSetup(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:957</i>
     */
    public static int NurApiStoreCurrentSetup(Pointer<?> hApi) {
        return NurApiStoreCurrentSetup(Pointer.getPeer(hApi));
    }

    protected native static int NurApiStoreCurrentSetup(@Ptr long hApi);

    /**
     * @fn int NurApiStoreCurrentSetupEx(HANDLE hApi, BYTE flags)
     * <br>
     * Store selected module setup to module's non-volatile memory.
     * <br>
     * <br>
     * @sa enum NUR_STORE_FLAGS
     * <br>
     *
     * <br>
     * @param    hApi    Handle to valid NurApi object instance.
     * <br>
     * @param    flags Defines which settings to store. see NUR_STORE_FLAGS
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiStoreCurrentSetupEx(HANDLE, BYTE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:970</i>
     */
    public static int NurApiStoreCurrentSetupEx(Pointer<?> hApi, byte flags) {
        return NurApiStoreCurrentSetupEx(Pointer.getPeer(hApi), flags);
    }

    protected native static int NurApiStoreCurrentSetupEx(@Ptr long hApi, byte flags);

    /**
     * @fn void NurApiSetLogLevel(HANDLE hApi, int logMask)
     * <br>
     * Set NurApi logging level mask.
     * <br>
     *
     * <br>
     * @sa enum NUR_LOGS, NurApiSetLogToFile()
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    logMask        Logging level mask to set. see enum NUR_LOGS
     * <br>
     *
     * <br>
     * @return None.<br> Original signature : <code>void NurApiSetLogLevel(HANDLE, int)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:983</i>
     */
    public static void NurApiSetLogLevel(Pointer<?> hApi, int logMask) {
        NurApiSetLogLevel(Pointer.getPeer(hApi), logMask);
    }

    protected native static void NurApiSetLogLevel(@Ptr long hApi, int logMask);

    /**
     * @fn int NurApiGetLogLevel(HANDLE hApi)
     * <br>
     * Get current NurApi logging level mask.
     * <br>
     *
     * <br>
     * @sa enum NUR_LOGS, NurApiSetLogToFile()
     * <br>
     *
     * <br>
     * @param    hApi    Handle to valid NurApi object instance.
     * <br>
     * @return Current logging level mask. see enum NUR_LOGS<br>
     * Original signature : <code>int NurApiGetLogLevel(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:994</i>
     */
    public static int NurApiGetLogLevel(Pointer<?> hApi) {
        return NurApiGetLogLevel(Pointer.getPeer(hApi));
    }

    protected native static int NurApiGetLogLevel(@Ptr long hApi);

    /**
     * @fn void NurApiSetLogToFile(HANDLE hApi, BOOL enable)
     * <br>
     * Enable NurApi log to file.
     * <br>
     *
     * <br>
     * @sa NurApiSetLogLevel()
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    enable        set TRUE to enable, FALSE to disable.
     * <br>
     * @return None.<br> Original signature : <code>void NurApiSetLogToFile(HANDLE, BOOL)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1006</i>
     */
    public static void NurApiSetLogToFile(Pointer<?> hApi, int enable) {
        NurApiSetLogToFile(Pointer.getPeer(hApi), enable);
    }

    protected native static void NurApiSetLogToFile(@Ptr long hApi, int enable);

    ;

    /**
     * @fn BOOL NurApiGetLogToFile(HANDLE hApi)
     * <br>
     * Get log to file enabled state.
     * <br>
     *
     * <br>
     * @sa NurApiSetLogLevel()
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance
     * <br>
     * @return TRUE if enabled, FALSE if disabled.<br>
     * Original signature : <code>BOOL NurApiGetLogToFile(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1017</i>
     */
    public static int NurApiGetLogToFile(Pointer<?> hApi) {
        return NurApiGetLogToFile(Pointer.getPeer(hApi));
    }

    ;

    protected native static int NurApiGetLogToFile(@Ptr long hApi);

    /**
     * @fn const TCHAR *NurApiSetLogFilePath(HANDLE hApi, const TCHAR *filename)
     * <br>
     * Set log file path.
     * <br>
     *
     * <br>
     * @sa NurApiGetLogFilePath(), NurApiSetLogToFile(), NurApiSetLogLevel()
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    filename    Path to log file.
     * <br>
     * @return None.<br> Original signature : <code>void NurApiSetLogFilePath(HANDLE, const TCHAR*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1029</i>
     */
    public static void NurApiSetLogFilePath(Pointer<?> hApi, Pointer<Byte> filename) {
        NurApiSetLogFilePath(Pointer.getPeer(hApi), Pointer.getPeer(filename));
    }

    protected native static void NurApiSetLogFilePath(@Ptr long hApi, @Ptr long filename);

    /**
     * @fn const TCHAR *NurApiGetLogFilePath(HANDLE hApi)
     * <br>
     * Get log file path.
     * <br>
     *
     * <br>
     * @sa NurApiSetLogFilePath(), NurApiSetLogToFile(), NurApiSetLogLevel()
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance
     * <br>
     * @return Full path to log file.<br>
     * Original signature : <code>TCHAR* NurApiGetLogFilePath(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1040</i>
     */
    public static Pointer<Byte> NurApiGetLogFilePath(Pointer<?> hApi) {
        return (Pointer) Pointer.pointerToAddress(NurApiGetLogFilePath(Pointer.getPeer(hApi)), Byte.class);
    }

    @Ptr
    protected native static long NurApiGetLogFilePath(@Ptr long hApi);

    /**
     * @fn void NurApiSetContext(HANDLE hApi, LPVOID ctx)
     * <br>
     * Set application specific context to NurApi object.
     * <br>
     * <br>
     * @sa NurApiGetContext()
     * <br>
     *
     * <br>
     * @param    hApi    Handle to valid NurApi object instance
     * <br>
     * @param    ctx        Pointer to application specific context. Context can be retrieved with NurApiGetContext() function.
     * <br>
     * @return None.<br> Original signature : <code>void NurApiSetContext(HANDLE, LPVOID)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1052</i>
     */
    public static void NurApiSetContext(Pointer<?> hApi, Pointer<?> ctx) {
        NurApiSetContext(Pointer.getPeer(hApi), Pointer.getPeer(ctx));
    }

    protected native static void NurApiSetContext(@Ptr long hApi, @Ptr long ctx);

    /**
     * @fn LPVOID NurApiGetContext(HANDLE hApi)
     * <br>
     * Get application specific context from NurApi object.
     * <br>
     * <br>
     * @sa NurApiSetContext()
     * <br>
     *
     * <br>
     * @param    hApi    Handle to valid NurApi object instance
     * <br>
     * @return Application specific context set by NurApiSetContext() function.<br>
     * Original signature : <code>LPVOID NurApiGetContext(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1063</i>
     */
    public static Pointer<?> NurApiGetContext(Pointer<?> hApi) {
        return Pointer.pointerToAddress(NurApiGetContext(Pointer.getPeer(hApi)));
    }

    @Ptr
    protected native static long NurApiGetContext(@Ptr long hApi);

    /**
     * @fn DWORD NurApiGetLastNotificationStatus(HANDLE hApi)
     * <br>
     * Get last notification status code.
     * <br>
     * Get last notification status code, this one of the NUR_ERRORCODES.
     * <br>
     * NOTE: This is function returns valid status only when called from application NotificationCallback.
     * <br>
     * <br>
     * @sa enum NUR_ERRORCODES, enum NUR_NOTIFICATION, NurApiSetNotificationCallback, NotificationCallback
     * <br>
     * <br>
     * @param    hApi    Handle to valid NurApi object instance.
     * <br>
     * @return Zero when no error, On error non-zero error code (NUR_ERRORCODES) is returned.<br>
     * Original signature : <code>DWORD NurApiGetLastNotificationStatus(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1076</i>
     */
    public static int NurApiGetLastNotificationStatus(Pointer<?> hApi) {
        return NurApiGetLastNotificationStatus(Pointer.getPeer(hApi));
    }

    protected native static int NurApiGetLastNotificationStatus(@Ptr long hApi);

    /**
     * @fn int NurApiSetNotificationCallback(HANDLE hApi, NotificationCallback nFunc)
     * <br>
     * Set notification receive function.
     * <br>
     * Set function that receives all notification events specific to this NurApi instance.
     * <br>
     *
     * <br>
     * @sa enum NUR_NOTIFICATION, NotificationCallback
     * <br>
     *
     * <br>
     * @param    hApi    Handle to valid NurApi object instance.
     * <br>
     * @param    nFunc    Pointer to a function.
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiSetNotificationCallback(HANDLE, NotificationCallback)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1089</i>
     */
    public static int NurApiSetNotificationCallback(Pointer<?> hApi, Pointer<NotificationCallback> nFunc) {
        return NurApiSetNotificationCallback(Pointer.getPeer(hApi), Pointer.getPeer(nFunc));
    }

    protected native static int NurApiSetNotificationCallback(@Ptr long hApi, @Ptr long nFunc);

    /**
     * @fn void NurApiLog(HANDLE hApi, int level, const TCHAR *txt)
     * <br>
     * Send log string through NurApi.
     * <br>
     * Application can send log string through NurApi and catch them on notification callback.
     * <br>
     *
     * <br>
     * @param    hApi    Handle to valid NurApi object instance.
     * <br>
     * @param    level    Logging level for this log string.
     * <br>
     * @param    txt        Text to send.
     * <br>
     * @return None.<br> Original signature : <code>void NurApiLog(HANDLE, int, const TCHAR*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1101</i>
     */
    public static void NurApiLog(Pointer<?> hApi, int level, Pointer<Byte> txt) {
        NurApiLog(Pointer.getPeer(hApi), level, Pointer.getPeer(txt));
    }

    protected native static void NurApiLog(@Ptr long hApi, int level, @Ptr long txt);

    /**
     * @fn int NurApiIsConnected(HANDLE hApi)
     * <br>
     * Get NUR module connection state.
     * <br>
     *
     * <br>
     * @remarks This function will return only connection state of the transport layer.
     * <br>
     * In order to know that module is responding, you'll need to communicate with module by calling e.g. NurApiPing().
     * <br>
     * <br>
     * @sa NurApiConnectSerialPort(), NurApiConnectSocket(), NurApiConnectTransport(), NurApiConnect(), NurApiConnectTransportSpec(),
     * <br>
     * NurApiDisconnect(), NurApiPing()
     * <br>
     * <br>
     * @param    hApi    Handle to valid NurApi object instance.
     * <br>
     * @return 0 if transport is connected, non-zero error code on failure.<br>
     * Original signature : <code>int NurApiIsConnected(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1116</i>
     */
    public static int NurApiIsConnected(Pointer<?> hApi) {
        return NurApiIsConnected(Pointer.getPeer(hApi));
    }

    protected native static int NurApiIsConnected(@Ptr long hApi);

    /**
     * @fn int NurApiConnect(HANDLE hApi)
     * <br>
     * Reconnect transport layer with previously set tranport/connect spec.
     * <br>
     * <br>
     * @sa NurApiConnectSerialPort(), NurApiConnectSocket(), NurApiConnectTransport(), NurApiConnect(), NurApiConnectTransportSpec(),
     * <br>
     * NurApiIsConnected(), NurApiDisconnect()
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @return 0 if connection succeeded, non-zero error code on failure.<br>
     * Original signature : <code>int NurApiConnect(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1128</i>
     */
    public static int NurApiConnect(Pointer<?> hApi) {
        return NurApiConnect(Pointer.getPeer(hApi));
    }

    protected native static int NurApiConnect(@Ptr long hApi);

    /**
     * @fn int NurApiConnectSerialPort(HANDLE hApi, int port, int baudRate)
     * <br>
     * Connect to NUR module using serial port transport.
     * <br>
     * <br>
     * @sa NurApiConnectSerialPort(), NurApiConnectSocket(), NurApiConnectTransport(), NurApiConnect(), NurApiConnectTransportSpec(),
     * <br>
     * NurApiIsConnected(), NurApiDisconnect()
     * <br>
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    port        Serial port (COM) port number to connect.
     * <br>
     * @param    baudRate    Connection port baud rate. Default is 115200 (NUR_DEFAULT_BAUDRATE)
     * <br>
     * @return 0 if connection succeeded, non-zero error code on failure.<br>
     * Original signature : <code>int NurApiConnectSerialPort(HANDLE, int, int)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1142</i>
     */
    public static int NurApiConnectSerialPort(Pointer<?> hApi, int port, int baudRate) {
        return NurApiConnectSerialPort(Pointer.getPeer(hApi), port, baudRate);
    }

    protected native static int NurApiConnectSerialPort(@Ptr long hApi, int port, int baudRate);

    /**
     * @fn int NurApiConnectSerialPortEx(HANDLE hApi, const TCHAR *portName, int baudRate)
     * <br>
     * Connect to NUR module using serial port transport.
     * <br>
     * <br>
     * @sa NurApiConnectSerialPort(), NurApiConnectSocket(), NurApiConnectTransport(), NurApiConnect(), NurApiConnectTransportSpec(),
     * <br>
     * NurApiIsConnected(), NurApiDisconnect()
     * <br>
     * <br>
     * @param    hApi         Handle to valid NurApi object instance.
     * <br>
     * @param    portName    Pointer to the serial port's name e.g "COM2:", "\\\\.\\COM10"
     * <br>
     * @param    baudRate    Connection port baud rate. Default is 115200 (NUR_DEFAULT_BAUDRATE)
     * <br>
     * @return 0 if connection succeeded, non-zero error code on failure.<br>
     * Original signature : <code>int NurApiConnectSerialPortEx(HANDLE, const TCHAR*, int)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1156</i>
     */
    public static int NurApiConnectSerialPortEx(Pointer<?> hApi, Pointer<Byte> portName, int baudRate) {
        return NurApiConnectSerialPortEx(Pointer.getPeer(hApi), Pointer.getPeer(portName), baudRate);
    }

    protected native static int NurApiConnectSerialPortEx(@Ptr long hApi, @Ptr long portName, int baudRate);

    /**
     * @fn int NurApiConnectSocket(HANDLE hApi, const TCHAR *ip, int port)
     * <br>
     * Connect to NUR module using TCP/IP transport.
     * <br>
     * <br>
     * @sa NurApiConnectSerialPort(), NurApiConnectSocket(), NurApiConnectTransport(), NurApiConnect(), NurApiConnectTransportSpec(),
     * <br>
     * NurApiIsConnected(), NurApiDisconnect()
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    ip            IP address of module.
     * <br>
     * @param    port        TCP/IP port number.
     * <br>
     * @return Zero if connection succeeded, non-zero error code on failure.<br>
     * Original signature : <code>int NurApiConnectSocket(HANDLE, const TCHAR*, int)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1170</i>
     */
    public static int NurApiConnectSocket(Pointer<?> hApi, Pointer<Byte> ip, int port) {
        return NurApiConnectSocket(Pointer.getPeer(hApi), Pointer.getPeer(ip), port);
    }

    protected native static int NurApiConnectSocket(@Ptr long hApi, @Ptr long ip, int port);

    /**
     * @fn int NurApiConnectAppleBLE(HANDLE hApi, void * readDataFunction, void * writeDataFunction, void * disconnectFunction)
     * <br>
     * Connect to NUR module using Apple Bluetooth LE transport.
     * <br>
     * <br>
     * @sa NurApiConnectSerialPort(), NurApiConnectSocket(), NurApiConnectTransport(), NurApiConnect(), NurApiConnectTransportSpec(),
     * <br>
     * NurApiIsConnected(), NurApiDisconnect()
     * <br>
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    readDataFunction    a function that handles reading data from the Bluetooth LE stack.
     * <br>
     * @param    writeDataFunction a function that handles writing data to the Bluetooth LE stack.
     * <br>
     * @param    disconnectFunction a function that handles disconnecting from the Bluetooth LE stack.
     * <br>
     * @return Zero if connection succeeded, non-zero error code on failure.<br>
     * Original signature : <code>int NurApiConnectAppleBLE(HANDLE, void*, void*, void*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1185</i>
     */
    public static int NurApiConnectAppleBLE(Pointer<?> hApi, Pointer<?> readDataFunction, Pointer<?> writeDataFunction, Pointer<?> disconnectFunction) {
        return NurApiConnectAppleBLE(Pointer.getPeer(hApi), Pointer.getPeer(readDataFunction), Pointer.getPeer(writeDataFunction), Pointer.getPeer(disconnectFunction));
    }

    protected native static int NurApiConnectAppleBLE(@Ptr long hApi, @Ptr long readDataFunction, @Ptr long writeDataFunction, @Ptr long disconnectFunction);

    /**
     * @fn int NurApiStopServer(HANDLE hApi)
     * <br>
     * Stop TCP/IP server. Server thread exit. Client connections will remains if any.
     * <br>
     * <br>
     * @sa NurApiStartServer(), NUR_NOTIFICATION_CLIENTCONNECTED, NUR_NOTIFICATION_CLIENTDISCONNECTED
     * <br>
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @return Zero if server stopped succesfully, non-zero error code on failure.<br>
     * Original signature : <code>int NurApiStopServer(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1196</i>
     */
    public static int NurApiStopServer(Pointer<?> hApi) {
        return NurApiStopServer(Pointer.getPeer(hApi));
    }

    protected native static int NurApiStopServer(@Ptr long hApi);

    /**
     * @fn int NurApiStartServer(HANDLE hApi,int port,int maxClients)
     * <br>
     * Start TCP/IP server for listening incoming connections.
     * <br>
     * When client connects, "NUR_NOTIFICATION_CLIENTCONNECTED" notification sent
     * <br>
     * When client disconnects "NUR_NOTIFICATION_CLIENTDISCONNECTED" notification sent
     * <br>
     * @sa NurApiStopServer(), NUR_NOTIFICATION_CLIENTCONNECTED, NUR_NOTIFICATION_CLIENTDISCONNECTED
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    port        Listening port
     * <br>
     * @param    maxClients    Maximum number of clients allowing to connect. If value 0, then no restrictions how many clients will connect.
     * <br>
     * @return Zero if server started succesfully, non-zero error code on failure.<br>
     * Original signature : <code>int NurApiStartServer(HANDLE, int, int)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1210</i>
     */
    public static int NurApiStartServer(Pointer<?> hApi, int port, int maxClients) {
        return NurApiStartServer(Pointer.getPeer(hApi), port, maxClients);
    }

    protected native static int NurApiStartServer(@Ptr long hApi, int port, int maxClients);

    /**
     * @fn int NurApiConnectUsb(HANDLE hApi, const TCHAR *devpath)
     * <br>
     * <br>
     * Connect to NUR module using USB transport.
     * <br>
     * <br>
     * @sa NurApiConnectSerialPort(), NurApiConnectSocket(), NurApiConnectTransport(), NurApiConnect(), NurApiConnectTransportSpec(),
     * <br>
     * NurApiIsConnected(), NurApiDisconnect(), NurUSBEnumerateDevices()
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    devpath        Device path returned by NurUSBEnumerateDevices() function.
     * <br>
     * <br>
     * @return 0 if connection succeeded, non-zero error code on failure.<br>
     * Original signature : <code>int NurApiConnectUsb(HANDLE, const TCHAR*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1225</i>
     */
    public static int NurApiConnectUsb(Pointer<?> hApi, Pointer<Byte> devpath) {
        return NurApiConnectUsb(Pointer.getPeer(hApi), Pointer.getPeer(devpath));
    }

    protected native static int NurApiConnectUsb(@Ptr long hApi, @Ptr long devpath);

    /**
     * @fn int NurApiSetUsbAutoConnect(HANDLE hApi, BOOL useAutoConnect)
     * <br>
     * Enable USB auto connect functionality.
     * <br>
     * When enabled NurApi will automatically connect NUR module device when USB is connected.
     * <br>
     *
     * <br>
     * @sa NurApiGetUsbAutoConnect()
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    useAutoConnect    TRUE to enable, FALSE to disable.
     * <br>
     *
     * <br>
     * @return 0 if succeeded, non-zero error code on failure.<br>
     * Original signature : <code>int NurApiSetUsbAutoConnect(HANDLE, BOOL)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1239</i>
     */
    public static int NurApiSetUsbAutoConnect(Pointer<?> hApi, int useAutoConnect) {
        return NurApiSetUsbAutoConnect(Pointer.getPeer(hApi), useAutoConnect);
    }

    protected native static int NurApiSetUsbAutoConnect(@Ptr long hApi, int useAutoConnect);

    /**
     * @param funcPtr Pointer to callback function
     *                <br>
     * @param arg     Application specific argument pointer. This is passed to callback
     *                <br>
     * @return Number of connected USB devices found.<br>
     * Original signature : <code>DWORD NurUSBEnumerateDevices(NurUSBEnumDeviceFunction, LPVOID)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1250</i>
     * @fn int NurUSBEnumerateDevices(NurUSBEnumDeviceFunction funcPtr, LPVOID arg)
     * <br>
     * Enumerate all USB connected NUR devices.
     * <br>
     * NOTE: This function works only in WIN32 target
     * <br>
     * <br>
     */
    public static int NurUSBEnumerateDevices(Pointer<NurUSBEnumDeviceFunction> funcPtr, Pointer<?> arg) {
        return NurUSBEnumerateDevices(Pointer.getPeer(funcPtr), Pointer.getPeer(arg));
    }

    protected native static int NurUSBEnumerateDevices(@Ptr long funcPtr, @Ptr long arg);

    /**
     * @fn BOOL NurApiGetUsbAutoConnect()
     * <br>
     * <br>
     * Get state of the USB auto connect.
     * <br>
     *
     * <br>
     * @sa NurApiSetUsbAutoConnect()
     * <br>
     *
     * <br>
     * @return TRUE if USB autoconnect is enabled, FALSE if disabled.<br>
     * Original signature : <code>BOOL NurApiGetUsbAutoConnect()</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1261</i>
     */
    public static native int NurApiGetUsbAutoConnect();

    /**
     * @fn int NurApiConnectIntegratedReader(HANDLE hApi)
     * <br>
     *
     * <br>
     * Connect to a integrated reader in supported mobile devices.
     * <br>
     * Currently Nordic ID Merlin and Nordic ID Morphic are supported.
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     *
     * <br>
     * @return 0 if succeeded, non-zero error code on failure.<br>
     * Original signature : <code>int NurApiConnectIntegratedReader(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1273</i>
     */
    public static int NurApiConnectIntegratedReader(Pointer<?> hApi) {
        return NurApiConnectIntegratedReader(Pointer.getPeer(hApi));
    }

    protected native static int NurApiConnectIntegratedReader(@Ptr long hApi);

    /**
     * @fn int NurApiConnectTransport(HANDLE hApi, const TCHAR *transportType, LPVOID connectSpec)
     * <br>
     * Connect to NUR module with named transport and connect spec.
     * <br>
     * <br>
     * @sa NurApiConnectSerialPort(), NurApiConnectSocket(), NurApiConnectTransport(), NurApiConnect(), NurApiConnectTransportSpec(),
     * <br>
     * NurApiIsConnected(), NurApiDisconnect()
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    transportType    Type of transport to create.
     * <br>
     * @param    connectSpec        Transport specific connect spec.
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiConnectTransport(HANDLE, const TCHAR*, LPVOID)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1287</i>
     */
    public static int NurApiConnectTransport(Pointer<?> hApi, Pointer<Byte> transportType, Pointer<?> connectSpec) {
        return NurApiConnectTransport(Pointer.getPeer(hApi), Pointer.getPeer(transportType), Pointer.getPeer(connectSpec));
    }

    protected native static int NurApiConnectTransport(@Ptr long hApi, @Ptr long transportType, @Ptr long connectSpec);

    /**
     * @fn int NurApiConnectTransportSpec(HANDLE hApi, LPVOID connectSpec)
     * <br>
     * Connect transport layer with new connect spec.
     * <br>
     * NOTE: This will cause current transport to disconnect, if connected.
     * <br>
     * <br>
     * @sa NurApiConnectSerialPort(), NurApiConnectSocket(), NurApiConnectTransport(), NurApiConnect(), NurApiConnectTransportSpec(),
     * <br>
     * NurApiIsConnected(), NurApiDisconnect()
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    connectSpec        New transport specific connect spec.
     * <br>
     * @return 0 if connection succeeded, non-zero error code on failure.<br>
     * Original signature : <code>int NurApiConnectTransportSpec(HANDLE, LPVOID)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1301</i>
     */
    public static int NurApiConnectTransportSpec(Pointer<?> hApi, Pointer<?> connectSpec) {
        return NurApiConnectTransportSpec(Pointer.getPeer(hApi), Pointer.getPeer(connectSpec));
    }

    protected native static int NurApiConnectTransportSpec(@Ptr long hApi, @Ptr long connectSpec);

    /**
     * @fn int NurApiDisconnect(HANDLE hApi)
     * <br>
     * Disconnect module connection.
     * <br>
     * <br>
     * @sa NurApiConnectSerialPort(), NurApiConnectSocket(), NurApiConnectTransport(), NurApiConnect(), NurApiConnectTransportSpec(),
     * <br>
     * NurApiIsConnected(), NurApiDisconnect()
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiDisconnect(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1313</i>
     */
    public static int NurApiDisconnect(Pointer<?> hApi) {
        return NurApiDisconnect(Pointer.getPeer(hApi));
    }

    protected native static int NurApiDisconnect(@Ptr long hApi);

    /**
     * @fn int NurApiPing(HANDLE hApi, TCHAR *resp)
     * <br>
     * Test module connectivity.
     * <br>
     * @param    hApi    Handle to valid NurApi object instance.
     * <br>
     * @param    resp    Pointer to a buffer that receives ping response. This parameter can be NULL. <b>NOTE: If not NULL, buffer must be atleast 16 TCHARs long</b>.
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiPing(HANDLE, TCHAR*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1322</i>
     */
    public static int NurApiPing(Pointer<?> hApi, Pointer<Byte> resp) {
        return NurApiPing(Pointer.getPeer(hApi), Pointer.getPeer(resp));
    }

    protected native static int NurApiPing(@Ptr long hApi, @Ptr long resp);

    /**
     * @fn int NurApiSetTitle(HANDLE hApi, TCHAR *title)
     * <br>
     * Set Title string to NUR module. Title can be used for giving frienly name to reader device. Support NUR Fw 2.6.0, later or NURL2
     * <br>
     * @param    hApi    Handle to valid NurApi object instance.
     * <br>
     * @param    title    Pointer to a buffer containing title string to NUR module. <b>NOTE: Set buffer size at least 32 TCHARs long</b>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiSetTitle(HANDLE, TCHAR*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1331</i>
     */
    public static int NurApiSetTitle(Pointer<?> hApi, Pointer<Byte> title) {
        return NurApiSetTitle(Pointer.getPeer(hApi), Pointer.getPeer(title));
    }

    protected native static int NurApiSetTitle(@Ptr long hApi, @Ptr long title);

    /**
     * @fn int NurApiGetTitle(HANDLE hApi, TCHAR *title)
     * <br>
     * Get Title string from NUR module. Title can be used for giving frienly name to reader device. Support NUR Fw 2.6.0, later or NURL2
     * <br>
     * @param    hApi    Handle to valid NurApi object instance.
     * <br>
     * @param    title    Pointer to a buffer that receives title string from NUR module. <b>NOTE: Set buffer size at least 32 TCHARs long</b>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetTitle(HANDLE, TCHAR*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1340</i>
     */
    public static int NurApiGetTitle(Pointer<?> hApi, Pointer<Byte> title) {
        return NurApiGetTitle(Pointer.getPeer(hApi), Pointer.getPeer(title));
    }

    protected native static int NurApiGetTitle(@Ptr long hApi, @Ptr long title);

    /**
     * @fn int NurApiBeep(HANDLE hApi, int frequency, int time, int duty)
     * <br>
     * This will cause devices with beep functionality to beep.
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    frequency    Beep frequency in Hz. Range 500 - 4000.
     * <br>
     * @param    time        Beep duration in milliseconds. Range 20 - 1000.
     * <br>
     * @param    duty        Beeper duty cycle, 50 is loudest. Range 5 - 95.
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiBeep(HANDLE, int, int, int)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1352</i>
     */
    public static int NurApiBeep(Pointer<?> hApi, int frequency, int time, int duty) {
        return NurApiBeep(Pointer.getPeer(hApi), frequency, time, duty);
    }

    protected native static int NurApiBeep(@Ptr long hApi, int frequency, int time, int duty);

    /**
     * @fn int NurApiGetBaudrate(HANDLE hApi, int *setting, int *realBaudrate)
     * <br>
     * Get NUR module baudrate setting.
     * <br>
     * <br>
     * @sa NurApiSetBaudrate(), enum NUR_BAUDRATE
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    setting            Pointer to a integer that receives current NUR module baudrate setting. see enum NUR_BAUDRATE
     * <br>
     * @param    realBaudrate    Pointer to a integer that receives baudrate in bps.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetBaudrate(HANDLE, int*, int*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1366</i>
     */
    public static int NurApiGetBaudrate(Pointer<?> hApi, Pointer<Integer> setting, Pointer<Integer> realBaudrate) {
        return NurApiGetBaudrate(Pointer.getPeer(hApi), Pointer.getPeer(setting), Pointer.getPeer(realBaudrate));
    }

    protected native static int NurApiGetBaudrate(@Ptr long hApi, @Ptr long setting, @Ptr long realBaudrate);

    /**
     * @fn int NurApiSetCommTimeout(HANDLE hApi, DWORD tmo)
     * <br>
     * Set communication timeout.
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    tmo                Communication timeout in seconds. Range is 3...15.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiSetCommTimeout(HANDLE, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1377</i>
     */
    public static int NurApiSetCommTimeout(Pointer<?> hApi, int tmo) {
        return NurApiSetCommTimeout(Pointer.getPeer(hApi), tmo);
    }

    protected native static int NurApiSetCommTimeout(@Ptr long hApi, int tmo);

    /**
     * @fn int NurApiGetCommTimeout(HANDLE hApi, DWORD *tmo)
     * <br>
     * Get communication timeout.
     * <br>
     * <br>
     * @param    hApi            Valid NUR API handle.
     * <br>
     * @param    tmo                Pointer to where the current communication timeout is stored to. Unit is seconds.
     * <br>
     *
     * <br>
     * @return TRUE if pointer parameter is not NULL and API handle is valid.<br>
     * Original signature : <code>BOOL NurApiGetCommTimeout(HANDLE, DWORD*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1388</i>
     */
    public static int NurApiGetCommTimeout(Pointer<?> hApi, Pointer<Integer> tmo) {
        return NurApiGetCommTimeout(Pointer.getPeer(hApi), Pointer.getPeer(tmo));
    }

    protected native static int NurApiGetCommTimeout(@Ptr long hApi, @Ptr long tmo);

    /**
     * @param base      1st channel's center frequency in kHz
     *                  <br>
     * @param nChan     Number of channels
     *                  <br>
     * @param chSpace   Channel width in kHz
     *                  <br>
     * @param chTime    Channel time
     *                  <br>
     * @param pauseTime Idle time between channel change if any.
     *                  <br>
     * @param lf        Maximum link frequency.
     *                  <br>
     * @param Tari      Tari definition; 1 = 12.5 and 2 = 25us.
     *                  <br>
     * @param shuffle   API shuffles the resulting table.
     *                  <br>
     *
     *                  <br>
     * @fn int NurApiBuildCustomHoptable(HANDLE hApi, DWORD base, DWORD nChan, DWORD chSpace, DWORD chTime, DWORD pauseTime, DWORD lf, DWORD Tari, BOOL shuffle)
     * <br>
     * Build a custom hoptable and store it into the module.
     * <br>
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiBuildCustomHoptable(HANDLE, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, BOOL)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1406</i>
     */
    public static int NurApiBuildCustomHoptable(Pointer<?> hApi, int base, int nChan, int chSpace, int chTime, int pauseTime, int lf, int Tari, int shuffle) {
        return NurApiBuildCustomHoptable(Pointer.getPeer(hApi), base, nChan, chSpace, chTime, pauseTime, lf, Tari, shuffle);
    }

    protected native static int NurApiBuildCustomHoptable(@Ptr long hApi, int base, int nChan, int chSpace, int chTime, int pauseTime, int lf, int Tari, int shuffle);

    /**
     * @param hApi      Handle to valid NurApi object instance.
     *                  <br>
     * @param freqs     Pointer to the frequencies.
     *                  <br>
     * @param nChan     Number of channels
     *                  <br>
     * @param chTime    Channel time
     *                  <br>
     * @param pauseTime Idle time between channel change if any.
     *                  <br>
     * @param lf        Maximum link frequency.
     *                  <br>
     * @param Tari      Tari definition; 1 = 12.5 and 2 = 25us.
     *                  <br>
     * @fn int NurApiSetCustomHoptable(HANDLE hApi, DWORD *freqs, DWORD nChan, DWORD chTime, DWORD pauseTime, DWORD lf, DWORD Tari)
     * <br>
     * Set pre-built custom hop table.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiSetCustomHoptable(HANDLE, DWORD*, DWORD, DWORD, DWORD, DWORD, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1421</i>
     */
    public static int NurApiSetCustomHoptable(Pointer<?> hApi, Pointer<Integer> freqs, int nChan, int chTime, int pauseTime, int lf, int Tari) {
        return NurApiSetCustomHoptable(Pointer.getPeer(hApi), Pointer.getPeer(freqs), nChan, chTime, pauseTime, lf, Tari);
    }

    protected native static int NurApiSetCustomHoptable(@Ptr long hApi, @Ptr long freqs, int nChan, int chTime, int pauseTime, int lf, int Tari);

    /**
     * @param hApi       Handle to valid NurApi object instance.
     *                   <br>
     * @param freqs      Pointer to the frequencies.
     *                   <br>
     * @param nChan      Number of channels
     *                   <br>
     * @param chTime     Channel time
     *                   <br>
     * @param pauseTime  Idle time between channel change if any.
     *                   <br>
     * @param lf         Maximum link frequency.
     *                   <br>
     * @param Tari       Tari definition; 1 = 12.5 and 2 = 25us.
     *                   <br>
     * @param lbtThresh  LBT threshold if used (minimum = -90).
     *                   <br>
     * @param maxTxLevel Maximum TX level. Range is 0...19.
     *                   <br>
     *                   <br>
     * @fn int NurApiSetCustomHoptableEx(HANDLE hApi, DWORD *freqs, DWORD nChan, DWORD chTime, DWORD pauseTime, DWORD lf, DWORD Tari, int lbtThresh, DWORD maxTxLevel)
     * <br>
     * <br>
     * Set pre-built custom hop table.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiSetCustomHoptableEx(HANDLE, DWORD*, DWORD, DWORD, DWORD, DWORD, DWORD, int, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1440</i>
     */
    public static int NurApiSetCustomHoptableEx(Pointer<?> hApi, Pointer<Integer> freqs, int nChan, int chTime, int pauseTime, int lf, int Tari, int lbtThresh, int maxTxLevel) {
        return NurApiSetCustomHoptableEx(Pointer.getPeer(hApi), Pointer.getPeer(freqs), nChan, chTime, pauseTime, lf, Tari, lbtThresh, maxTxLevel);
    }

    protected native static int NurApiSetCustomHoptableEx(@Ptr long hApi, @Ptr long freqs, int nChan, int chTime, int pauseTime, int lf, int Tari, int lbtThresh, int maxTxLevel);

    /**
     * @fn int NurApiGetCustomHoptable(HANDLE hApi, struct NUR_CUSTOMHOP_PARAMS *chp);
     * <br>
     * Get current custom hoptable stored to the module if any.
     * <br>
     * <br>
     * @sa NUR_CUSTOMHOP_PARAMS, NurApiSetCustomHoptable()
     * <br>
     *
     * <br>
     * @param    hApi    Handle to valid NurApi object instance.
     * <br>
     * @param    chp        Pointer to the NUR_CUSTOMHOP_PARAMS structure.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetCustomHoptable(HANDLE, NUR_CUSTOMHOP_PARAMS*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1453</i>
     */
    public static int NurApiGetCustomHoptable(Pointer<?> hApi, Pointer<NUR_CUSTOMHOP_PARAMS> chp) {
        return NurApiGetCustomHoptable(Pointer.getPeer(hApi), Pointer.getPeer(chp));
    }

    protected native static int NurApiGetCustomHoptable(@Ptr long hApi, @Ptr long chp);

    /**
     * @fn int NurApiGetCustomHoptableEx(HANDLE hApi, struct NUR_CUSTOMHOP_PARAMS_EX *chp);
     * <br>
     * Get current custom hoptable stored to the module if any.
     * <br>
     * <br>
     * @sa NUR_CUSTOMHOP_PARAMS_EX, NurApiSetCustomHoptable()
     * <br>
     *
     * <br>
     * @param    hApi    Handle to valid NurApi object instance.
     * <br>
     * @param    chp        Pointer to the NUR_CUSTOMHOP_PARAMS_EX structure.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetCustomHoptableEx(HANDLE, NUR_CUSTOMHOP_PARAMS_EX*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1466</i>
     */
    public static int NurApiGetCustomHoptableEx(Pointer<?> hApi, Pointer<NUR_CUSTOMHOP_PARAMS_EX> chp) {
        return NurApiGetCustomHoptableEx(Pointer.getPeer(hApi), Pointer.getPeer(chp));
    }

    protected native static int NurApiGetCustomHoptableEx(@Ptr long hApi, @Ptr long chp);

    /**
     * @fn int NurApiSetBaudrate(HANDLE hApi, int setting)
     * <br>
     * Set NUR module baudrate setting.
     * <br>
     * <br>
     * @sa NurApiGetBaudrate(), enum NUR_BAUDRATE
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    setting        New NUR module baudrate setting. see enum NUR_BAUDRATE
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiSetBaudrate(HANDLE, int)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1478</i>
     */
    public static int NurApiSetBaudrate(Pointer<?> hApi, int setting) {
        return NurApiSetBaudrate(Pointer.getPeer(hApi), setting);
    }

    protected native static int NurApiSetBaudrate(@Ptr long hApi, int setting);

    /**
     * @fn int NurApiSetSensorConfig(HANDLE hApi, struct NUR_SENSOR_CONFIG *sensors, DWORD sensorsSize)
     * <br>
     * Set NUR module sensor configuration.
     * <br>
     * <br>
     * @sa NurApiSetSensorConfig()
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    sensors            Pointer to a sensor configuration structure.
     * <br>
     * @param    sensorsSize        Size of <i>sensors</i> structure in bytes. Usually: sizeof(struct NUR_SENSOR_CONFIG).
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiSetSensorConfig(HANDLE, NUR_SENSOR_CONFIG*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1491</i>
     */
    public static int NurApiSetSensorConfig(Pointer<?> hApi, Pointer<NUR_SENSOR_CONFIG> sensors, int sensorsSize) {
        return NurApiSetSensorConfig(Pointer.getPeer(hApi), Pointer.getPeer(sensors), sensorsSize);
    }

    protected native static int NurApiSetSensorConfig(@Ptr long hApi, @Ptr long sensors, int sensorsSize);

    /**
     * @fn int NurApiGetSensorConfig(HANDLE hApi, struct NUR_SENSOR_CONFIG *sensors, DWORD sensorsSize)
     * <br>
     * Get NUR module sensor configuration.
     * <br>
     * <br>
     * @sa NurApiGetSensorConfig()
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    sensors            Pinter to a sensor configuration structure that receives module current GPIO configuration.
     * <br>
     * @param    sensorsSize        Size of <i>sensors</i> structure in bytes. Usually: sizeof(struct NUR_SENSOR_CONFIG).
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetSensorConfig(HANDLE, NUR_SENSOR_CONFIG*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1504</i>
     */
    public static int NurApiGetSensorConfig(Pointer<?> hApi, Pointer<NUR_SENSOR_CONFIG> sensors, int sensorsSize) {
        return NurApiGetSensorConfig(Pointer.getPeer(hApi), Pointer.getPeer(sensors), sensorsSize);
    }

    protected native static int NurApiGetSensorConfig(@Ptr long hApi, @Ptr long sensors, int sensorsSize);

    /**
     * @fn int NurApiSetGPIOConfig(HANDLE hApi, struct NUR_GPIO_CONFIG *gpio, DWORD gpioSize)
     * <br>
     * Set NUR module GPIO configuration.
     * <br>
     * <br>
     * @sa NurApiGetGPIOConfig()
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    gpio        Pointer to the GPIO configuration.
     * <br>
     * @param    gpioSize    Size of <i>gpio</i> structure in bytes. Usually: sizeof(struct NUR_GPIO_CONFIG).
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiSetGPIOConfig(HANDLE, NUR_GPIO_CONFIG*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1517</i>
     */
    public static int NurApiSetGPIOConfig(Pointer<?> hApi, Pointer<NUR_GPIO_CONFIG> gpio, int gpioSize) {
        return NurApiSetGPIOConfig(Pointer.getPeer(hApi), Pointer.getPeer(gpio), gpioSize);
    }

    protected native static int NurApiSetGPIOConfig(@Ptr long hApi, @Ptr long gpio, int gpioSize);

    /**
     * @fn int NurApiGetGPIOConfig(HANDLE hApi, struct NUR_GPIO_CONFIG *gpio, DWORD gpioSize)
     * <br>
     * Get NUR module GPIO configuration.
     * <br>
     * <br>
     * @sa NurApiSetGPIOConfig()
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    gpio        Pointer to the GPIO configuration.
     * <br>
     * @param    gpioSize    Size of <i>gpio</i> structure in bytes. Usually: sizeof(struct NUR_GPIO_CONFIG).
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetGPIOConfig(HANDLE, NUR_GPIO_CONFIG*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1530</i>
     */
    public static int NurApiGetGPIOConfig(Pointer<?> hApi, Pointer<NUR_GPIO_CONFIG> gpio, int gpioSize) {
        return NurApiGetGPIOConfig(Pointer.getPeer(hApi), Pointer.getPeer(gpio), gpioSize);
    }

    protected native static int NurApiGetGPIOConfig(@Ptr long hApi, @Ptr long gpio, int gpioSize);

    /**
     * @fn int NurApiSetGPIOStatus(HANDLE hApi, int gpio, BOOL state)
     * <br>
     * Set single GPIO pin state.
     * <br>
     * <b>NOTE: GPIO must be configured as output</b>
     * <br>
     * <br>
     * @sa NurApiSetGPIOStatus(), NUR_GPIO
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    gpio        Zero based GPIO number. see NUR_GPIO
     * <br>
     * @param    state        State to set. TRUE = high, FALSE = low.
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiSetGPIOStatus(HANDLE, int, BOOL)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1544</i>
     */
    public static int NurApiSetGPIOStatus(Pointer<?> hApi, int gpio, int state) {
        return NurApiSetGPIOStatus(Pointer.getPeer(hApi), gpio, state);
    }

    protected native static int NurApiSetGPIOStatus(@Ptr long hApi, int gpio, int state);

    /**
     * @fn int NurApiGetGPIOStatus(HANDLE hApi, int gpio, struct NUR_GPIO_STATUS *status, DWORD statusSize)
     * <br>
     * Get single GPIO pin state.
     * <br>
     * <br>
     * @sa NurApiGetGPIOStatus(), NUR_GPIO_STATUS, NUR_GPIO
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    gpio        Zero based GPIO number. see NUR_GPIO
     * <br>
     * @param    status        Status of the GPIO pin including enable, direction and low/high information.
     * <br>
     * @param    statusSize    Size of <i>status</i> structure in bytes. Usually: sizeof(struct NUR_GPIO_STATUS).
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetGPIOStatus(HANDLE, int, NUR_GPIO_STATUS*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1558</i>
     */
    public static int NurApiGetGPIOStatus(Pointer<?> hApi, int gpio, Pointer<NUR_GPIO_STATUS> status, int statusSize) {
        return NurApiGetGPIOStatus(Pointer.getPeer(hApi), gpio, Pointer.getPeer(status), statusSize);
    }

    protected native static int NurApiGetGPIOStatus(@Ptr long hApi, int gpio, @Ptr long status, int statusSize);

    /**
     * @fn int NurApiGetRegionInfo(HANDLE hApi, int regionId, struct NUR_REGIONINFO *ri, DWORD riSize)
     * <br>
     * Get NUR module specific region's information.
     * <br>
     * <br>
     * @sa NurApiGetReaderInfo()
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance
     * <br>
     * @param    regionId    Region ID. If set to -1, module current region ID is used.
     * <br>
     * @param    ri            Pointer to a NUR_REGIONINFO structure that receives region information.
     * <br>
     * @param    riSize        Size of <i>ri</i> structure in bytes. Usually: sizeof(struct NUR_REGIONINFO).
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetRegionInfo(HANDLE, int, NUR_REGIONINFO*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1573</i>
     */
    public static int NurApiGetRegionInfo(Pointer<?> hApi, int regionId, Pointer<NUR_REGIONINFO> ri, int riSize) {
        return NurApiGetRegionInfo(Pointer.getPeer(hApi), regionId, Pointer.getPeer(ri), riSize);
    }

    protected native static int NurApiGetRegionInfo(@Ptr long hApi, int regionId, @Ptr long ri, int riSize);

    /**
     * @fn int NurApiGetReaderInfo(HANDLE hApi, struct NUR_READERINFO *ri, DWORD riSize)
     * <br>
     * Get general information about the reader.
     * <br>
     *
     * <br>
     * @sa NurApiGetRegionInfo()
     * <br>
     * <br>
     * @param    hApi    Handle to valid NurApi object instance
     * <br>
     * @param    ri        Pointer to the NUR_READERINFO structure.
     * <br>
     * @param    riSize    Size of <i>ri</i> structure in bytes. Usually: sizeof(struct NUR_READERINFO).
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetReaderInfo(HANDLE, NUR_READERINFO*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1587</i>
     */
    public static int NurApiGetReaderInfo(Pointer<?> hApi, Pointer<NUR_READERINFO> ri, int riSize) {
        return NurApiGetReaderInfo(Pointer.getPeer(hApi), Pointer.getPeer(ri), riSize);
    }

    protected native static int NurApiGetReaderInfo(@Ptr long hApi, @Ptr long ri, int riSize);

    /**
     * @fn int NurApiScanSingle(HANDLE hApi, int timeout, struct NUR_TRIGGERREAD_DATA *resp)
     * <br>
     * The single scan is used to read a single tag's EPC contents using a timeout defined in milliseconds.
     * <br>
     *
     * <br>
     * @remarks If there's more than one tag in the reader range, this function will most likely fail.
     * <br>
     *
     * <br>
     * @sa NUR_TRIGGERREAD_DATA, NurApiSimpleInventory()
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    timeout        Timeout in milliseconds. Range 50 - 2000.
     * <br>
     * @param    resp        Pointer to a structure that receives read tag information.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiScanSingle(HANDLE, int, NUR_TRIGGERREAD_DATA*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1603</i>
     */
    public static int NurApiScanSingle(Pointer<?> hApi, int timeout, Pointer<NUR_TRIGGERREAD_DATA> resp) {
        return NurApiScanSingle(Pointer.getPeer(hApi), timeout, Pointer.getPeer(resp));
    }

    protected native static int NurApiScanSingle(@Ptr long hApi, int timeout, @Ptr long resp);

    /**
     * @fn int NurApiSimpleInventory(HANDLE hApi, struct NUR_INVENTORY_RESPONSE *resp)
     * <br>
     * Perform Inventory command.
     * <br>
     * This function uses rounds, Q and session values from current module settings.
     * <br>
     *
     * <br>
     * @sa NurApiInventory(), NurApiInventorySelect32(), NurApiInventorySelectByEPC(), NUR_INVENTORY_RESPONSE
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    resp        Pointer to a structure that receives inventory response.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiSimpleInventory(HANDLE, NUR_INVENTORY_RESPONSE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1617</i>
     */
    public static int NurApiSimpleInventory(Pointer<?> hApi, Pointer<NUR_INVENTORY_RESPONSE> resp) {
        return NurApiSimpleInventory(Pointer.getPeer(hApi), Pointer.getPeer(resp));
    }

    protected native static int NurApiSimpleInventory(@Ptr long hApi, @Ptr long resp);

    /**
     * @fn int NurApiInventory(HANDLE hApi, int rounds, int Q, int session, struct NUR_INVENTORY_RESPONSE *resp)
     * <br>
     * Perform Inventory command.
     * <br>
     * <br>
     * @sa NurApiSimpleInventory(), NurApiInventorySelect32(), NurApiInventorySelectByEPC(), NUR_INVENTORY_RESPONSE
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    rounds            Full query rounds to perform in inventory. Range 0 - 10. Value 0 means automatic round number.
     * <br>
     * @param    Q                The Q parameter. Range 0 - 15. Value 0 means automatic Q calculation.
     * <br>
     * @param    session            The session parameter. Range 0 - 3.
     * <br>
     * @param    resp            Pointer to a structure that receives inventory response.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiInventory(HANDLE, int, int, int, NUR_INVENTORY_RESPONSE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1633</i>
     */
    public static int NurApiInventory(Pointer<?> hApi, int rounds, int Q, int session, Pointer<NUR_INVENTORY_RESPONSE> resp) {
        return NurApiInventory(Pointer.getPeer(hApi), rounds, Q, session, Pointer.getPeer(resp));
    }

    protected native static int NurApiInventory(@Ptr long hApi, int rounds, int Q, int session, @Ptr long resp);

    /**
     * @fn int NurApiSetInventoryPeriod(HANDLE hApi, int level, BOOL save)
     * <br>
     * Configure the inventory stream's duty cycle.
     * <br>
     * <br>
     * @sa enum NUR_AUTOPERIOD
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    level            Defined by NUR_AUTOPERIOD: 0...3.
     * <br>
     * @param    save            If set to TRUE then the module stores this setting into its non-volatile memory.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiSetInventoryPeriod(HANDLE, int, BOOL)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1647</i>
     */
    public static int NurApiSetInventoryPeriod(Pointer<?> hApi, int level, int save) {
        return NurApiSetInventoryPeriod(Pointer.getPeer(hApi), level, save);
    }

    protected native static int NurApiSetInventoryPeriod(@Ptr long hApi, int level, int save);

    /**
     * @fn int NurApiGetInventoryPeriod(HANDLE hApi, int *level)
     * <br>
     * Get the current duty cycle for inventory stream.
     * <br>
     * <br>
     * @sa enum NUR_AUTOPERIOD
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    level            Pointer to where the currnet level is to be store. Must not be NULL.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetInventoryPeriod(HANDLE, int*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1660</i>
     */
    public static int NurApiGetInventoryPeriod(Pointer<?> hApi, Pointer<Integer> level) {
        return NurApiGetInventoryPeriod(Pointer.getPeer(hApi), Pointer.getPeer(level));
    }

    protected native static int NurApiGetInventoryPeriod(@Ptr long hApi, @Ptr long level);

    /**
     * @fn int NurApiInventorySelect32(HANDLE hApi, int rounds, int Q, int session, BOOL invertSelect,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask,
     * <br>
     * struct NUR_INVENTORY_RESPONSE *resp)
     * <br>
     * <br>
     * Perform Inventory command with specific tag singulation.
     * <br>
     * Tags can be singluted against desired memory bank and data mask.
     * <br>
     * <br>
     * @sa NurApiSimpleInventory(), NurApiInventory(), NurApiInventorySelectByEPC(), NUR_INVENTORY_RESPONSE
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    rounds                Full query rounds to perform. Range 0 - 10. Value 0 means automatic round number.
     * <br>
     * @param    Q                    The Q parameter. Range 0 - 15. Value 0 means automatic Q calculation.
     * <br>
     * @param    session                The session parameter. Accepted range is 0 - 3.
     * <br>
     * @param    invertSelect        Invert select. Select tags that do not match the selection criteria.
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     * @param    resp                Pointer to a inventory response structure.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiInventorySelect32(HANDLE, int, int, int, BOOL, BYTE, DWORD, int, BYTE*, NUR_INVENTORY_RESPONSE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1686</i>
     */
    public static int NurApiInventorySelect32(Pointer<?> hApi, int rounds, int Q, int session, int invertSelect, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, Pointer<NUR_INVENTORY_RESPONSE> resp) {
        return NurApiInventorySelect32(Pointer.getPeer(hApi), rounds, Q, session, invertSelect, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), Pointer.getPeer(resp));
    }

    protected native static int NurApiInventorySelect32(@Ptr long hApi, int rounds, int Q, int session, int invertSelect, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, @Ptr long resp);

    /**
     * @fn int NurApiInventorySelectByEPC(HANDLE hApi, int rounds, int Q, int session, BOOL invertSelect,
     * <br>
     * BYTE *epcBuffer, DWORD epcBufferLen,
     * <br>
     * struct NUR_INVENTORY_RESPONSE *resp)
     * <br>
     * <br>
     * Perform Inventory command with tag singulated against EPC.
     * <br>
     * <br>
     * @sa NurApiSimpleInventory(), NurApiInventory(), NurApiInventorySelect32(), NUR_INVENTORY_RESPONSE
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    rounds                Full query rounds to perform. Range 0 - 10. Value 0 means automatic round number.
     * <br>
     * @param    Q                    The Q parameter. Range 0 - 15. Value 0 means automatic Q calculation.
     * <br>
     * @param    session                The session parameter. Accepted range is 0 - 3.
     * <br>
     * @param    invertSelect        Invert select. Select tags that do not match the selection criteria.
     * <br>
     * @param    epcBuffer            EPC memory to singulate against.
     * <br>
     * @param    epcBufferLen        Size of epcBuffer in bytes.
     * <br>
     * @param    resp                Pointer to a inventory response structure.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiInventorySelectByEPC(HANDLE, int, int, int, BOOL, BYTE*, DWORD, NUR_INVENTORY_RESPONSE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1708</i>
     */
    public static int NurApiInventorySelectByEPC(Pointer<?> hApi, int rounds, int Q, int session, int invertSelect, Pointer<Byte> epcBuffer, int epcBufferLen, Pointer<NUR_INVENTORY_RESPONSE> resp) {
        return NurApiInventorySelectByEPC(Pointer.getPeer(hApi), rounds, Q, session, invertSelect, Pointer.getPeer(epcBuffer), epcBufferLen, Pointer.getPeer(resp));
    }

    protected native static int NurApiInventorySelectByEPC(@Ptr long hApi, int rounds, int Q, int session, int invertSelect, @Ptr long epcBuffer, int epcBufferLen, @Ptr long resp);

    /**
     * @fn int NurApiStartInventoryStream(HANDLE hApi, int rounds, int Q, int session)
     * <br>
     * <br>
     * Start inventory streaming on module.
     * <br>
     * Module will start continuos inventory and sends new tags to host as notification.
     * <br>
     * By default notification is sent only when there's tag(s) available, if you need zero round information
     * <br>
     * it can configured with setup opFlags (enum NUR_OPFLAGS).
     * <br>
     * <br>
     * @sa NurApiStopInventoryStream(), NUR_INVENTORYSTREAM_DATA, NUR_OPFLAGS
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    rounds                Full query rounds to perform. Range 0 - 10. Value 0 means automatic round number.
     * <br>
     * @param    Q                    The Q parameter. Range 0 - 15. Value 0 means automatic Q calculation.
     * <br>
     * @param    session                The session parameter. Accepted range is 0 - 3.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiStartInventoryStream(HANDLE, int, int, int)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1727</i>
     */
    public static int NurApiStartInventoryStream(Pointer<?> hApi, int rounds, int Q, int session) {
        return NurApiStartInventoryStream(Pointer.getPeer(hApi), rounds, Q, session);
    }

    protected native static int NurApiStartInventoryStream(@Ptr long hApi, int rounds, int Q, int session);

    /**
     * @fn int NurApiStartSimpleInventoryStream(HANDLE hApi)
     * <br>
     * <br>
     * Start inventory streaming on module.
     * <br>
     * Module will start continuos inventory and sends new tags to host as notification.
     * <br>
     * By default notification is sent only when there's tag(s) available, if you need zero round information
     * <br>
     * it can configured with setup opFlags (enum NUR_OPFLAGS).
     * <br>
     * <b>This function uses rounds, Q and session values from current module settings.</b>
     * <br>
     * <br>
     * @sa NurApiStopInventoryStream(), NUR_INVENTORYSTREAM_DATA, NUR_OPFLAGS
     * <br>
     * <br>
     * @param    hApi    Handle to valid NurApi object instance
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiStartSimpleInventoryStream(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1744</i>
     */
    public static int NurApiStartSimpleInventoryStream(Pointer<?> hApi) {
        return NurApiStartSimpleInventoryStream(Pointer.getPeer(hApi));
    }

    protected native static int NurApiStartSimpleInventoryStream(@Ptr long hApi);

    /**
     * @fn int NurApiStartInventorySelectStream(HANDLE hApi, int rounds, int Q, int session, BOOL invertSelect,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask)
     * <br>
     * <br>
     * Start inventory streaming on module.
     * <br>
     * Module will start continuos inventory and sends new tags to host as notification.
     * <br>
     * By default notification is sent only when there's tag(s) available, if you need zero round information
     * <br>
     * it can configured with setup opFlags (enum NUR_OPFLAGS).
     * <br>
     * Tags can be singluted against desired memory bank and mask.
     * <br>
     * <br>
     * @sa NurApiStopInventoryStream(), NUR_INVENTORYSTREAM_DATA
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    rounds                Full query rounds to perform. Range 0 - 10. Value 0 means automatic round number.
     * <br>
     * @param    Q                    The Q parameter. Range 0 - 15. Value 0 means automatic Q calculation.
     * <br>
     * @param    session                The session parameter. Accepted range is 0 - 3.
     * <br>
     * @param    invertSelect        Invert select. Select tags that do not match the selection criteria.
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiStartInventorySelectStream(HANDLE, int, int, int, BOOL, BYTE, DWORD, int, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1771</i>
     */
    public static int NurApiStartInventorySelectStream(Pointer<?> hApi, int rounds, int Q, int session, int invertSelect, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask) {
        return NurApiStartInventorySelectStream(Pointer.getPeer(hApi), rounds, Q, session, invertSelect, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask));
    }

    protected native static int NurApiStartInventorySelectStream(@Ptr long hApi, int rounds, int Q, int session, int invertSelect, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask);

    /**
     * @fn int NurApiStopInventoryStream(HANDLE hApi)
     * <br>
     * <br>
     * Stop inventory streaming on module.
     * <br>
     * <br>
     * @param    hApi    Handle to valid NurApi object instance
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiStopInventoryStream(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1782</i>
     */
    public static int NurApiStopInventoryStream(Pointer<?> hApi) {
        return NurApiStopInventoryStream(Pointer.getPeer(hApi));
    }

    protected native static int NurApiStopInventoryStream(@Ptr long hApi);

    /**
     * @fn BOOL NurApiIsInventoryStreamRunning(HANDLE hApi)
     * <br>
     * <br>
     * Return TRUE if inventory stream routine is running on module.
     * <br>
     * <br>
     * @param    hApi    Handle to valid NurApi object instance
     * <br>
     * <br>
     * @return TRUE if inventory stream routine is running. FALSE otherwise.<br>
     * Original signature : <code>BOOL NurApiIsInventoryStreamRunning(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1793</i>
     */
    public static int NurApiIsInventoryStreamRunning(Pointer<?> hApi) {
        return NurApiIsInventoryStreamRunning(Pointer.getPeer(hApi));
    }

    protected native static int NurApiIsInventoryStreamRunning(@Ptr long hApi);

    /**
     * @fn int NurApiStartPeriodicInventory(HANDLE hApi, int rounds, int Q, int session)
     * <br>
     * Start periodic inventory command.
     * <br>
     * Inventory commands are executed periodically in loop.
     * <br>
     * Results are sent with the notification NUR_NOTIFICATION_PERIODIC_INVENTORY.
     * <br>
     *
     * <br>
     * @sa NurApiStopPeriodicInventory(), NurApiIsPeriodicInventoryRunning(), NurApiStartInventoryStream()
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    rounds            Full query rounds to perform. Range 0 - 10. Value 0 means automatic round number.
     * <br>
     * @param    Q                The Q parameter. Range 0 - 15. Value 0 means automatic Q calculation.
     * <br>
     * @param    session            The session parameter. Accepted range is 0 - 3.
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiStartPeriodicInventory(HANDLE, int, int, int)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1809</i>
     */
    public static int NurApiStartPeriodicInventory(Pointer<?> hApi, int rounds, int Q, int session) {
        return NurApiStartPeriodicInventory(Pointer.getPeer(hApi), rounds, Q, session);
    }

    protected native static int NurApiStartPeriodicInventory(@Ptr long hApi, int rounds, int Q, int session);

    /**
     * @fn int NurApiStopPeriodicInventory(HANDLE hApi, BOOL waitExit)
     * <br>
     * Stop periodic inventory command.
     * <br>
     * <br>
     * @sa NurApiStartPeriodicInventory(), NurApiIsPeriodicInventoryRunning()
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    waitExit        Wait periodic inventory thread exit.
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiStopPeriodicInventory(HANDLE, BOOL)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1821</i>
     */
    public static int NurApiStopPeriodicInventory(Pointer<?> hApi, int waitExit) {
        return NurApiStopPeriodicInventory(Pointer.getPeer(hApi), waitExit);
    }

    protected native static int NurApiStopPeriodicInventory(@Ptr long hApi, int waitExit);

    /**
     * @fn BOOL NurApiIsPeriodicInventoryRunning(HANDLE hApi)
     * <br>
     * Return TRUE if periodic inventory routine is running.
     * <br>
     * <br>
     * @sa NurApiStartPeriodicInventory(), NurApiStopPeriodicInventory()
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @return TRUE if periodic inventory routine is running. FALSE otherwise.<br>
     * Original signature : <code>BOOL NurApiIsPeriodicInventoryRunning(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1832</i>
     */
    public static int NurApiIsPeriodicInventoryRunning(Pointer<?> hApi) {
        return NurApiIsPeriodicInventoryRunning(Pointer.getPeer(hApi));
    }

    protected native static int NurApiIsPeriodicInventoryRunning(@Ptr long hApi);

    /**
     * @fn int NurApiInventoryEx(HANDLE hApi, struct NUR_INVEX_PARAMS *params,
     * <br>
     * struct NUR_INVEX_FILTER *filters, int filtersCount,
     * <br>
     * struct NUR_INVENTORY_RESPONSE *resp)
     * <br>
     * Extended inventory command with multiple filters.
     * <br>
     * <br>
     * @sa struct NUR_INVEX_PARAMS, struct NUR_INVEX_FILTER
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    params            Pointer to inventory parameters.
     * <br>
     * @param    filters            Pointer to filter array.
     * <br>
     * @param    filtersCount    Number of filter structs in filters array.
     * <br>
     * @param    resp            Pointer to a inventory response structure.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiInventoryEx(HANDLE, NUR_INVEX_PARAMS*, NUR_INVEX_FILTER*, int, NUR_INVENTORY_RESPONSE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1850</i>
     */
    public static int NurApiInventoryEx(Pointer<?> hApi, Pointer<NUR_INVEX_PARAMS> params, Pointer<NUR_INVEX_FILTER> filters, int filtersCount, Pointer<NUR_INVENTORY_RESPONSE> resp) {
        return NurApiInventoryEx(Pointer.getPeer(hApi), Pointer.getPeer(params), Pointer.getPeer(filters), filtersCount, Pointer.getPeer(resp));
    }

    protected native static int NurApiInventoryEx(@Ptr long hApi, @Ptr long params, @Ptr long filters, int filtersCount, @Ptr long resp);

    /**
     * @fn int NurApiRerunInventoryEx(HANDLE hApi, struct NUR_INVENTORY_RESPONSE *resp)
     * <br>
     *
     * <br>
     * Re-run te extended inventory with last set parameters. Requires at least one successful call to single extended inventory or
     * <br>
     * extended inventory stream prior to this call.
     * <br>
     * <br>
     * @sa struct NUR_INVENTORY_RESPONSE
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    resp            Pointer to a inventory response structure.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiRerunInventoryEx(HANDLE, NUR_INVENTORY_RESPONSE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1865</i>
     */
    public static int NurApiRerunInventoryEx(Pointer<?> hApi, Pointer<NUR_INVENTORY_RESPONSE> resp) {
        return NurApiRerunInventoryEx(Pointer.getPeer(hApi), Pointer.getPeer(resp));
    }

    protected native static int NurApiRerunInventoryEx(@Ptr long hApi, @Ptr long resp);

    /**
     * @fn int NurApiStartInventoryEx(HANDLE hApi, struct NUR_INVEX_PARAMS *params,
     * <br>
     * struct NUR_INVEX_FILTER *filters, int filtersCount)
     * <br>
     * Start extended inventory streaming command with multiple filters.
     * <br>
     * <br>
     * @sa struct NUR_INVEX_PARAMS, struct NUR_INVEX_FILTER
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    params            Pointer to inventory parameters.
     * <br>
     * @param    filters            Pointer to filter array.
     * <br>
     * @param    filtersCount    Number of filter structs in filters array.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiStartInventoryEx(HANDLE, NUR_INVEX_PARAMS*, NUR_INVEX_FILTER*, int)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1881</i>
     */
    public static int NurApiStartInventoryEx(Pointer<?> hApi, Pointer<NUR_INVEX_PARAMS> params, Pointer<NUR_INVEX_FILTER> filters, int filtersCount) {
        return NurApiStartInventoryEx(Pointer.getPeer(hApi), Pointer.getPeer(params), Pointer.getPeer(filters), filtersCount);
    }

    protected native static int NurApiStartInventoryEx(@Ptr long hApi, @Ptr long params, @Ptr long filters, int filtersCount);

    /**
     * @fn int NurApiStopInventoryEx(HANDLE hApi)
     * <br>
     * Stop extended inventory streaming in module.
     * <br>
     * <br>
     * @sa struct NUR_INVEX_PARAMS, struct NUR_INVEX_FILTER
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiStopInventoryEx(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1893</i>
     */
    public static int NurApiStopInventoryEx(Pointer<?> hApi) {
        return NurApiStopInventoryEx(Pointer.getPeer(hApi));
    }

    protected native static int NurApiStopInventoryEx(@Ptr long hApi);

    /**
     * @fn BOOL NurApiIsInventoryExRunning(HANDLE hApi)
     * <br>
     * Return TRUE if streaming extended inventory routine is running.
     * <br>
     * <br>
     * @sa NurApiStartInventoryEx(), NurApiStopInventoryEx()
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @return TRUE if streaming extended inventory routine is running. FALSE otherwise.<br>
     * Original signature : <code>BOOL NurApiIsInventoryExRunning(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1904</i>
     */
    public static int NurApiIsInventoryExRunning(Pointer<?> hApi) {
        return NurApiIsInventoryExRunning(Pointer.getPeer(hApi));
    }

    protected native static int NurApiIsInventoryExRunning(@Ptr long hApi);

    /**
     * @fn int NurApiTIDInventory(HANDLE hApi, DWORD firstWord, DWORD nWords)
     * <br>
     * <br>
     * Configures current inventory so that the TID data is returned instead of EPC in specified manner.
     * <br>
     * <br>
     * @sa NurApiUserMemInventory(), NurApiInventoryRead(), NurApiStartXTIDInventory
     * <br>
     * @sa NurApiInventoryRead(), NurApiGetInventoryRead(), NurApiInventoryReadCtl()
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    firstWord        First word to read from the TID memory.
     * <br>
     * @param    nWords            Number of 16-bit words to read. Range is 1...32.
     * <br>
     * <br>
     * @return Zero when successful, error code otherwise.<br>
     * Original signature : <code>int NurApiTIDInventory(HANDLE, DWORD, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1920</i>
     */
    public static int NurApiTIDInventory(Pointer<?> hApi, int firstWord, int nWords) {
        return NurApiTIDInventory(Pointer.getPeer(hApi), firstWord, nWords);
    }

    protected native static int NurApiTIDInventory(@Ptr long hApi, int firstWord, int nWords);

    /**
     * @fn int NurApiUserMemInventory(HANDLE hApi, DWORD firstWord, DWORD nWords)
     * <br>
     * Configures current inventory so that the user memory data is returned instead of EPC in specified manner.
     * <br>
     * <br>
     * @sa NurApiTIDInventory(), NurApiInventoryRead(), NurApiStartXTIDInventory
     * <br>
     * @sa NurApiInventoryRead(), NurApiGetInventoryRead(), NurApiInventoryReadCtl()
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    firstWord        First word to read from the user memory.
     * <br>
     * @param    nWords            Number of 16-bit words to read. Range is 1..32.
     * <br>
     * <br>
     * @return Zero when successful, error code otherwise.<br>
     * Original signature : <code>int NurApiUserMemInventory(HANDLE, DWORD, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1935</i>
     */
    public static int NurApiUserMemInventory(Pointer<?> hApi, int firstWord, int nWords) {
        return NurApiUserMemInventory(Pointer.getPeer(hApi), firstWord, nWords);
    }

    protected native static int NurApiUserMemInventory(@Ptr long hApi, int firstWord, int nWords);

    /**
     * @fn int NurApiConfigXTIDInventory(HANDLE hApi, BOOL dataOnly, BOOL includeHeader);
     * <br>
     * Configures the TID/XTID based inventory + read.
     * <br>
     * <br>
     * @sa NurApiTIDInventory(), NurApiInventoryRead()
     * <br>
     * @sa NurApiInventoryRead(), NurApiGetInventoryRead(), NurApiInventoryReadCtl()
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    dataOnly        If TRUE then the XTID based read result is returned in the place of the EPC. Otherwise the XTID based read result is appended to the EPC.
     * <br>
     * @param    includeHeader    If this is set to TRUE, then the reader will include all of the TID data in the tag data.
     * <br>
     * <br>
     * @return Zero when successful, error code otherwise.<br>
     * Original signature : <code>int NurApiConfigXTIDInventory(HANDLE, BOOL, BOOL)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1950</i>
     */
    public static int NurApiConfigXTIDInventory(Pointer<?> hApi, int dataOnly, int includeHeader) {
        return NurApiConfigXTIDInventory(Pointer.getPeer(hApi), dataOnly, includeHeader);
    }

    protected native static int NurApiConfigXTIDInventory(@Ptr long hApi, int dataOnly, int includeHeader);

    /**
     * @fn BOOL NurApiInventoryRead(HANDLE hApi, BOOL on, DWORD dwType, DWORD dwBank, DWORD dwAddress, DWORD nWords)
     * <br>
     * Configures following inventoryies to do an inventory + read operation in a specified manner.
     * <br>
     * <br>
     * @sa NurApiTIDInventory(), NurApiUserMemInventory()
     * <br>
     * @sa NurApiGetInventoryRead(), NurApiInventoryReadCtl()
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    on                On / off control; TRUE means on.
     * <br>
     * @param    dwType            Type for inventory + read: 0 = EPC + data, 1 = data only (returned in the EPC field).
     * <br>
     * @param    dwBank            Bank to read from; allowed banks are EPC (1), TID (2) and user memory (3).
     * <br>
     * @param    dwAddress        Word address to start the reading from.
     * <br>
     * @param    nWords            Number of 16-bit words to read. Range is 1..32.
     * <br>
     * <br>
     * @return Zero when successful, error code otherwise.<br>
     * Original signature : <code>int NurApiInventoryRead(HANDLE, BOOL, DWORD, DWORD, DWORD, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1968</i>
     */
    public static int NurApiInventoryRead(Pointer<?> hApi, int on, int dwType, int dwBank, int dwAddress, int nWords) {
        return NurApiInventoryRead(Pointer.getPeer(hApi), on, dwType, dwBank, dwAddress, nWords);
    }

    protected native static int NurApiInventoryRead(@Ptr long hApi, int on, int dwType, int dwBank, int dwAddress, int nWords);

    /**
     * @fn BOOL NurApiGetInventoryRead(HANDLE hApi, struct NUR_IRINFORMATION *pIrInfo)
     * <br>
     * Get current inventory + read configuration.
     * <br>
     * <br>
     * @sa NUR_IRINFORMATION
     * <br>
     * @sa NurApiTIDInventory(), NurApiUserMemInventory()
     * <br>
     * @sa NurApiInventoryRead(), NurApiInventoryReadCtl()
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    pIrInfo            Pointer to NUR_IRINFORMATION structure.
     * <br>
     * <br>
     * @return Zero when successful, error code otherwise.<br>
     * Original signature : <code>int NurApiGetInventoryRead(HANDLE, NUR_IRINFORMATION*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1983</i>
     */
    public static int NurApiGetInventoryRead(Pointer<?> hApi, Pointer<NUR_IRINFORMATION> pIrInfo) {
        return NurApiGetInventoryRead(Pointer.getPeer(hApi), Pointer.getPeer(pIrInfo));
    }

    protected native static int NurApiGetInventoryRead(@Ptr long hApi, @Ptr long pIrInfo);

    /**
     * @fn BOOL NurApiInventoryReadCtl(HANDLE hApi, BOOL on)
     * <br>
     * Control inventory + read; on / off.
     * <br>
     * <br>
     * @sa NurApiTIDInventory(), NurApiUserMemInventory(),
     * <br>
     * @sa NurApiInventoryRead(), NurApiGetInventoryRead()
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    on                Set to TRUE to use inventory + read the wayt it is currently confgured.
     * <br>
     * <br>
     * @return Zero when successful, error code otherwise.<br>
     * Original signature : <code>int NurApiInventoryReadCtl(HANDLE, BOOL)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:1997</i>
     */
    public static int NurApiInventoryReadCtl(Pointer<?> hApi, int on) {
        return NurApiInventoryReadCtl(Pointer.getPeer(hApi), on);
    }

    protected native static int NurApiInventoryReadCtl(@Ptr long hApi, int on);

    /**
     * @fn int NurApiFetchTags(HANDLE hApi, BOOL includeMeta, int *tagsAdded)
     * <br>
     * Fetch all inventoried tags from module.
     * <br>
     * <br>
     * @sa NurApiClearTags(), NurApiGetTagCount(), NurApiGetTagData()
     * <br>
     * <br>
     * @param    hApi     Handle to valid NurApi object instance.
     * <br>
     * @param    includeMeta    TRUE to include meta data, FALSE to exclude. If TRUE, NUR_TAG_DATA will contain all tag meta information.
     * <br>
     * @param    tagsAdded    Number of tags added in internal tag buffer by this fetch is stored here.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiFetchTags(HANDLE, BOOL, int*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2011</i>
     */
    public static int NurApiFetchTags(Pointer<?> hApi, int includeMeta, Pointer<Integer> tagsAdded) {
        return NurApiFetchTags(Pointer.getPeer(hApi), includeMeta, Pointer.getPeer(tagsAdded));
    }

    protected native static int NurApiFetchTags(@Ptr long hApi, int includeMeta, @Ptr long tagsAdded);

    /**
     * @fn int NurApiFetchTagAt(HANDLE hApi, BOOL includeMeta, int tagNum, struct NUR_TAG_DATA_EX *pData, DWORD szData)
     * <br>
     * Fetch a single tag indicated by the tag number.
     * <br>
     * <br>
     * @sa NurApiGetTagCount()
     * <br>
     * <br>
     * @param    hApi     Handle to valid NurApi object instance.
     * <br>
     * @param    includeMeta    TRUE to include meta data, FALSE to exclude. If TRUE, NUR_TAG_DATA will contain all tag meta information.
     * <br>
     * @param    tagNum        Tag number to retrieve (not an actual index).
     * <br>
     * @param    pData        Pointer to the NUR_TAG_DATA_EX structure where the data is stored.
     * <br>
     * @param    szData        Size of the data structure.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiFetchTagAt(HANDLE, BOOL, int, NUR_TAG_DATA_EX*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2027</i>
     */
    public static int NurApiFetchTagAt(Pointer<?> hApi, int includeMeta, int tagNum, Pointer<NUR_TAG_DATA_EX> pData, int szData) {
        return NurApiFetchTagAt(Pointer.getPeer(hApi), includeMeta, tagNum, Pointer.getPeer(pData), szData);
    }

    protected native static int NurApiFetchTagAt(@Ptr long hApi, int includeMeta, int tagNum, @Ptr long pData, int szData);

    /**
     * @fn int NurApiClearTags(HANDLE hApi)
     * <br>
     * Clear previously inventoried tags from memory.
     * <br>
     * <br>
     * @sa NurApiClearTags(), NurApiGetTagCount(), NurApiGetTagData()
     * <br>
     * <br>
     * @param    hApi    Handle to valid NurApi object instance.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiClearTags(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2039</i>
     */
    public static int NurApiClearTags(Pointer<?> hApi) {
        return NurApiClearTags(Pointer.getPeer(hApi));
    }

    protected native static int NurApiClearTags(@Ptr long hApi);

    /**
     * @fn int NurApiEnableXPCRemoval(HANDLE hApi, BOOL enable)
     * <br>
     * <br>
     * Enables or disables the XPC information removal when the tags are retrieved from the storage.
     * <br>
     * When the removal is enabled, the XPC indicator bit will also be set to '0' in the PC word.
     * <br>
     *
     * <br>
     * @sa NurApiGetTagMeta(), NurApiGetTagData(), NurApiGetTagDataEx()
     * <br>
     * <br>
     * @param    hApi     Handle to valid NurApi object instance.
     * <br>
     * @param    enable Set to TRUE if the XPC removal is to be enabled.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiEnableXPCRemoval(HANDLE, BOOL)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2054</i>
     */
    public static int NurApiEnableXPCRemoval(Pointer<?> hApi, int enable) {
        return NurApiEnableXPCRemoval(Pointer.getPeer(hApi), enable);
    }

    protected native static int NurApiEnableXPCRemoval(@Ptr long hApi, int enable);

    /**
     * @fn int NurApiXPCRemovalEnabled(HANDLE hApi, BOOL *enable)
     * <br>
     *
     * <br>
     * Returns whether the XPC removal is currently enabled or not.
     * <br>
     *
     * <br>
     * @sa NurApiGetTagMeta(), NurApiGetTagData(), NurApiGetTagDataEx()
     * <br>
     * <br>
     * @param    hApi    Handle to valid NurApi object instance.
     * <br>
     * @param    enable    Pointer to where the state is to be stored.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiXPCRemovalEnabled(HANDLE, BOOL*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2068</i>
     */
    public static int NurApiXPCRemovalEnabled(Pointer<?> hApi, Pointer<Integer> enable) {
        return NurApiXPCRemovalEnabled(Pointer.getPeer(hApi), Pointer.getPeer(enable));
    }

    protected native static int NurApiXPCRemovalEnabled(@Ptr long hApi, @Ptr long enable);

    /**
     * @fn int NurApiGetTagCount(HANDLE hApi, int *count)
     * <br>
     * Get count of inventoried tags in memory.
     * <br>
     * You have to call NurApiFetchTags() in order to get fresh tag list from module.
     * <br>
     *
     * <br>
     * @sa NurApiFetchTags(), NurApiClearTags(), NurApiGetTagMeta(), NurApiGetTagData(), NurApiGetTagDataEx()
     * <br>
     * <br>
     * @param    hApi    Handle to valid NurApi object instance.
     * <br>
     * @param    count    Number of tags fetched from module memory is received in this pointer.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetTagCount(HANDLE, int*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2082</i>
     */
    public static int NurApiGetTagCount(Pointer<?> hApi, Pointer<Integer> count) {
        return NurApiGetTagCount(Pointer.getPeer(hApi), Pointer.getPeer(count));
    }

    protected native static int NurApiGetTagCount(@Ptr long hApi, @Ptr long count);

    /**
     * @fn int NurApiGetTagData(HANDLE hApi, int idx, struct NUR_TAG_DATA *tagData)
     * <br>
     * <br>
     * Get inventoried tag data by index.
     * <br>
     *
     * <br>
     * @sa NurApiGetTagCount(), NurApiClearTags(), NUR_TAG_DATA, NurApiGetAllTagData()
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    idx            Tag index in internal tag buffer.
     * <br>
     * @param    tagData        Valid pointer NUR_TAG_DATA structure.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetTagData(HANDLE, int, NUR_TAG_DATA*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2097</i>
     */
    public static int NurApiGetTagData(Pointer<?> hApi, int idx, Pointer<NUR_TAG_DATA> tagData) {
        return NurApiGetTagData(Pointer.getPeer(hApi), idx, Pointer.getPeer(tagData));
    }

    protected native static int NurApiGetTagData(@Ptr long hApi, int idx, @Ptr long tagData);

    /**
     * @fn int NurApiGetTagDataEx(HANDLE hApi, int idx, struct NUR_TAG_DATA_EX *tagDataEx, DWORD szEntry)
     * <br>
     * <br>
     * Get inventoried tag data by index. Includes possible read data.
     * <br>
     *
     * <br>
     * @sa NurApiGetTagCount(), NurApiClearTags(), NUR_TAG_DATA_EX, NurApiGetAllTagDataEx()
     * <br>
     *
     * <br>
     * @param    hApi         Handle to valid NurApi object instance.
     * <br>
     * @param    idx             Tag index in internal tag buffer.
     * <br>
     * @param    tagDataEx        Valid pointer NUR_TAG_DATA_EX structure.
     * <br>
     * @param    szEntry Size of the entry. May change upon new version(s).
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetTagDataEx(HANDLE, int, NUR_TAG_DATA_EX*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2113</i>
     */
    public static int NurApiGetTagDataEx(Pointer<?> hApi, int idx, Pointer<NUR_TAG_DATA_EX> tagDataEx, int szEntry) {
        return NurApiGetTagDataEx(Pointer.getPeer(hApi), idx, Pointer.getPeer(tagDataEx), szEntry);
    }

    protected native static int NurApiGetTagDataEx(@Ptr long hApi, int idx, @Ptr long tagDataEx, int szEntry);

    /**
     * @fn int NurApiGetAllTagData(HANDLE hApi, struct NUR_TAG_DATA *tagDataBuffer, int *tagDataCount)
     * <br>
     * <br>
     * Get all inventoried tags once.
     * <br>
     *
     * <br>
     * @sa NurApiGetTagCount(), NurApiClearTags(), NUR_TAG_DATA, NurApiGetTagData()
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    tagDataBuffer    Pointer to a NUR_TAG_DATA structures. Must contain at least <i>tagDataCount</i> entries of NUR_TAG_DATA.
     * <br>
     * @param    tagDataCount    Number of entries in <i>tagDataBuffer</i>. On return number of valid entries is received in this pointer.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetAllTagData(HANDLE, NUR_TAG_DATA*, int*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2128</i>
     */
    public static int NurApiGetAllTagData(Pointer<?> hApi, Pointer<NUR_TAG_DATA> tagDataBuffer, Pointer<Integer> tagDataCount) {
        return NurApiGetAllTagData(Pointer.getPeer(hApi), Pointer.getPeer(tagDataBuffer), Pointer.getPeer(tagDataCount));
    }

    protected native static int NurApiGetAllTagData(@Ptr long hApi, @Ptr long tagDataBuffer, @Ptr long tagDataCount);

    /**
     * @fn int NurApiGetAllTagDataEx(HANDLE hApi, struct NUR_TAG_DATA_EX *tagDataBuffer, int *tagDataCount, DWORD szSingleEntry)
     * <br>
     * <br>
     * Get all inventoried tags once. Include possible intentory+read data per tag basis.
     * <br>
     *
     * <br>
     * @sa NurApiGetTagCount(), NurApiClearTags(), NUR_TAG_DATA_EX, NurApiGetTagDataEx()
     * <br>
     *
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    tagDataBuffer        Pointer to a NUR_TAG_DATA_EX structures. Must contain at least <i>tagDataCount</i> entries of NUR_TAG_DATA.
     * <br>
     * @param    tagDataCount        Number of entries in <i>tagDataBuffer</i>. On return number of valid entries is received in this pointer.
     * <br>
     * @param    szSingleEntry        Size fo one NUR_TAG_DATA_EX entry.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetAllTagDataEx(HANDLE, NUR_TAG_DATA_EX*, int*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2144</i>
     */
    public static int NurApiGetAllTagDataEx(Pointer<?> hApi, Pointer<NUR_TAG_DATA_EX> tagDataBuffer, Pointer<Integer> tagDataCount, int szSingleEntry) {
        return NurApiGetAllTagDataEx(Pointer.getPeer(hApi), Pointer.getPeer(tagDataBuffer), Pointer.getPeer(tagDataCount), szSingleEntry);
    }

    protected native static int NurApiGetAllTagDataEx(@Ptr long hApi, @Ptr long tagDataBuffer, @Ptr long tagDataCount, int szSingleEntry);

    /**
     * @fn int NurApiLockTagStorage(HANDLE hApi, BOOL lock)
     * <br>
     * <br>
     * Lock the tag storage in order to prevent simultaneous multiple thread access.
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    lock     TRUE to lock, FALSE to unlock.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiLockTagStorage(HANDLE, BOOL)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2156</i>
     */
    public static int NurApiLockTagStorage(Pointer<?> hApi, int lock) {
        return NurApiLockTagStorage(Pointer.getPeer(hApi), lock);
    }

    protected native static int NurApiLockTagStorage(@Ptr long hApi, int lock);

    /**
     * @fn int NurApiStopContinuous(HANDLE hApi)
     * <br>
     * <br>
     * Force stop all NUR module running continuous functions.
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     *
     * <br>
     * @return 0 if succeeded, non-zero error code on failure.<br>
     * Original signature : <code>int NurApiStopContinuous(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2167</i>
     */
    public static int NurApiStopContinuous(Pointer<?> hApi) {
        return NurApiStopContinuous(Pointer.getPeer(hApi));
    }

    protected native static int NurApiStopContinuous(@Ptr long hApi);

    /**
     * @fn int NurApiTraceTag32(HANDLE hApi,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask,
     * <br>
     * BYTE flags, struct NUR_TRACETAG_DATA *resp)
     * <br>
     * <br>
     * Trace singulated single tag.
     * <br>
     *
     * <br>
     * @sa NurApiTraceTagByEPC(), NUR_TRACETAG
     * <br>
     *
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     * @param    flags                Flags for trace. see enum NUR_TRACETAG
     * <br>
     * @param    resp                Pointer to a structure that receives trace response.
     * <br>
     * If continuous tracing is specified in <i>flags</i> response is not received,
     * <br>
     * instead module will send NUR_NOTIFICATION_TRACETAG notification for tracing.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiTraceTag32(HANDLE, BYTE, DWORD, int, BYTE*, BYTE, NUR_TRACETAG_DATA*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2191</i>
     */
    public static int NurApiTraceTag32(Pointer<?> hApi, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, byte flags, Pointer<NUR_TRACETAG_DATA> resp) {
        return NurApiTraceTag32(Pointer.getPeer(hApi), sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), flags, Pointer.getPeer(resp));
    }

    protected native static int NurApiTraceTag32(@Ptr long hApi, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, byte flags, @Ptr long resp);

    /**
     * @fn int NurApiTraceTagByEPC(HANDLE hApi, BYTE *epcBuffer, DWORD epcBufferLen, BYTE flags, struct NUR_TRACETAG_DATA *resp)
     * <br>
     * <br>
     * Trace single tag singluated against tag's EPC memory.
     * <br>
     *
     * <br>
     * @sa NurApiTraceTag32(), NUR_TRACETAG
     * <br>
     *
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    epcBuffer            EPC memory to singulate against.
     * <br>
     * @param    epcBufferLen        Size of epcBuffer in bytes.
     * <br>
     * @param    flags                Flags for trace. see enum NUR_TRACETAG
     * <br>
     * @param    resp                Pointer to a structure that receives trace response.
     * <br>
     * If continuous tracing is specified in <i>flags</i> response is not received,
     * <br>
     * instead module will send NUR_NOTIFICATION_TRACETAG notification for tracing.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiTraceTagByEPC(HANDLE, BYTE*, DWORD, BYTE, NUR_TRACETAG_DATA*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2210</i>
     */
    public static int NurApiTraceTagByEPC(Pointer<?> hApi, Pointer<Byte> epcBuffer, int epcBufferLen, byte flags, Pointer<NUR_TRACETAG_DATA> resp) {
        return NurApiTraceTagByEPC(Pointer.getPeer(hApi), Pointer.getPeer(epcBuffer), epcBufferLen, flags, Pointer.getPeer(resp));
    }

    protected native static int NurApiTraceTagByEPC(@Ptr long hApi, @Ptr long epcBuffer, int epcBufferLen, byte flags, @Ptr long resp);

    /**
     * @fn BOOL NurApiIsTraceRunning(HANDLE hApi)
     * <br>
     * <br>
     * Return TRUE if tag trace routine is running on module.
     * <br>
     * <br>
     * @param    hApi    Handle to valid NurApi object instance
     * <br>
     * <br>
     * @return TRUE if tag trace routine is running. FALSE otherwise.<br>
     * Original signature : <code>BOOL NurApiIsTraceRunning(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2221</i>
     */
    public static int NurApiIsTraceRunning(Pointer<?> hApi) {
        return NurApiIsTraceRunning(Pointer.getPeer(hApi));
    }

    protected native static int NurApiIsTraceRunning(@Ptr long hApi);

    /**
     * @fn int NurApiReadSingulatedTag32(HANDLE hApi, DWORD passwd, BOOL secured,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask,
     * <br>
     * BYTE rdBank, DWORD rdAddress, int rdByteCount, BYTE *rdBuffer)
     * <br>
     * Read data from tag with specific singulation.
     * <br>
     * Tag can be singluted against desired memory bank and mask.
     * <br>
     * <br>
     * @sa NurApiReadTagByEPC(), NurApiReadTag32()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     * @param    rdBank                Memory bank for read operation.
     * <br>
     * @param    rdAddress            <b>Word</b> address for read operation.
     * <br>
     * @param    rdByteCount            Number of bytes to read. This must <b>divisible by two</b>.
     * <br>
     * @param    rdBuffer            Pointer to a buffer that received read data. Must be atleast <i>rdByteCount</i> bytes long.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiReadSingulatedTag32(HANDLE, DWORD, BOOL, BYTE, DWORD, int, BYTE*, BYTE, DWORD, int, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2247</i>
     */
    public static int NurApiReadSingulatedTag32(Pointer<?> hApi, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, byte rdBank, int rdAddress, int rdByteCount, Pointer<Byte> rdBuffer) {
        return NurApiReadSingulatedTag32(Pointer.getPeer(hApi), passwd, secured, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), rdBank, rdAddress, rdByteCount, Pointer.getPeer(rdBuffer));
    }

    protected native static int NurApiReadSingulatedTag32(@Ptr long hApi, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, byte rdBank, int rdAddress, int rdByteCount, @Ptr long rdBuffer);

    /**
     * @fn int NurApiCustomReadSingulatedTag32(HANDLE hApi,
     * <br>
     * DWORD rdCmd, BYTE cmdBits, DWORD rdBank, BYTE bankBits,
     * <br>
     * DWORD passwd, BOOL secured,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask,
     * <br>
     * DWORD rdAddress, int rdByteCount, BYTE *rdBuffer);
     * <br>
     * Read data from tag with specific singulation and with custom read command.
     * <br>
     * The command can be practically anything; the module's action is "act like this was a read operation".
     * <br>
     * Tag can be singluted against desired memory bank and mask.
     * <br>
     * <br>
     * @sa NurApiCustomReadTagByEPC(), NurApiCustomReadTag32()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    rdCmd                Custom read command.
     * <br>
     * @param    cmdBits            Number of bits in the 'custom' read command. Must be 1...32.
     * <br>
     * @param    rdBank            Customizable bank parameter for 'custom' read.
     * <br>
     * @param    bankBits        Number of bits in the bank parameter. Can be 0.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     * @param    rdAddress            <b>Word</b> address for read operation.
     * <br>
     * @param    rdByteCount            Number of bytes to read. This must <b>divisible by two</b>.
     * <br>
     * @param    rdBuffer            Pointer to a buffer that received read data. Must be at least <i>rdByteCount</i> bytes long.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiCustomReadSingulatedTag32(HANDLE, DWORD, BYTE, DWORD, BYTE, DWORD, BOOL, BYTE, DWORD, int, BYTE*, DWORD, int, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2279</i>
     */
    public static int NurApiCustomReadSingulatedTag32(Pointer<?> hApi, int rdCmd, byte cmdBits, int rdBank, byte bankBits, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, int rdAddress, int rdByteCount, Pointer<Byte> rdBuffer) {
        return NurApiCustomReadSingulatedTag32(Pointer.getPeer(hApi), rdCmd, cmdBits, rdBank, bankBits, passwd, secured, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), rdAddress, rdByteCount, Pointer.getPeer(rdBuffer));
    }

    protected native static int NurApiCustomReadSingulatedTag32(@Ptr long hApi, int rdCmd, byte cmdBits, int rdBank, byte bankBits, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, int rdAddress, int rdByteCount, @Ptr long rdBuffer);

    /**
     * @fn int NurApiReadTagByEPC(HANDLE hApi, DWORD passwd, BOOL secured,
     * <br>
     * BYTE *epcBuffer, DWORD epcBufferLen,
     * <br>
     * BYTE rdBank, DWORD rdAddress, int rdByteCount, BYTE *rdBuffer)
     * <br>
     * Read data from tag singulated by tag's EPC memory.
     * <br>
     *
     * <br>
     * @sa NurApiReadSingulatedTag32(), NurApiReadTag32()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    epcBuffer            EPC memory to singulate against.
     * <br>
     * @param    epcBufferLen        Size of epcBuffer in bytes.
     * <br>
     * @param    rdBank                Memory bank for read operation.
     * <br>
     * @param    rdAddress            <b>Word</b> address for read operation.
     * <br>
     * @param    rdByteCount            Number of bytes to read. This must <b>divisible by two</b>.
     * <br>
     * @param    rdBuffer            Pointer to a buffer that received read data. Must be atleast <i>rdByteCount</i> bytes long.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiReadTagByEPC(HANDLE, DWORD, BOOL, BYTE*, DWORD, BYTE, DWORD, int, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2302</i>
     */
    public static int NurApiReadTagByEPC(Pointer<?> hApi, int passwd, int secured, Pointer<Byte> epcBuffer, int epcBufferLen, byte rdBank, int rdAddress, int rdByteCount, Pointer<Byte> rdBuffer) {
        return NurApiReadTagByEPC(Pointer.getPeer(hApi), passwd, secured, Pointer.getPeer(epcBuffer), epcBufferLen, rdBank, rdAddress, rdByteCount, Pointer.getPeer(rdBuffer));
    }

    protected native static int NurApiReadTagByEPC(@Ptr long hApi, int passwd, int secured, @Ptr long epcBuffer, int epcBufferLen, byte rdBank, int rdAddress, int rdByteCount, @Ptr long rdBuffer);

    /**
     * @fn int NurApiCustomReadTagByEPC(HANDLE hApi,
     * <br>
     * DWORD rdCmd, BYTE cmdBits, DWORD rdBank, BYTE bankBits,
     * <br>
     * DWORD passwd, BOOL secured,
     * <br>
     * BYTE *epcBuffer, DWORD epcBufferLen,
     * <br>
     * DWORD rdAddress, int rdByteCount, BYTE *rdBuffer)
     * <br>
     * Read data from tag singulated by tag's EPC memory.
     * <br>
     *
     * <br>
     * @sa NurApiCustomReadSingulatedTag32(), NurApiReadTag32()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    rdCmd                Custom read command.
     * <br>
     * @param    cmdBits            Number of bits in the 'custom' read command. Must be 1...32.
     * <br>
     * @param    rdBank            Customizable bank parameter for 'custom' read.
     * <br>
     * @param    bankBits        Number of bits in the bank parameter. Can be 0.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    epcBuffer            EPC memory to singulate against.
     * <br>
     * @param    epcBufferLen        Size of epcBuffer in bytes.
     * <br>
     * @param    rdBank                Memory bank for read operation.
     * <br>
     * @param    rdAddress            <b>Word</b> address for read operation.
     * <br>
     * @param    rdByteCount            Number of bytes to read. This must <b>divisible by two</b>.
     * <br>
     * @param    rdBuffer            Pointer to a buffer that received read data. Must be atleast <i>rdByteCount</i> bytes long.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiCustomReadTagByEPC(HANDLE, DWORD, BYTE, DWORD, BYTE, DWORD, BOOL, BYTE*, DWORD, DWORD, int, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2331</i>
     */
    public static int NurApiCustomReadTagByEPC(Pointer<?> hApi, int rdCmd, byte cmdBits, int rdBank, byte bankBits, int passwd, int secured, Pointer<Byte> epcBuffer, int epcBufferLen, int rdAddress, int rdByteCount, Pointer<Byte> rdBuffer) {
        return NurApiCustomReadTagByEPC(Pointer.getPeer(hApi), rdCmd, cmdBits, rdBank, bankBits, passwd, secured, Pointer.getPeer(epcBuffer), epcBufferLen, rdAddress, rdByteCount, Pointer.getPeer(rdBuffer));
    }

    protected native static int NurApiCustomReadTagByEPC(@Ptr long hApi, int rdCmd, byte cmdBits, int rdBank, byte bankBits, int passwd, int secured, @Ptr long epcBuffer, int epcBufferLen, int rdAddress, int rdByteCount, @Ptr long rdBuffer);

    /**
     * @fn int NurApiReadTag32(HANDLE hApi, DWORD passwd, BOOL secured, BYTE rdBank, DWORD rdAddress, int rdByteCount, BYTE *rdBuffer)
     * <br>
     * Read data from tag without any singulation data.
     * <br>
     * This function can be used for tags that does not have EPC.
     * <br>
     *
     * <br>
     * @note If there's more than one tag in range, this function will most likely fail due to the RF collision.
     * <br>
     *
     * <br>
     * @sa NurApiReadSingulatedTag32(), NurApiReadTagByEPC()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    rdBank                Memory bank for read operation.
     * <br>
     * @param    rdAddress            <b>Word</b> address for read operation.
     * <br>
     * @param    rdByteCount            Number of bytes to read. This must <b>divisible by two</b>.
     * <br>
     * @param    rdBuffer            Pointer to a buffer that received read data. Must be atleast <i>rdByteCount</i> bytes long.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiReadTag32(HANDLE, DWORD, BOOL, BYTE, DWORD, int, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2353</i>
     */
    public static int NurApiReadTag32(Pointer<?> hApi, int passwd, int secured, byte rdBank, int rdAddress, int rdByteCount, Pointer<Byte> rdBuffer) {
        return NurApiReadTag32(Pointer.getPeer(hApi), passwd, secured, rdBank, rdAddress, rdByteCount, Pointer.getPeer(rdBuffer));
    }

    protected native static int NurApiReadTag32(@Ptr long hApi, int passwd, int secured, byte rdBank, int rdAddress, int rdByteCount, @Ptr long rdBuffer);

    /**
     * @fn int NurApiCustomReadTag32(HANDLE hApi, DWORD rdCmd, BYTE cmdBits, DWORD rdBank, BYTE bankBits, DWORD passwd, BOOL secured, DWORD rdAddress, int rdByteCount, BYTE *rdBuffer)
     * <br>
     * Read data from tag without any singulation data with custom read command and customizable bank parameter.
     * <br>
     * This function can be used for tags that does not have EPC.
     * <br>
     *
     * <br>
     * @note If there's more than one tag in range, this function will most likely fail due to the RF collision.
     * <br>
     *
     * <br>
     * @sa NurApiCustomReadSingulatedTag32(), NurApiCustomReadTagByEPC()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    rdCmd                Custom read command.
     * <br>
     * @param    cmdBits            Number of bits in the 'custom' read command. Must be 1...32.
     * <br>
     * @param    rdBank            Customizable bank parameter for 'custom' read.
     * <br>
     * @param    bankBits        Number of bits in the bank parameter. Can be 0.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    rdBank                Memory bank for read operation.
     * <br>
     * @param    rdAddress            <b>Word</b> address for read operation.
     * <br>
     * @param    rdByteCount            Number of bytes to read. This must <b>divisible by two</b>.
     * <br>
     * @param    rdBuffer            Pointer to a buffer that received read data. Must be atleast <i>rdByteCount</i> bytes long.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiCustomReadTag32(HANDLE, DWORD, BYTE, DWORD, BYTE, DWORD, BOOL, DWORD, int, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2379</i>
     */
    public static int NurApiCustomReadTag32(Pointer<?> hApi, int rdCmd, byte cmdBits, int rdBank, byte bankBits, int passwd, int secured, int rdAddress, int rdByteCount, Pointer<Byte> rdBuffer) {
        return NurApiCustomReadTag32(Pointer.getPeer(hApi), rdCmd, cmdBits, rdBank, bankBits, passwd, secured, rdAddress, rdByteCount, Pointer.getPeer(rdBuffer));
    }

    protected native static int NurApiCustomReadTag32(@Ptr long hApi, int rdCmd, byte cmdBits, int rdBank, byte bankBits, int passwd, int secured, int rdAddress, int rdByteCount, @Ptr long rdBuffer);

    /**
     * @fn int NurApiSetUseBlockWrite(HANDLE hApi, BOOL val)
     * <br>
     * <br>
     * Set current block write usage flag.
     * <br>
     * When set to TRUE, all NurApi tag write functions will use UHF C1G2 BlockWrite command (uhf c1g2 spec available at epcglobal) to write data to tag.
     * <br>
     * UHF C1G2 standard section "6.3.2.11.3.7 BlockWrite (optional)".
     * <br>
     *
     * <br>
     * @sa NurApiGetUseBlockWrite()
     * <br>
     *
     * <br>
     * @param    hApi    Handle to valid NurApi object instance.
     * <br>
     * @param    val        If TRUE BlockWrite method is used.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark Not all tags supports BlockWrite. If unsure, DO NOT USE.<br>
     * Original signature : <code>int NurApiSetUseBlockWrite(HANDLE, BOOL)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2396</i>
     */
    public static int NurApiSetUseBlockWrite(Pointer<?> hApi, int val) {
        return NurApiSetUseBlockWrite(Pointer.getPeer(hApi), val);
    }

    protected native static int NurApiSetUseBlockWrite(@Ptr long hApi, int val);

    /**
     * @fn int NurApiDisableCustomReselect(HANDLE hApi)
     * <br>
     * <br>
     * Call to this will disable the tag re-selection during next custom exchange.
     * <br>
     * Any following command will reset this flag so it is valid only for one round.
     * <br>
     *
     * <br>
     * @sa NurApiCustomExchangeByEPC(), NurApiCustomExchange32(), NurApiCustomExchangeSingulated32(), NurApiSetExtCarrier()
     * <br>
     *
     * <br>
     * @param    hApi    Handle to valid NurApi object instance.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiDisableCustomReselect(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2410</i>
     */
    public static int NurApiDisableCustomReselect(Pointer<?> hApi) {
        return NurApiDisableCustomReselect(Pointer.getPeer(hApi));
    }

    protected native static int NurApiDisableCustomReselect(@Ptr long hApi);

    /**
     * @fn int NurApiGetUseBlockWrite(HANDLE hApi, BOOL *val)
     * <br>
     * <br>
     * Get current block write usage flag.
     * <br>
     * When set to TRUE, all NurApi tag write functions will use UHF C1G2 BlockWrite command (uhf c1g2 spec available at epcglobal) to write data to tag.
     * <br>
     * UHF C1G2 standard section "6.3.2.11.3.7 BlockWrite (optional)".
     * <br>
     *
     * <br>
     * @sa NurApiSetUseBlockWrite()
     * <br>
     *
     * <br>
     * @param    hApi    Handle to valid NurApi object instance.
     * <br>
     * @param    val        Pointer to a BOOL that receives current setting.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark Not all tags supports BlockWrite. If unsure, DO NOT USE.<br>
     * Original signature : <code>int NurApiGetUseBlockWrite(HANDLE, BOOL*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2427</i>
     */
    public static int NurApiGetUseBlockWrite(Pointer<?> hApi, Pointer<Integer> val) {
        return NurApiGetUseBlockWrite(Pointer.getPeer(hApi), Pointer.getPeer(val));
    }

    protected native static int NurApiGetUseBlockWrite(@Ptr long hApi, @Ptr long val);

    /**
     * @fn int NurApiWriteSingulatedTag32(HANDLE hApi, DWORD passwd, BOOL secured,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask,
     * <br>
     * BYTE wrBank, DWORD wrAddress, int wrByteCount, BYTE *wrBuffer)
     * <br>
     * Write data to tag with specific singulation.
     * <br>
     * Tag can be singluted against desired memory bank and mask.
     * <br>
     *
     * <br>
     * @sa NurApiWriteTagByEPC(), NurApiWriteTag32()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     * @param    wrBank                Memory bank for write operation.
     * <br>
     * @param    wrAddress            <b>Word</b> address for write operation.
     * <br>
     * @param    wrByteCount            Number of bytes to write. This must <b>divisible by two</b>.
     * <br>
     * @param    wrBuffer            Data to write. Must be atleast <i>wrByteCount</i> bytes long.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiWriteSingulatedTag32(HANDLE, DWORD, BOOL, BYTE, DWORD, int, BYTE*, BYTE, DWORD, int, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2453</i>
     */
    public static int NurApiWriteSingulatedTag32(Pointer<?> hApi, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, byte wrBank, int wrAddress, int wrByteCount, Pointer<Byte> wrBuffer) {
        return NurApiWriteSingulatedTag32(Pointer.getPeer(hApi), passwd, secured, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), wrBank, wrAddress, wrByteCount, Pointer.getPeer(wrBuffer));
    }

    protected native static int NurApiWriteSingulatedTag32(@Ptr long hApi, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, byte wrBank, int wrAddress, int wrByteCount, @Ptr long wrBuffer);

    /**
     * @fn int NurApiWriteTagByEPC(HANDLE hApi, DWORD passwd, BOOL secured,
     * <br>
     * BYTE *epcBuffer, DWORD epcBufferLen,
     * <br>
     * BYTE wrBank, DWORD wrAddress, int wrByteCount, BYTE *wrBuffer)
     * <br>
     * Write data to tag singulated by tag's EPC memory.
     * <br>
     * <br>
     * @sa NurApiWriteSingulatedTag32(), NurApiWriteTag32()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    epcBuffer            EPC memory to singulate against.
     * <br>
     * @param    epcBufferLen        Size of epcBuffer in bytes.
     * <br>
     * @param    wrBank                Memory bank for write operation.
     * <br>
     * @param    wrAddress            <b>Word</b> address for write operation.
     * <br>
     * @param    wrByteCount            Number of bytes to write. This must <b>divisible by two</b>.
     * <br>
     * @param    wrBuffer            Data to write. Must be atleast <i>wrByteCount</i> bytes long.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiWriteTagByEPC(HANDLE, DWORD, BOOL, BYTE*, DWORD, BYTE, DWORD, int, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2476</i>
     */
    public static int NurApiWriteTagByEPC(Pointer<?> hApi, int passwd, int secured, Pointer<Byte> epcBuffer, int epcBufferLen, byte wrBank, int wrAddress, int wrByteCount, Pointer<Byte> wrBuffer) {
        return NurApiWriteTagByEPC(Pointer.getPeer(hApi), passwd, secured, Pointer.getPeer(epcBuffer), epcBufferLen, wrBank, wrAddress, wrByteCount, Pointer.getPeer(wrBuffer));
    }

    protected native static int NurApiWriteTagByEPC(@Ptr long hApi, int passwd, int secured, @Ptr long epcBuffer, int epcBufferLen, byte wrBank, int wrAddress, int wrByteCount, @Ptr long wrBuffer);

    /**
     * @fn int NurApiWriteTag32(HANDLE hApi, DWORD passwd, BOOL secured,
     * <br>
     * BYTE wrBank, DWORD wrAddress, int wrByteCount, BYTE *wrBuffer)
     * <br>
     * Write data to tag without any singulation data.
     * <br>
     * This function can be used for tags that does not have EPC.
     * <br>
     *
     * <br>
     * @note If there's more than one tag in range, this function will most likely fail due to the RF collision.
     * <br>
     *
     * <br>
     * @sa NurApiWriteSingulatedTag32(), NurApiWriteTagByEPC()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    wrBank                Memory bank for write operation.
     * <br>
     * @param    wrAddress            <b>Word</b> address for write operation.
     * <br>
     * @param    wrByteCount            Number of bytes to write. This must <b>divisible by two</b>.
     * <br>
     * @param    wrBuffer            Data to write. Must be atleast <i>wrByteCount</i> bytes long.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiWriteTag32(HANDLE, DWORD, BOOL, BYTE, DWORD, int, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2499</i>
     */
    public static int NurApiWriteTag32(Pointer<?> hApi, int passwd, int secured, byte wrBank, int wrAddress, int wrByteCount, Pointer<Byte> wrBuffer) {
        return NurApiWriteTag32(Pointer.getPeer(hApi), passwd, secured, wrBank, wrAddress, wrByteCount, Pointer.getPeer(wrBuffer));
    }

    protected native static int NurApiWriteTag32(@Ptr long hApi, int passwd, int secured, byte wrBank, int wrAddress, int wrByteCount, @Ptr long wrBuffer);

    /**
     * @fn int NurApiBlockWriteSingulatedTag32(HANDLE hApi, DWORD passwd, BOOL secured,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask,
     * <br>
     * BYTE wrBank, DWORD wrAddress, int wrByteCount, BYTE *wrBuffer, BYTE blSize);
     * <br>
     * Write data to tag with specific singulation. Uses spcific block write.
     * <br>
     * Tag can be singluted against desired memory bank and mask.
     * <br>
     *
     * <br>
     * @sa NurApiBlockWriteByEPC(), NurApiBlockWriteTag32()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     * @param    wrBank                Memory bank for write operation.
     * <br>
     * @param    wrAddress            <b>Word</b> address for write operation.
     * <br>
     * @param    wrByteCount            Number of bytes to write. This must <b>divisible by two and by blSize (if not 0)</b>.
     * <br>
     * @param    wrBuffer            Data to write. Must be atleast <i>wrByteCount</i> bytes long.
     * <br>
     * @param    blSize                Size of a single block. If the data is considered to be single block.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiBlockWriteSingulatedTag32(HANDLE, DWORD, BOOL, BYTE, DWORD, int, BYTE*, BYTE, DWORD, int, BYTE*, BYTE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2526</i>
     */
    public static int NurApiBlockWriteSingulatedTag32(Pointer<?> hApi, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, byte wrBank, int wrAddress, int wrByteCount, Pointer<Byte> wrBuffer, byte blSize) {
        return NurApiBlockWriteSingulatedTag32(Pointer.getPeer(hApi), passwd, secured, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), wrBank, wrAddress, wrByteCount, Pointer.getPeer(wrBuffer), blSize);
    }

    protected native static int NurApiBlockWriteSingulatedTag32(@Ptr long hApi, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, byte wrBank, int wrAddress, int wrByteCount, @Ptr long wrBuffer, byte blSize);

    /**
     * @fn int NurApiBlockWriteByEPC(HANDLE hApi, DWORD passwd, BOOL secured, BYTE *epcBuffer, DWORD epcBufferLen,
     * <br>
     * BYTE wrBank, DWORD wrAddress, int wrByteCount, BYTE *wrBuffer, BYTE blSize)
     * <br>
     * Write data to tag singulated by tag's EPC memory. Uses spcific block write.
     * <br>
     *
     * <br>
     * @sa NurApiBlockWriteSingulatedTag32(), NurApiBlockWriteTag32()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    epcBuffer            EPC memory to singulate against.
     * <br>
     * @param    epcBufferLen        Size of epcBuffer in bytes.
     * <br>
     * @param    wrBank                Memory bank for write operation.
     * <br>
     * @param    wrAddress            <b>Word</b> address for write operation.
     * <br>
     * @param    wrByteCount            Number of bytes to write. This must <b>divisible by two and by blSize (if not 0)</b>.
     * <br>
     * @param    wrBuffer            Data to write. Must be atleast <i>wrByteCount</i> bytes long.
     * <br>
     * @param    blSize                Size of a single block. If the data is considered to be single block.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiBlockWriteByEPC(HANDLE, DWORD, BOOL, BYTE*, DWORD, BYTE, DWORD, int, BYTE*, BYTE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2549</i>
     */
    public static int NurApiBlockWriteByEPC(Pointer<?> hApi, int passwd, int secured, Pointer<Byte> epcBuffer, int epcBufferLen, byte wrBank, int wrAddress, int wrByteCount, Pointer<Byte> wrBuffer, byte blSize) {
        return NurApiBlockWriteByEPC(Pointer.getPeer(hApi), passwd, secured, Pointer.getPeer(epcBuffer), epcBufferLen, wrBank, wrAddress, wrByteCount, Pointer.getPeer(wrBuffer), blSize);
    }

    protected native static int NurApiBlockWriteByEPC(@Ptr long hApi, int passwd, int secured, @Ptr long epcBuffer, int epcBufferLen, byte wrBank, int wrAddress, int wrByteCount, @Ptr long wrBuffer, byte blSize);

    /**
     * @fn int NurApiBlockWriteTag32(HANDLE hApi, DWORD passwd, BOOL secured,
     * <br>
     * BYTE wrBank, DWORD wrAddress, int wrByteCount, BYTE *wrBuffer, BYTE blSize)
     * <br>
     * Write data to tag without any singulation data. Uses spcific block write.
     * <br>
     *
     * <br>
     * @note If there's more than one tag in range, this function will most likely fail due to the RF collision.
     * <br>
     * <br>
     * @sa NurApiBlockWriteByEPC(), NurApiBlockWriteSingulatedTag32()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    wrBank                Memory bank for write operation.
     * <br>
     * @param    wrAddress            <b>Word</b> address for write operation.
     * <br>
     * @param    wrByteCount            Number of bytes to write. This must <b>divisible by two and by blSize (if not 0)</b>.
     * <br>
     * @param    wrBuffer            Data to write. Must be atleast <i>wrByteCount</i> bytes long.
     * <br>
     * @param    blSize                Size of a single block. If the data is considered to be single block.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiBlockWriteTag32(HANDLE, DWORD, BOOL, BYTE, DWORD, int, BYTE*, BYTE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2572</i>
     */
    public static int NurApiBlockWriteTag32(Pointer<?> hApi, int passwd, int secured, byte wrBank, int wrAddress, int wrByteCount, Pointer<Byte> wrBuffer, byte blSize) {
        return NurApiBlockWriteTag32(Pointer.getPeer(hApi), passwd, secured, wrBank, wrAddress, wrByteCount, Pointer.getPeer(wrBuffer), blSize);
    }

    protected native static int NurApiBlockWriteTag32(@Ptr long hApi, int passwd, int secured, byte wrBank, int wrAddress, int wrByteCount, @Ptr long wrBuffer, byte blSize);

    /**
     * @fn int NurApiEraseSingulatedTag32(HANDLE hApi, DWORD passwd, BOOL secured,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask,
     * <br>
     * BYTE erBank, DWORD erAddress, BYTE erWordCount)
     * <br>
     * Erases tag using the BlockErase command with specific singulation.
     * <br>
     * Tag can be singluted against desired memory bank and mask.
     * <br>
     *
     * <br>
     * @sa NurApiEraseTagByEPC()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     * @param    erBank                Memory bank for erase operation.
     * <br>
     * @param    erAddress            <b>Word</b> address for erase operation.
     * <br>
     * @param    erWordCount            Number of words to erase.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiEraseSingulatedTag32(HANDLE, DWORD, BOOL, BYTE, DWORD, int, BYTE*, BYTE, DWORD, BYTE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2597</i>
     */
    public static int NurApiEraseSingulatedTag32(Pointer<?> hApi, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, byte erBank, int erAddress, byte erWordCount) {
        return NurApiEraseSingulatedTag32(Pointer.getPeer(hApi), passwd, secured, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), erBank, erAddress, erWordCount);
    }

    protected native static int NurApiEraseSingulatedTag32(@Ptr long hApi, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, byte erBank, int erAddress, byte erWordCount);

    /**
     * @fn int NURAPICONV NurApiEraseTagByEPC(HANDLE hApi, DWORD passwd, BOOL secured,
     * <br>
     * BYTE *epcBuffer, DWORD epcBufferLen,
     * <br>
     * BYTE erBank, DWORD erAddress, BYTE erWordCount)
     * <br>
     * Erases tag using the BlockErase command.
     * <br>
     * <br>
     * @sa NurApiEraseSingulatedTag32()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    epcBuffer            EPC memory to singulate against.
     * <br>
     * @param    epcBufferLen        Size of epcBuffer in bytes.
     * <br>
     * @param    erBank                Memory bank for erase operation.
     * <br>
     * @param    erAddress            <b>Word</b> address for erase operation.
     * <br>
     * @param    erWordCount            Number of words to erase.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiEraseTagByEPC(HANDLE, DWORD, BOOL, BYTE*, DWORD, BYTE, DWORD, BYTE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2619</i>
     */
    public static int NurApiEraseTagByEPC(Pointer<?> hApi, int passwd, int secured, Pointer<Byte> epcBuffer, int epcBufferLen, byte erBank, int erAddress, byte erWordCount) {
        return NurApiEraseTagByEPC(Pointer.getPeer(hApi), passwd, secured, Pointer.getPeer(epcBuffer), epcBufferLen, erBank, erAddress, erWordCount);
    }

    protected native static int NurApiEraseTagByEPC(@Ptr long hApi, int passwd, int secured, @Ptr long epcBuffer, int epcBufferLen, byte erBank, int erAddress, byte erWordCount);

    /**
     * @fn int NurApiCustomWriteSingulatedTag32(HANDLE hApi,
     * <br>
     * DWORD wrCmd, BYTE cmdBits, DWORD wrBank, BYTE bankBits,
     * <br>
     * DWORD passwd, BOOL secured, BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask,
     * <br>
     * DWORD wrAddress, int wrByteCount, BYTE *wrBuffer)
     * <br>
     * Write data to tag with specific singulation using customizable command and bank parameters.
     * <br>
     * Tag can be singluted against desired memory bank and mask.
     * <br>
     *
     * <br>
     * @sa NurApiCustomWriteTagByEPC(), NurApiCustomWriteTag32()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    wrCmd                Custom write command.
     * <br>
     * @param    cmdBits            Number of bits in the 'custom' write command. Must be 1...32.
     * <br>
     * @param    wrBank            Customizable bank parameter for 'custom' write.
     * <br>
     * @param    bankBits        Number of bits in the bank parameter. Can be 0.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     * @param    wrAddress            <b>Word</b> address for write operation.
     * <br>
     * @param    wrByteCount            Number of bytes to write. This must <b>divisible by two</b>.
     * <br>
     * @param    wrBuffer            Data to write. Must be atleast <i>wrByteCount</i> bytes long.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiCustomWriteSingulatedTag32(HANDLE, DWORD, BYTE, DWORD, BYTE, DWORD, BOOL, BYTE, DWORD, int, BYTE*, DWORD, int, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2649</i>
     */
    public static int NurApiCustomWriteSingulatedTag32(Pointer<?> hApi, int wrCmd, byte cmdBits, int wrBank, byte bankBits, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, int wrAddress, int wrByteCount, Pointer<Byte> wrBuffer) {
        return NurApiCustomWriteSingulatedTag32(Pointer.getPeer(hApi), wrCmd, cmdBits, wrBank, bankBits, passwd, secured, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), wrAddress, wrByteCount, Pointer.getPeer(wrBuffer));
    }

    protected native static int NurApiCustomWriteSingulatedTag32(@Ptr long hApi, int wrCmd, byte cmdBits, int wrBank, byte bankBits, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, int wrAddress, int wrByteCount, @Ptr long wrBuffer);

    /**
     * @fn int NurApiCustomWriteTagByEPC(HANDLE hApi,
     * <br>
     * DWORD wrCmd, BYTE cmdBits, DWORD wrBank, BYTE bankBits,
     * <br>
     * DWORD passwd, BOOL secured, BYTE *epcBuffer, DWORD epcBufferLen,
     * <br>
     * DWORD wrAddress, int wrByteCount, BYTE *wrBuffer)
     * <br>
     * Write data to tag singulated by tag's EPC memory.
     * <br>
     * <br>
     * @sa NurApiCustomWriteSingulatedTag32(), NurApiCustomWriteTag32()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    wrCmd                Custom write command.
     * <br>
     * @param    cmdBits            Number of bits in the 'custom' write command. Must be 1...32.
     * <br>
     * @param    wrBank            Customizable bank parameter for 'custom' write.
     * <br>
     * @param    bankBits        Number of bits in the bank parameter. Can be 0.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    epcBuffer            EPC memory to singulate against.
     * <br>
     * @param    epcBufferLen        Size of epcBuffer in bytes.
     * <br>
     * @param    wrAddress            <b>Word</b> address for write operation.
     * <br>
     * @param    wrByteCount            Number of bytes to write. This must <b>divisible by two</b>.
     * <br>
     * @param    wrBuffer            Data to write. Must be atleast <i>wrByteCount</i> bytes long.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiCustomWriteTagByEPC(HANDLE, DWORD, BYTE, DWORD, BYTE, DWORD, BOOL, BYTE*, DWORD, DWORD, int, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2676</i>
     */
    public static int NurApiCustomWriteTagByEPC(Pointer<?> hApi, int wrCmd, byte cmdBits, int wrBank, byte bankBits, int passwd, int secured, Pointer<Byte> epcBuffer, int epcBufferLen, int wrAddress, int wrByteCount, Pointer<Byte> wrBuffer) {
        return NurApiCustomWriteTagByEPC(Pointer.getPeer(hApi), wrCmd, cmdBits, wrBank, bankBits, passwd, secured, Pointer.getPeer(epcBuffer), epcBufferLen, wrAddress, wrByteCount, Pointer.getPeer(wrBuffer));
    }

    protected native static int NurApiCustomWriteTagByEPC(@Ptr long hApi, int wrCmd, byte cmdBits, int wrBank, byte bankBits, int passwd, int secured, @Ptr long epcBuffer, int epcBufferLen, int wrAddress, int wrByteCount, @Ptr long wrBuffer);

    /**
     * @fn int NurApiCustomWriteTag32(HANDLE hApi,
     * <br>
     * DWORD wrCmd, BYTE cmdBits, DWORD wrBank, BYTE bankBits,
     * <br>
     * DWORD passwd, BOOL secured,
     * <br>
     * DWORD wrAddress, int wrByteCount, BYTE *wrBuffer)
     * <br>
     * Write data to tag without any singulation data using customizable command and bank parameters.
     * <br>
     * This function can be used for tags that does not have EPC.
     * <br>
     *
     * <br>
     * @note If there's more than one tag in range, this function will most likely fail due to the RF collision.
     * <br>
     *
     * <br>
     * @sa NurApiCustomWriteSingulatedTag32(), NurApiCustomWriteTagByEPC()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    wrCmd                Custom write command.
     * <br>
     * @param    cmdBits            Number of bits in the 'custom' write command. Must be 1...32.
     * <br>
     * @param    wrBank            Customizable bank parameter for 'custom' write.
     * <br>
     * @param    bankBits        Number of bits in the bank parameter. Can be 0.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    wrAddress            <b>Word</b> address for write operation.
     * <br>
     * @param    wrByteCount            Number of bytes to write. This must <b>divisible by two</b>.
     * <br>
     * @param    wrBuffer            Data to write. Must be atleast <i>wrByteCount</i> bytes long.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiCustomWriteTag32(HANDLE, DWORD, BYTE, DWORD, BYTE, DWORD, BOOL, DWORD, int, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2704</i>
     */
    public static int NurApiCustomWriteTag32(Pointer<?> hApi, int wrCmd, byte cmdBits, int wrBank, byte bankBits, int passwd, int secured, int wrAddress, int wrByteCount, Pointer<Byte> wrBuffer) {
        return NurApiCustomWriteTag32(Pointer.getPeer(hApi), wrCmd, cmdBits, wrBank, bankBits, passwd, secured, wrAddress, wrByteCount, Pointer.getPeer(wrBuffer));
    }

    protected native static int NurApiCustomWriteTag32(@Ptr long hApi, int wrCmd, byte cmdBits, int wrBank, byte bankBits, int passwd, int secured, int wrAddress, int wrByteCount, @Ptr long wrBuffer);

    /**
     * @param pParams Pointer to the custom bit stream controls.
     *                <br>
     * @param resp    Pointer to the tag's response.
     *                <br>
     * @param respLen Pointer to the tag's response length.
     *                <br>
     *                <br>
     * @fn int NurApiCustomExchangeSingulated32(HANDLE hApi, DWORD passwd, BOOL secured,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask,
     * <br>
     * struct NUR_CUSTEXCHANGE_PARAMS *pParams, BYTE *resp, int *respLen);
     * <br>
     * <br>
     * Performs a custom bit stream exchange or transmit only with a singulated tag.
     * <br>
     *
     * <br>
     * @sa NurApiCustomExchangeByEPC(), NurApiCustomExchange32(), NUR_CUSTEXCHANGE_PARAMS
     * <br>
     * <br>
     * @param    hApi                 Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                 Password for secured operations.
     * <br>
     * @param    secured                 TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    sBank                 Memory bank used for tag singulation.
     * <br>
     * @param    sAddress             Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiCustomExchangeSingulated32(HANDLE, DWORD, BOOL, BYTE, DWORD, int, BYTE*, NUR_CUSTEXCHANGE_PARAMS*, BYTE*, int*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2729</i>
     */
    public static int NurApiCustomExchangeSingulated32(Pointer<?> hApi, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, Pointer<NUR_CUSTEXCHANGE_PARAMS> pParams, Pointer<Byte> resp, Pointer<Integer> respLen) {
        return NurApiCustomExchangeSingulated32(Pointer.getPeer(hApi), passwd, secured, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), Pointer.getPeer(pParams), Pointer.getPeer(resp), Pointer.getPeer(respLen));
    }

    protected native static int NurApiCustomExchangeSingulated32(@Ptr long hApi, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, @Ptr long pParams, @Ptr long resp, @Ptr long respLen);

    /**
     * @param pParams Pointer to the custom bit stream controls.
     *                <br>
     * @param resp    Pointer to the tag's response.
     *                <br>
     * @param respLen Pointer to the tag's response length.
     *                <br>
     *                <br>
     * @fn int NurApiCustomExchangeByEPC(HANDLE hApi, DWORD passwd, BOOL secured,
     * <br>
     * BYTE *epcBuffer, DWORD epcBufferLen, struct NUR_CUSTEXCHANGE_PARAMS *pParams, BYTE *resp, int *respLen);
     * <br>
     * <br>
     * Performs a custom bit stream exchange or transmit only with a tag. Tag is singulated with the given EPC data.
     * <br>
     *
     * <br>
     * @sa NurApiCustomExchangeSingulated32(), NurApiCustomExchange32(), NUR_CUSTEXCHANGE_PARAMS
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    passwd            Password for secured operations.
     * <br>
     * @param    secured            TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    epcBuffer        EPC data used for singulation.
     * <br>
     * @param    epcBufferLen    EPC length in bytes.
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiCustomExchangeByEPC(HANDLE, DWORD, BOOL, BYTE*, DWORD, NUR_CUSTEXCHANGE_PARAMS*, BYTE*, int*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2751</i>
     */
    public static int NurApiCustomExchangeByEPC(Pointer<?> hApi, int passwd, int secured, Pointer<Byte> epcBuffer, int epcBufferLen, Pointer<NUR_CUSTEXCHANGE_PARAMS> pParams, Pointer<Byte> resp, Pointer<Integer> respLen) {
        return NurApiCustomExchangeByEPC(Pointer.getPeer(hApi), passwd, secured, Pointer.getPeer(epcBuffer), epcBufferLen, Pointer.getPeer(pParams), Pointer.getPeer(resp), Pointer.getPeer(respLen));
    }

    protected native static int NurApiCustomExchangeByEPC(@Ptr long hApi, int passwd, int secured, @Ptr long epcBuffer, int epcBufferLen, @Ptr long pParams, @Ptr long resp, @Ptr long respLen);

    /**
     * @param pParams Pointer to the cuastom bit stream controls.
     *                <br>
     * @param resp    Pointer to the tag's response.
     *                <br>
     * @param respLen Pointer to the tag's response length.
     *                <br>
     *                <br>
     * @fn int NurApiCustomExchange32(HANDLE hApi, DWORD passwd, BOOL secured, struct NUR_CUSTEXCHANGE_PARAMS *pParams, BYTE *resp, int *respLen);
     * <br>
     * <br>
     * Performs a custom bit stream exchange or transmit only with a tag.
     * <br>
     * This function can be used with a tag that does not ahve an EPC or in a case where
     * <br>
     * a tag can safely be assumed to be the only on in the range.
     * <br>
     *
     * <br>
     * @sa NurApiCustomExchangeSingulated32, NurApiCustomExchangeByEPC(), NUR_CUSTEXCHANGE_PARAMS
     * <br>
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    passwd        Password for secured operations.
     * <br>
     * @param    secured        TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiCustomExchange32(HANDLE, DWORD, BOOL, NUR_CUSTEXCHANGE_PARAMS*, BYTE*, int*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2772</i>
     */
    public static int NurApiCustomExchange32(Pointer<?> hApi, int passwd, int secured, Pointer<NUR_CUSTEXCHANGE_PARAMS> pParams, Pointer<Byte> resp, Pointer<Integer> respLen) {
        return NurApiCustomExchange32(Pointer.getPeer(hApi), passwd, secured, Pointer.getPeer(pParams), Pointer.getPeer(resp), Pointer.getPeer(respLen));
    }

    protected native static int NurApiCustomExchange32(@Ptr long hApi, int passwd, int secured, @Ptr long pParams, @Ptr long resp, @Ptr long respLen);

    /**
     * @param value  Value to append.
     *               <br>
     * @param nBits  Number of bits used from the value.
     *               <br>
     * @param maxLen Maximum number of bits in the buf parameter.
     *               <br>
     *               <br>
     * @fn BOOL NurApiAddDWBitsToBuffer(BYTE *buf, int *curPt, DWORD value, int nBits, int maxLen)
     * <br>
     * <br>
     * Adds a DWORD value to a bit buffer.
     * <br>
     *
     * <br>
     * @sa NurApiAddEBV32
     * <br>
     *
     * <br>
     * @param    buf Pointer to a byte buffer allocated for bits.
     * <br>
     * @param    curPt Current pointer i.e. where to add next bits.
     * <br>
     * @return TRUE when succeeded, FALSE on error (no room, or parameter error).
     * <br>
     * @remark the curPt parameter will be updated to a new value upon a successful value addition.<br>
     * Original signature : <code>BOOL NurApiAddDWBitsToBuffer(BYTE*, int*, DWORD, int, int)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2790</i>
     */
    public static int NurApiAddDWBitsToBuffer(Pointer<Byte> buf, Pointer<Integer> curPt, int value, int nBits, int maxLen) {
        return NurApiAddDWBitsToBuffer(Pointer.getPeer(buf), Pointer.getPeer(curPt), value, nBits, maxLen);
    }

    protected native static int NurApiAddDWBitsToBuffer(@Ptr long buf, @Ptr long curPt, int value, int nBits, int maxLen);

    /**
     * @fn BOOL NurApiAddEBV32(BYTE *buf, int *curPt, DWORD ebv, int maxLen);
     * <br>
     * <br>
     * Adds a 32-bit EBV (Extensible Bit Vector) value to a bit buffer.
     * <br>
     *
     * <br>
     * @sa NurApiAddDWBitsToBuffer
     * <br>
     *
     * <br>
     * @param    buf Pointer to a byte buffer allocated for bits.
     * <br>
     * @param    curPt Current pointer i.e. where to add next bits.
     * <br>
     * @param    ebv Value to append.
     * <br>
     * @param    maxLen Maximum number of bits in the buf parameter.
     * <br>
     * <br>
     * @return TRUE when succeeded, FALSE on error (no room, or parameter error).
     * <br>
     * @remark the curPt parameter will be updated to a new value upon a successful EBV addition.<br>
     * Original signature : <code>BOOL NurApiAddEBV32(BYTE*, int*, DWORD, int)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2807</i>
     */
    public static int NurApiAddEBV32(Pointer<Byte> buf, Pointer<Integer> curPt, int ebv, int maxLen) {
        return NurApiAddEBV32(Pointer.getPeer(buf), Pointer.getPeer(curPt), ebv, maxLen);
    }

    protected native static int NurApiAddEBV32(@Ptr long buf, @Ptr long curPt, int ebv, int maxLen);

    /**
     * @fn int NurApiWriteEPC(HANDLE hApi, DWORD passwd, BOOL secured,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask,
     * <br>
     * BYTE *newEpcBuffer, DWORD newEpcBufferLen)
     * <br>
     * Write new EPC to tag with specific singulation.
     * <br>
     * This function sets also tag PC word correctly for new EPC length.
     * <br>
     * Tag can be singluted against desired memory bank and mask.
     * <br>
     *
     * <br>
     * @sa NurApiWriteEPCByEPC()
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     * @param    newEpcBuffer        New EPC to write.
     * <br>
     * @param    newEpcBufferLen        Number of EPC bytes to write. This must <b>divisible by two</b>.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiWriteEPC(HANDLE, DWORD, BOOL, BYTE, DWORD, int, BYTE*, BYTE*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2831</i>
     */
    public static int NurApiWriteEPC(Pointer<?> hApi, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, Pointer<Byte> newEpcBuffer, int newEpcBufferLen) {
        return NurApiWriteEPC(Pointer.getPeer(hApi), passwd, secured, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), Pointer.getPeer(newEpcBuffer), newEpcBufferLen);
    }

    protected native static int NurApiWriteEPC(@Ptr long hApi, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, @Ptr long newEpcBuffer, int newEpcBufferLen);

    /**
     * @fn int NurApiWriteEPCByEPC(HANDLE hApi, DWORD passwd, BOOL secured,
     * <br>
     * BYTE *epcBuffer, DWORD epcBufferLen,
     * <br>
     * BYTE *newEpcBuffer, DWORD newEpcBufferLen)
     * <br>
     * Write new EPC to specific tag singulated by tag's EPC memory.
     * <br>
     * This function sets also tag PC bytes correctly for new EPC length.
     * <br>
     *
     * <br>
     * @sa NurApiWriteEPC()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    epcBuffer            EPC memory to singulate against.
     * <br>
     * @param    epcBufferLen        Size of epcBuffer in bytes.
     * <br>
     * @param    newEpcBuffer        New EPC to write.
     * <br>
     * @param    newEpcBufferLen        Number of EPC bytes to write. This must <b>divisible by two</b>.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiWriteEPCByEPC(HANDLE, DWORD, BOOL, BYTE*, DWORD, BYTE*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2853</i>
     */
    public static int NurApiWriteEPCByEPC(Pointer<?> hApi, int passwd, int secured, Pointer<Byte> epcBuffer, int epcBufferLen, Pointer<Byte> newEpcBuffer, int newEpcBufferLen) {
        return NurApiWriteEPCByEPC(Pointer.getPeer(hApi), passwd, secured, Pointer.getPeer(epcBuffer), epcBufferLen, Pointer.getPeer(newEpcBuffer), newEpcBufferLen);
    }

    protected native static int NurApiWriteEPCByEPC(@Ptr long hApi, int passwd, int secured, @Ptr long epcBuffer, int epcBufferLen, @Ptr long newEpcBuffer, int newEpcBufferLen);

    /**
     * @fn int NurApiSetAccessPassword(HANDLE hApi, DWORD passwd, BOOL secured,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask,
     * <br>
     * DWORD newPasswd)
     * <br>
     * Write new access password to tag with specific singulation.
     * <br>
     * Tag can be singluted against desired memory bank and mask.
     * <br>
     *
     * <br>
     * @sa NurApiGetKillPassword(), NurApiGetKillPasswordByEPC(), NurApiSetKillPassword(), NurApiSetKillPasswordByEPC()
     * <br>
     * @sa NurApiGetAccessPassword(), NurApiGetAccessPasswordByEPC(), NurApiSetAccessPassword(), NurApiSetAccessPasswordByEPC()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     * @param    newPasswd            New access password to write.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiSetAccessPassword(HANDLE, DWORD, BOOL, BYTE, DWORD, int, BYTE*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2877</i>
     */
    public static int NurApiSetAccessPassword(Pointer<?> hApi, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, int newPasswd) {
        return NurApiSetAccessPassword(Pointer.getPeer(hApi), passwd, secured, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), newPasswd);
    }

    protected native static int NurApiSetAccessPassword(@Ptr long hApi, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, int newPasswd);

    /**
     * @fn int NurApiSetAccessPasswordByEPC(HANDLE hApi, DWORD passwd, BOOL secured,
     * <br>
     * BYTE *epcBuffer, DWORD epcBufferLen,
     * <br>
     * DWORD newPasswd)
     * <br>
     * Write new access password to specific tag singulated by tag's EPC memory.
     * <br>
     *
     * <br>
     * @sa NurApiGetKillPassword(), NurApiGetKillPasswordByEPC(), NurApiSetKillPassword(), NurApiSetKillPasswordByEPC()
     * <br>
     * @sa NurApiGetAccessPassword(), NurApiGetAccessPasswordByEPC(), NurApiSetAccessPassword(), NurApiSetAccessPasswordByEPC()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    epcBuffer            EPC memory to singulate against.
     * <br>
     * @param    epcBufferLen        Size of epcBuffer in bytes.
     * <br>
     * @param    newPasswd            New access password to write.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiSetAccessPasswordByEPC(HANDLE, DWORD, BOOL, BYTE*, DWORD, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2898</i>
     */
    public static int NurApiSetAccessPasswordByEPC(Pointer<?> hApi, int passwd, int secured, Pointer<Byte> epcBuffer, int epcBufferLen, int newPasswd) {
        return NurApiSetAccessPasswordByEPC(Pointer.getPeer(hApi), passwd, secured, Pointer.getPeer(epcBuffer), epcBufferLen, newPasswd);
    }

    protected native static int NurApiSetAccessPasswordByEPC(@Ptr long hApi, int passwd, int secured, @Ptr long epcBuffer, int epcBufferLen, int newPasswd);

    /**
     * @fn int NurApiGetAccessPassword(HANDLE hApi, DWORD passwd, BOOL secured,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask,
     * <br>
     * DWORD *currentPasswd)
     * <br>
     * Read access password from tag with specific singulation.
     * <br>
     * Tag can be singluted against desired memory bank and mask.
     * <br>
     *
     * <br>
     * @sa NurApiGetKillPassword(), NurApiGetKillPasswordByEPC(), NurApiSetKillPassword(), NurApiSetKillPasswordByEPC()
     * <br>
     * @sa NurApiGetAccessPassword(), NurApiGetAccessPasswordByEPC(), NurApiSetAccessPassword(), NurApiSetAccessPasswordByEPC()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     * @param    currentPasswd        Read access password is stored here.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiGetAccessPassword(HANDLE, DWORD, BOOL, BYTE, DWORD, int, BYTE*, DWORD*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2922</i>
     */
    public static int NurApiGetAccessPassword(Pointer<?> hApi, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, Pointer<Integer> currentPasswd) {
        return NurApiGetAccessPassword(Pointer.getPeer(hApi), passwd, secured, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), Pointer.getPeer(currentPasswd));
    }

    protected native static int NurApiGetAccessPassword(@Ptr long hApi, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, @Ptr long currentPasswd);

    /**
     * @fn int NurApiGetAccessPasswordByEPC(HANDLE hApi, DWORD passwd, BOOL secured,
     * <br>
     * BYTE *epcBuffer, DWORD epcBufferLen,
     * <br>
     * DWORD *currentPasswd)
     * <br>
     * Read access password from specific tag singulated by tag's EPC memory.
     * <br>
     *
     * <br>
     * @sa NurApiGetKillPassword(), NurApiGetKillPasswordByEPC(), NurApiSetKillPassword(), NurApiSetKillPasswordByEPC()
     * <br>
     * @sa NurApiGetAccessPassword(), NurApiGetAccessPasswordByEPC(), NurApiSetAccessPassword(), NurApiSetAccessPasswordByEPC()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    epcBuffer            EPC memory to singulate against.
     * <br>
     * @param    epcBufferLen        Size of epcBuffer in bytes.
     * <br>
     * @param    currentPasswd        Read access password is stored here.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiGetAccessPasswordByEPC(HANDLE, DWORD, BOOL, BYTE*, DWORD, DWORD*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2943</i>
     */
    public static int NurApiGetAccessPasswordByEPC(Pointer<?> hApi, int passwd, int secured, Pointer<Byte> epcBuffer, int epcBufferLen, Pointer<Integer> currentPasswd) {
        return NurApiGetAccessPasswordByEPC(Pointer.getPeer(hApi), passwd, secured, Pointer.getPeer(epcBuffer), epcBufferLen, Pointer.getPeer(currentPasswd));
    }

    protected native static int NurApiGetAccessPasswordByEPC(@Ptr long hApi, int passwd, int secured, @Ptr long epcBuffer, int epcBufferLen, @Ptr long currentPasswd);

    /**
     * @fn int NurApiSetKillPassword(HANDLE hApi, DWORD passwd, BOOL secured,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask,
     * <br>
     * DWORD newPasswd)
     * <br>
     * Write new kill password to tag with specific singulation.
     * <br>
     * Tag can be singluted against desired memory bank and mask.
     * <br>
     *
     * <br>
     * @sa NurApiGetKillPassword(), NurApiGetKillPasswordByEPC(), NurApiSetKillPassword(), NurApiSetKillPasswordByEPC()
     * <br>
     * @sa NurApiGetAccessPassword(), NurApiGetAccessPasswordByEPC(), NurApiSetAccessPassword(), NurApiSetAccessPasswordByEPC()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     * @param    newPasswd            New kill password to write.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiSetKillPassword(HANDLE, DWORD, BOOL, BYTE, DWORD, int, BYTE*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2967</i>
     */
    public static int NurApiSetKillPassword(Pointer<?> hApi, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, int newPasswd) {
        return NurApiSetKillPassword(Pointer.getPeer(hApi), passwd, secured, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), newPasswd);
    }

    protected native static int NurApiSetKillPassword(@Ptr long hApi, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, int newPasswd);

    /**
     * @fn int NurApiSetKillPasswordByEPC(HANDLE hApi, DWORD passwd, BOOL secured,
     * <br>
     * BYTE *epcBuffer, DWORD epcBufferLen,
     * <br>
     * DWORD newPasswd)
     * <br>
     * Write new kill password to specific tag singulated by tag's EPC memory.
     * <br>
     *
     * <br>
     * @sa NurApiGetKillPassword(), NurApiGetKillPasswordByEPC(), NurApiSetKillPassword(), NurApiSetKillPasswordByEPC()
     * <br>
     * @sa NurApiGetAccessPassword(), NurApiGetAccessPasswordByEPC(), NurApiSetAccessPassword(), NurApiSetAccessPasswordByEPC()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    epcBuffer            EPC memory to singulate against.
     * <br>
     * @param    epcBufferLen        Size of epcBuffer in bytes.
     * <br>
     * @param    newPasswd            New kill password to write.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiSetKillPasswordByEPC(HANDLE, DWORD, BOOL, BYTE*, DWORD, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:2988</i>
     */
    public static int NurApiSetKillPasswordByEPC(Pointer<?> hApi, int passwd, int secured, Pointer<Byte> epcBuffer, int epcBufferLen, int newPasswd) {
        return NurApiSetKillPasswordByEPC(Pointer.getPeer(hApi), passwd, secured, Pointer.getPeer(epcBuffer), epcBufferLen, newPasswd);
    }

    protected native static int NurApiSetKillPasswordByEPC(@Ptr long hApi, int passwd, int secured, @Ptr long epcBuffer, int epcBufferLen, int newPasswd);

    /**
     * @fn int NurApiGetKillPassword(HANDLE hApi, DWORD passwd, BOOL secured,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask,
     * <br>
     * DWORD *currentPasswd)
     * <br>
     * Read kill password from tag with specific singulation.
     * <br>
     * Tag can be singluted against desired memory bank and mask.
     * <br>
     *
     * <br>
     * @sa NurApiGetKillPassword(), NurApiGetKillPasswordByEPC(), NurApiSetKillPassword(), NurApiSetKillPasswordByEPC()
     * <br>
     * @sa NurApiGetAccessPassword(), NurApiGetAccessPasswordByEPC(), NurApiSetAccessPassword(), NurApiSetAccessPasswordByEPC()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     * @param    currentPasswd        Read kill password is stored here.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiGetKillPassword(HANDLE, DWORD, BOOL, BYTE, DWORD, int, BYTE*, DWORD*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3012</i>
     */
    public static int NurApiGetKillPassword(Pointer<?> hApi, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, Pointer<Integer> currentPasswd) {
        return NurApiGetKillPassword(Pointer.getPeer(hApi), passwd, secured, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), Pointer.getPeer(currentPasswd));
    }

    protected native static int NurApiGetKillPassword(@Ptr long hApi, int passwd, int secured, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, @Ptr long currentPasswd);

    /**
     * @fn int NurApiGetKillPasswordByEPC(HANDLE hApi, DWORD passwd, BOOL secured,
     * <br>
     * BYTE *epcBuffer, DWORD epcBufferLen,
     * <br>
     * DWORD *currentPasswd)
     * <br>
     * Read kill password from specific tag singulated by tag's EPC memory.
     * <br>
     *
     * <br>
     * @sa NurApiGetKillPassword(), NurApiGetKillPasswordByEPC(), NurApiSetKillPassword(), NurApiSetKillPasswordByEPC()
     * <br>
     * @sa NurApiGetAccessPassword(), NurApiGetAccessPasswordByEPC(), NurApiSetAccessPassword(), NurApiSetAccessPasswordByEPC()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations.
     * <br>
     * @param    secured                TRUE if operation is secured, otherwise FALSE.
     * <br>
     * @param    epcBuffer            EPC memory to singulate against.
     * <br>
     * @param    epcBufferLen        Size of epcBuffer in bytes.
     * <br>
     * @param    currentPasswd        Read access password is stored here.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiGetKillPasswordByEPC(HANDLE, DWORD, BOOL, BYTE*, DWORD, DWORD*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3033</i>
     */
    public static int NurApiGetKillPasswordByEPC(Pointer<?> hApi, int passwd, int secured, Pointer<Byte> epcBuffer, int epcBufferLen, Pointer<Integer> currentPasswd) {
        return NurApiGetKillPasswordByEPC(Pointer.getPeer(hApi), passwd, secured, Pointer.getPeer(epcBuffer), epcBufferLen, Pointer.getPeer(currentPasswd));
    }

    protected native static int NurApiGetKillPasswordByEPC(@Ptr long hApi, int passwd, int secured, @Ptr long epcBuffer, int epcBufferLen, @Ptr long currentPasswd);

    /**
     * @fn int NurApiSetLock(HANDLE hApi, DWORD passwd,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask,
     * <br>
     * DWORD memoryMask, DWORD action)
     * <br>
     * Set memory lock for tag with specific singulation.
     * <br>
     * Tag can be singluted against desired memory bank and mask.
     * <br>
     *
     * <br>
     * @sa NurApiSetLockRaw(), NurApiSetLockByEPC(), NUR_LOCKACTION, NUR_LOCKMEM
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations. Password is always needed.
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     * @param    memoryMask            Which memories to lock. All flags in enum NUR_LOCKMEM can be combined.
     * <br>
     * @param    action                Action to perform for memories. See enum NUR_LOCKACTION.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiSetLock(HANDLE, DWORD, BYTE, DWORD, int, BYTE*, DWORD, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3056</i>
     */
    public static int NurApiSetLock(Pointer<?> hApi, int passwd, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, int memoryMask, int action) {
        return NurApiSetLock(Pointer.getPeer(hApi), passwd, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), memoryMask, action);
    }

    protected native static int NurApiSetLock(@Ptr long hApi, int passwd, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, int memoryMask, int action);

    /**
     * @fn int NurApiSetLockRaw(HANDLE hApi, DWORD passwd,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask,
     * <br>
     * DWORD lockMask, DWORD lockAction)
     * <br>
     * Set memory lock for tag with specific singulation.
     * <br>
     * Tag can be singluted against desired memory bank and mask.
     * <br>
     * Lock mask and action parameter are in raw format defined in UHF C1G2 standard section "6.3.2.11.3.5 Lock (mandatory)".
     * <br>
     *
     * <br>
     * @sa NurApiSetLock()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations. Password is always needed.
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     * @param    lockMask            Standard defined lock payload bits 19-10, starting from bit 0.
     * <br>
     * @param    lockAction            Standard defined lock payload bits 9-0, starting from bit 0.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiSetLockRaw(HANDLE, DWORD, BYTE, DWORD, int, BYTE*, DWORD, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3080</i>
     */
    public static int NurApiSetLockRaw(Pointer<?> hApi, int passwd, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, int lockMask, int lockAction) {
        return NurApiSetLockRaw(Pointer.getPeer(hApi), passwd, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), lockMask, lockAction);
    }

    protected native static int NurApiSetLockRaw(@Ptr long hApi, int passwd, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, int lockMask, int lockAction);

    /**
     * @fn int NurApiSetLockByEPC(HANDLE hApi, DWORD passwd,
     * <br>
     * BYTE *epcBuffer, DWORD epcBufferLen,
     * <br>
     * DWORD memoryMask, DWORD action)
     * <br>
     * Set memory lock for specific tag singulated by tag's EPC memory.
     * <br>
     *
     * <br>
     * @sa NurApiSetLock(), NUR_LOCKACTION, NUR_LOCKMEM
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations. Password is always needed.
     * <br>
     * @param    epcBuffer            EPC memory to singulate against.
     * <br>
     * @param    epcBufferLen        Size of epcBuffer in bytes.
     * <br>
     * @param    memoryMask            Which memories to lock. All flags in enum NUR_LOCKMEM can be combined.
     * <br>
     * @param    action                Action to perform for memories. See enum NUR_LOCKACTION
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiSetLockByEPC(HANDLE, DWORD, BYTE*, DWORD, DWORD, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3100</i>
     */
    public static int NurApiSetLockByEPC(Pointer<?> hApi, int passwd, Pointer<Byte> epcBuffer, int epcBufferLen, int memoryMask, int action) {
        return NurApiSetLockByEPC(Pointer.getPeer(hApi), passwd, Pointer.getPeer(epcBuffer), epcBufferLen, memoryMask, action);
    }

    protected native static int NurApiSetLockByEPC(@Ptr long hApi, int passwd, @Ptr long epcBuffer, int epcBufferLen, int memoryMask, int action);

    /**
     * @fn int NurApiOpenStateLock(HANDLE hApi, BYTE sBank, DWORD sAddress, DWORD sMaskBitLength, BYTE *sMask, DWORD lockMask, DWORD lockAction)
     * <br>
     * <br>
     * Set memory lock for tag with specific singulation without using access password.
     * <br>
     * Tag can be singluted against desired memory bank and mask.
     * <br>
     *
     * <br>
     * @sa NurApiSetLockRaw(), NurApiSetLockByEPC(), NUR_LOCKACTION, NUR_LOCKMEM
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     * @param    lockMask            Which memories to lock. All flags in enum NUR_LOCKMEM can be combined.
     * <br>
     * @param    lockAction         Action to perform for memories. See enum NUR_LOCKACTION.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiOpenStateLock(HANDLE, BYTE, DWORD, DWORD, BYTE*, DWORD, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3121</i>
     */
    public static int NurApiOpenStateLock(Pointer<?> hApi, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, int lockMask, int lockAction) {
        return NurApiOpenStateLock(Pointer.getPeer(hApi), sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), lockMask, lockAction);
    }

    protected native static int NurApiOpenStateLock(@Ptr long hApi, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, int lockMask, int lockAction);

    /**
     * @fn int NurApiOpenStateLockRaw(HANDLE hApi, BYTE sBank, DWORD sAddress, DWORD sMaskBitLength, BYTE *sMask, DWORD lockMask, DWORD lockAction)
     * <br>
     * <br>
     * Set memory lock for tag with specific singulation without using access password.
     * <br>
     * Tag can be singluted against desired memory bank and mask.
     * <br>
     * Lock mask and action parameter are in raw format defined in UHF C1G2 standard section "6.3.2.11.3.5 Lock (mandatory)".
     * <br>
     *
     * <br>
     * @sa NurApiSetLock()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     * @param    lockMask            Standard defined lock payload bits 19-10, starting from bit 0.
     * <br>
     * @param    lockAction            Standard defined lock payload bits 9-0, starting from bit 0.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiOpenStateLockRaw(HANDLE, BYTE, DWORD, DWORD, BYTE*, DWORD, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3143</i>
     */
    public static int NurApiOpenStateLockRaw(Pointer<?> hApi, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, int lockMask, int lockAction) {
        return NurApiOpenStateLockRaw(Pointer.getPeer(hApi), sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), lockMask, lockAction);
    }

    protected native static int NurApiOpenStateLockRaw(@Ptr long hApi, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, int lockMask, int lockAction);

    /**
     * @fn NurApiOpenStateLockByEPC(HANDLE hApi, BYTE * epcBuffer, DWORD epcBufferLen, DWORD memoryMask, DWORD action)
     * <br>
     * <br>
     * Set memory lock for specific tag singulated by tag's EPC memory without using access password.
     * <br>
     *
     * <br>
     * @sa NurApiSetLock(), NUR_LOCKACTION, NUR_LOCKMEM
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    epcBuffer            EPC memory to singulate against.
     * <br>
     * @param    epcBufferLen        Size of epcBuffer in bytes.
     * <br>
     * @param    memoryMask            Which memories to lock. All flags in enum NUR_LOCKMEM can be combined.
     * <br>
     * @param    action                Action to perform for memories. See enum NUR_LOCKACTION
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiOpenStateLockByEPC(HANDLE, BYTE*, DWORD, DWORD, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3161</i>
     */
    public static int NurApiOpenStateLockByEPC(Pointer<?> hApi, Pointer<Byte> epcBuffer, int epcBufferLen, int memoryMask, int action) {
        return NurApiOpenStateLockByEPC(Pointer.getPeer(hApi), Pointer.getPeer(epcBuffer), epcBufferLen, memoryMask, action);
    }

    protected native static int NurApiOpenStateLockByEPC(@Ptr long hApi, @Ptr long epcBuffer, int epcBufferLen, int memoryMask, int action);

    /**
     * @fn int NurApiKillTag(HANDLE hApi, DWORD passwd,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask)
     * <br>
     * Kill tag with specific singulation.
     * <br>
     * Tag can be singluted against desired memory bank and mask.
     * <br>
     *
     * <br>
     * @sa NurApiKillTagByEPC()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations. Password is always needed.
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiKillTag(HANDLE, DWORD, BYTE, DWORD, int, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3181</i>
     */
    public static int NurApiKillTag(Pointer<?> hApi, int passwd, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask) {
        return NurApiKillTag(Pointer.getPeer(hApi), passwd, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask));
    }

    protected native static int NurApiKillTag(@Ptr long hApi, int passwd, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask);

    /**
     * @fn int NurApiKillTagByEPC(HANDLE hApi, DWORD passwd,
     * <br>
     * BYTE *epcBuffer, DWORD epcBufferLen)
     * <br>
     * Kill specific tag singulated by tag's EPC memory.
     * <br>
     *
     * <br>
     * @sa NurApiKillTag()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations. Password is always needed.
     * <br>
     * @param    epcBuffer            EPC memory to singulate against.
     * <br>
     * @param    epcBufferLen        Size of epcBuffer in bytes.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag data addressing.<br>
     * Original signature : <code>int NurApiKillTagByEPC(HANDLE, DWORD, BYTE*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3198</i>
     */
    public static int NurApiKillTagByEPC(Pointer<?> hApi, int passwd, Pointer<Byte> epcBuffer, int epcBufferLen) {
        return NurApiKillTagByEPC(Pointer.getPeer(hApi), passwd, Pointer.getPeer(epcBuffer), epcBufferLen);
    }

    protected native static int NurApiKillTagByEPC(@Ptr long hApi, int passwd, @Ptr long epcBuffer, int epcBufferLen);

    /**
     * @fn int NurApiNXPReadProtect(HANDLE hApi, DWORD passwd, BOOL protect,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask);
     * <br>
     * Set or reset specific tag's read protect with given singulation data.
     * <br>
     *
     * <br>
     * @sa NurApiNXPReadProtect()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations. Password is always needed.
     * <br>
     * @param    protect                TRUE to set (password not needed) FALSE to reset (password always used).
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag singulation.<br>
     * Original signature : <code>int NurApiNXPReadProtect(HANDLE, DWORD, BOOL, BYTE, DWORD, int, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3218</i>
     */
    public static int NurApiNXPReadProtect(Pointer<?> hApi, int passwd, int protect, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask) {
        return NurApiNXPReadProtect(Pointer.getPeer(hApi), passwd, protect, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask));
    }

    protected native static int NurApiNXPReadProtect(@Ptr long hApi, int passwd, int protect, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask);

    /**
     * @fn int NurApiNXPEAS(HANDLE hApi, DWORD passwd, BOOL set,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask);
     * <br>
     * <br>
     * Set or reset specific tag's EAS alarm with given singulation data.
     * <br>
     * When tag's EAS alarm bit is set to 1, tag will reply to EAS Alarm command.
     * <br>
     *
     * <br>
     * @sa NurApiNXPAlarm(), NurApiNXPStartAlarmStream(), NurApiNXPStopAlarmStream()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations. Password is always needed.
     * <br>
     * @param    set                    TRUE to set to alarm bit to 1, FALSE to reset alarm bit to 0: Password always used.
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag singulation.<br>
     * Original signature : <code>int NurApiNXPEAS(HANDLE, DWORD, BOOL, BYTE, DWORD, int, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3240</i>
     */
    public static int NurApiNXPEAS(Pointer<?> hApi, int passwd, int set, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask) {
        return NurApiNXPEAS(Pointer.getPeer(hApi), passwd, set, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask));
    }

    protected native static int NurApiNXPEAS(@Ptr long hApi, int passwd, int set, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask);

    /**
     * @fn int NurApiNXPAlarm(HANDLE hApi);
     * <br>
     * <br>
     * Send NXP EAS Alarm command. Return zero when there's armed EAS tags in range of reader.
     * <br>
     *
     * <br>
     * @sa NurApiNXPStartAlarmStream(), NurApiNXPStopAlarmStream(), NurApiNXPEAS()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     *
     * <br>
     * @return Zero when there's armed EAS tags in range of reader, NUR_ERROR_NO_TAG when no armed tags in range.<br>
     * Original signature : <code>int NurApiNXPAlarm(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3253</i>
     */
    public static int NurApiNXPAlarm(Pointer<?> hApi) {
        return NurApiNXPAlarm(Pointer.getPeer(hApi));
    }

    protected native static int NurApiNXPAlarm(@Ptr long hApi);

    /**
     * @fn int NurApiNXPStartAlarmStream(HANDLE hApi)
     * <br>
     * <br>
     * Start NXP EAS Alarm streaming on module.
     * <br>
     * Module will start continuos EAS Alarm stream and sends notification to host when there's armed tags in range.
     * <br>
     * <br>
     * @note Not supported in firmware version 3.1-A or older.
     * <br>
     * <br>
     * @sa NurApiNXPStopAlarmStream(), NUR_EASALARMSTREAM_DATA
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiNXPStartAlarmStream(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3269</i>
     */
    public static int NurApiNXPStartAlarmStream(Pointer<?> hApi) {
        return NurApiNXPStartAlarmStream(Pointer.getPeer(hApi));
    }

    protected native static int NurApiNXPStartAlarmStream(@Ptr long hApi);

    /**
     * @fn int NurApiNXPStopAlarmStream(HANDLE hApi)
     * <br>
     * <br>
     * Stop EAS Alarm streaming on module.
     * <br>
     * <br>
     * @note Not supported in firmware version 3.1-A or older.
     * <br>
     * <br>
     * @param    hApi    Handle to valid NurApi object instance
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiNXPStopAlarmStream(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3282</i>
     */
    public static int NurApiNXPStopAlarmStream(Pointer<?> hApi) {
        return NurApiNXPStopAlarmStream(Pointer.getPeer(hApi));
    }

    protected native static int NurApiNXPStopAlarmStream(@Ptr long hApi);

    /**
     * @fn BOOL NurApiIsNXPAlarmStreamRunning(HANDLE hApi)
     * <br>
     * <br>
     * Return TRUE if EAS Alarm stream routine is running on module.
     * <br>
     * <br>
     * @note Not supported in firmware version 3.1-A or older.
     * <br>
     * <br>
     * @param    hApi    Handle to valid NurApi object instance
     * <br>
     * <br>
     * @return TRUE if inventory stream routine is running. FALSE otherwise.<br>
     * Original signature : <code>BOOL NurApiIsNXPAlarmStreamRunning(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3295</i>
     */
    public static int NurApiIsNXPAlarmStreamRunning(Pointer<?> hApi) {
        return NurApiIsNXPAlarmStreamRunning(Pointer.getPeer(hApi));
    }

    protected native static int NurApiIsNXPAlarmStreamRunning(@Ptr long hApi);

    /**
     * @fn int NurApiMonza4QTWrite(HANDLE hApi, DWORD passwd, BOOL reduce, BOOL pubMem,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask);
     * <br>
     * Monza4 QT command. Writes the QT_SR and QT_MEM bits.
     * <br>
     *
     * <br>
     * @sa NurApiMonza4QTWrite()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations. Password is always needed.
     * <br>
     * @param    reduce                The QT_SR bit (0/1) (range reduction).
     * <br>
     * @param    pubMem                The QT_MEM bit (0/1) (public private memory selection).
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag singulation.<br>
     * Original signature : <code>int NurApiMonza4QTWrite(HANDLE, DWORD, BOOL, BOOL, BYTE, DWORD, int, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3316</i>
     */
    public static int NurApiMonza4QTWrite(Pointer<?> hApi, int passwd, int reduce, int pubMem, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask) {
        return NurApiMonza4QTWrite(Pointer.getPeer(hApi), passwd, reduce, pubMem, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask));
    }

    protected native static int NurApiMonza4QTWrite(@Ptr long hApi, int passwd, int reduce, int pubMem, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask);

    /**
     * @fn int NurApiMonza4QTRead(HANDLE hApi, DWORD passwd, BOOL *reduce, BOOL *pubMem,
     * <br>
     * BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask);
     * <br>
     * Monza4 QT command. Reads the QT_SR and QT_MEM bits.
     * <br>
     *
     * <br>
     * @sa NurApiMonza4QTWrite()
     * <br>
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    passwd                Password for secured operations. Password is always needed.
     * <br>
     * @param    *reduce				Pointer to BOOL indicating whether the read range is reduced or not.
     * <br>
     * @param    *pubMem				Pointer to BOOL indicating whether the tag uses public memory or not.
     * <br>
     * @param    sBank                Memory bank used for tag singulation.
     * <br>
     * @param    sAddress            Singulation data address in <b>bits</b>.
     * <br>
     * @param    sMaskBitLength Length of the mask data in <b>bits</b>.
     * <br>
     * @param    sMask Mask data buffer.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remark This function uses 32-bit tag singulation.<br>
     * Original signature : <code>int NurApiMonza4QTRead(HANDLE, DWORD, BOOL*, BOOL*, BYTE, DWORD, int, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3337</i>
     */
    public static int NurApiMonza4QTRead(Pointer<?> hApi, int passwd, Pointer<Integer> reduce, Pointer<Integer> pubMem, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask) {
        return NurApiMonza4QTRead(Pointer.getPeer(hApi), passwd, Pointer.getPeer(reduce), Pointer.getPeer(pubMem), sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask));
    }

    protected native static int NurApiMonza4QTRead(@Ptr long hApi, int passwd, @Ptr long reduce, @Ptr long pubMem, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask);

    /**
     * @fn int NurApiFactoryReset(HANDLE hApi, DWORD resetcode)
     * <br>
     * Reset factory defaults.
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance
     * <br>
     * @param    resetcode        Set this value to 0x994F6B32.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiFactoryReset(HANDLE, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3348</i>
     */
    public static int NurApiFactoryReset(Pointer<?> hApi, int resetcode) {
        return NurApiFactoryReset(Pointer.getPeer(hApi), resetcode);
    }

    protected native static int NurApiFactoryReset(@Ptr long hApi, int resetcode);

    /**
     * @fn int NurApiModuleRestart(HANDLE hApi)
     * <br>
     * <br>
     * Restart NUR Module.
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiModuleRestart(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3358</i>
     */
    public static int NurApiModuleRestart(Pointer<?> hApi) {
        return NurApiModuleRestart(Pointer.getPeer(hApi));
    }

    protected native static int NurApiModuleRestart(@Ptr long hApi);

    /**
     * @fn int NurApiResetToTarget(HANDLE hApi, BYTE session, BOOL targetIsA)
     * <br>
     * <br>
     * Reset tags inventoried state to desired target A or B.
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance
     * <br>
     * @param    session            Which session to reset. Value 0 - 3
     * <br>
     * @param    targetIsA        TRUE if desired target is A, FALSE for target B
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiResetToTarget(HANDLE, BYTE, BOOL)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3370</i>
     */
    public static int NurApiResetToTarget(Pointer<?> hApi, byte session, int targetIsA) {
        return NurApiResetToTarget(Pointer.getPeer(hApi), session, targetIsA);
    }

    protected native static int NurApiResetToTarget(@Ptr long hApi, byte session, int targetIsA);

    /**
     * @fn int NurApiGetEthConfig(HANDLE hApi,struct NUR_ETHDEV_CONFIG *resp,DWORD cfgSize)
     * <br>
     * <br>
     * Get Ethernet configuration settings from conneted device.
     * <br>
     * Getting ethernet setting from all Sampo devices in network same time, use NurApiSendBroadcast().
     * <br>
     * NUR_NOTIFICATION_DEVSEARCH nofication appears every time Sampo device founded from network including configuration info.
     * <br>
     *
     * <br>
     * @sa NUR_ETHDEV_CONFIG, NurApiSetEthConfig()
     * <br>
     * @param    hApi            Handle to valid NurApi object instance
     * <br>
     * @param    *resp			Pointer to NUR_ETHDEV_CONFIG struct for receiving configuration data
     * <br>
     * @param    cfgSize            Size of NUR_ETHDEV_CONFIG struct
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetEthConfig(HANDLE, NUR_ETHDEV_CONFIG*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3385</i>
     */
    public static int NurApiGetEthConfig(Pointer<?> hApi, Pointer<NUR_ETHDEV_CONFIG> resp, int cfgSize) {
        return NurApiGetEthConfig(Pointer.getPeer(hApi), Pointer.getPeer(resp), cfgSize);
    }

    protected native static int NurApiGetEthConfig(@Ptr long hApi, @Ptr long resp, int cfgSize);

    /**
     * @fn int NurApiSetEthConfig(HANDLE hApi, struct NUR_ETHDEV_CONFIG *vi, DWORD viSize)
     * <br>
     * <br>
     * Set Ethernet configuration to currently connected device (USB, serial or TCP/IP)
     * <br>
     * 1. Set transport to 0 at NUR_ETHDEV_CONFIG struct
     * <br>
     * Set ethernet setting to specified Sampo using Broadcast:
     * <br>
     * 1. Set transport to 1 at NUR_ETHDEV_CONFIG struct
     * <br>
     * 2. Specify mac address of target Sampo at NUR_ETHDEV_CONFIG struct
     * <br>
     * @sa NUR_ETHDEV_CONFIG, NurApiGetEthConfig()
     * <br>
     * @param    hApi            Handle to valid NurApi object instance
     * <br>
     * @param    *vi				Pointer to NUR_ETHDEV_CONFIG struct for configuration data
     * <br>
     * @param    viSize            Size of NUR_ETHDEV_CONFIG struct
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiSetEthConfig(HANDLE, NUR_ETHDEV_CONFIG*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3401</i>
     */
    public static int NurApiSetEthConfig(Pointer<?> hApi, Pointer<NUR_ETHDEV_CONFIG> vi, int viSize) {
        return NurApiSetEthConfig(Pointer.getPeer(hApi), Pointer.getPeer(vi), viSize);
    }

    protected native static int NurApiSetEthConfig(@Ptr long hApi, @Ptr long vi, int viSize);

    /**
     * @fn int NurApiSendBroadcast(HANDLE hApi,int cmd,int filterType,int filterOp, BYTE *filterData, int filterSize, BYTE *data, DWORD dataLength)
     * <br>
     * Broadcast messages are used mainly for searching Sampo devices from network.
     * <br>
     * Broadcast message can also be used for Get/Set ethernet configurations of Sampo devices
     * <br>
     * Send Broadcast message using specified command and optional filters.
     * <br>
     * Broadcast message is sent to all Sampo devices in network but only those Sampo devices receives and executes messages which met filter rules.
     * <br>
     * If filter type has been set to NUR_BC_FILTER_TYPE_NONE then all devices recevies and executes broadcast message.
     * <br>
     * @sa NUR_BC_CMD, NUR_BC_FILTER_TYPE, NUR_BC_FILTER_OP
     * <br>
     * @param    hApi            Handle to valid NurApi object instance
     * <br>
     * @param    cmd                Broadcast command. see NUR_BC_CMD)
     * <br>
     * @param    filterType        Filter type: see NUR_BC_FILTER_TYPE
     * <br>
     * @param    filterOp        Filter operation: see NUR_BC_FILTER_OP
     * <br>
     * @param    filterData        Filter data. Max 16 bytes. Typically char string.
     * <br>
     * @param    filterSize        Size of filter data in bytes.
     * <br>
     * @param    data            Broadcast command data. cmd specified what kind of data need to send to Sampo device(s)
     * <br>
     * @param    dataLength        Size of Broadcast command data
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiSendBroadcast(HANDLE, int, int, int, BYTE*, int, BYTE*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3421</i>
     */
    public static int NurApiSendBroadcast(Pointer<?> hApi, int cmd, int filterType, int filterOp, Pointer<Byte> filterData, int filterSize, Pointer<Byte> data, int dataLength) {
        return NurApiSendBroadcast(Pointer.getPeer(hApi), cmd, filterType, filterOp, Pointer.getPeer(filterData), filterSize, Pointer.getPeer(data), dataLength);
    }

    protected native static int NurApiSendBroadcast(@Ptr long hApi, int cmd, int filterType, int filterOp, @Ptr long filterData, int filterSize, @Ptr long data, int dataLength);

    /**
     * @fn int NurApiDiscoverDevices(HANDLE hApi, DWORD timeout)
     * <br>
     * <br>
     * Runs a one device discovery round. It is possible that during the call information
     * <br>
     * about the found devices is passed via device search -notification if there is an API callback correctly set up.
     * <br>
     *
     * <br>
     * @sa MIN_DEVQUERY_TIMEOUT, MAX_DEVQUERY_TIMEOUT, NUR_NOTIFICATION_DEVSEARCH, NurApiSetNotificationCallback
     * <br>
     * @param    hApi            Handle to valid NurApi object instance
     * <br>
     * @param    timeout            This is the response wait timeout. Unit is milliseconds and the range is MIN_DEVQUERY_TIMEOUT...MAX_DEVQUERY_TIMEOUT.
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiDiscoverDevices(HANDLE, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3434</i>
     */
    public static int NurApiDiscoverDevices(Pointer<?> hApi, int timeout) {
        return NurApiDiscoverDevices(Pointer.getPeer(hApi), timeout);
    }

    protected native static int NurApiDiscoverDevices(@Ptr long hApi, int timeout);

    /**
     * @fn int NurApiStartDeviceDiscovery(HANDLE hApi, DWORD timeout)
     * <br>
     * Starts a background thread that constantly queries Sampo devices from the local network.
     * <br>
     * @sa NUR_BC_FILTER_OP, MIN_DEVQUERY_TIMEOUT, MAX_DEVQUERY_TIMEOUT
     * <br>
     * @param    hApi            Handle to valid NurApi object instance
     * <br>
     * @param    timeout            This is the response wait timeout. Unit is milliseconds and the range is MIN_DEVQUERY_TIMEOUT...MAX_DEVQUERY_TIMEOUT.
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiStartDeviceDiscovery(HANDLE, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3444</i>
     */
    public static int NurApiStartDeviceDiscovery(Pointer<?> hApi, int timeout) {
        return NurApiStartDeviceDiscovery(Pointer.getPeer(hApi), timeout);
    }

    protected native static int NurApiStartDeviceDiscovery(@Ptr long hApi, int timeout);

    /**
     * @fn int NurApiStopDeviceDiscovery(HANDLE hApi)
     * <br>
     * Interrupts the current Sampo device query if it is running.
     * <br>
     * @sa NurApiStartDeviceDiscovery, NurApiSendBroadcast
     * <br>
     * <br>
     * @param    hApi Handle to valid NurApi object instance
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiStopDeviceDiscovery(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3455</i>
     */
    public static int NurApiStopDeviceDiscovery(Pointer<?> hApi) {
        return NurApiStopDeviceDiscovery(Pointer.getPeer(hApi));
    }

    protected native static int NurApiStopDeviceDiscovery(@Ptr long hApi);

    /**
     * @fn int NurApiIsDiscovering(HANDLE hApi)
     * <br>
     * Used to check whether there is an ongoing device discovery.
     * <br>
     * @sa NurApiStartDeviceDiscovery, NurApiStopDeviceDiscovery, NurApiSendBroadcast
     * <br>
     * <br>
     * @param    hApi Handle to valid NurApi object instance
     * <br>
     * <br>
     * @return Zero when succeeded (discovery running), non-zero error code otherwise.<br>
     * Original signature : <code>int NurApiIsDiscovering(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3466</i>
     */
    public static int NurApiIsDiscovering(Pointer<?> hApi) {
        return NurApiIsDiscovering(Pointer.getPeer(hApi));
    }

    protected native static int NurApiIsDiscovering(@Ptr long hApi);

    /**
     * @param hApi   Handle to valid NurApi object instance
     *               <br>
     * @param si     Pointer to the NUR_SYSTEMINFO structure.
     *               <br>
     * @param siSize Minimum size of 'si'.
     *               <br>
     *               <br>
     * @fn int NurApiGetSystemInfo(HANDLE hApi, struct NUR_SYSTEMINFO *si, DWORD siSize)
     * <br>
     * Return information about the module itnernals.
     * <br>
     * <br>
     * @sa NUR_SYSTEMINFO
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetSystemInfo(HANDLE, NUR_SYSTEMINFO*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3480</i>
     */
    public static int NurApiGetSystemInfo(Pointer<?> hApi, Pointer<NUR_SYSTEMINFO> si, int siSize) {
        return NurApiGetSystemInfo(Pointer.getPeer(hApi), Pointer.getPeer(si), siSize);
    }

    protected native static int NurApiGetSystemInfo(@Ptr long hApi, @Ptr long si, int siSize);

    /**
     * @param hApi         Handle to valid NurApi object instance
     *                     <br>
     * @param cmd          Command that the module's comman handler processes.
     *                     <br>
     * @param inbuffer     Parameters for this command.
     *                     <br>
     * @param inbufferLen  Length, in bytes, of the parameters.
     *                     <br>
     * @param outbuffer    Pointer to the response buffer.
     *                     <br>
     * @param outbufferLen Maximum output buffer length.
     *                     <br>
     * @param bytesRet     Pointer to an unsigned integer where the response's actual length is stored to.
     *                     <br>
     *                     <br>
     * @fn int NurApiCustomCmd(HANDLE hApi, BYTE cmd, BYTE *inbuffer, DWORD inbufferLen, BYTE *outbuffer, DWORD outbufferLen, DWORD *bytesRet)
     * <br>
     * executes a freely formatted custom exchange with a tag.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiCustomCmd(HANDLE, BYTE, BYTE*, DWORD, BYTE*, DWORD, DWORD*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3496</i>
     */
    public static int NurApiCustomCmd(Pointer<?> hApi, byte cmd, Pointer<Byte> inbuffer, int inbufferLen, Pointer<Byte> outbuffer, int outbufferLen, Pointer<Integer> bytesRet) {
        return NurApiCustomCmd(Pointer.getPeer(hApi), cmd, Pointer.getPeer(inbuffer), inbufferLen, Pointer.getPeer(outbuffer), outbufferLen, Pointer.getPeer(bytesRet));
    }

    protected native static int NurApiCustomCmd(@Ptr long hApi, byte cmd, @Ptr long inbuffer, int inbufferLen, @Ptr long outbuffer, int outbufferLen, @Ptr long bytesRet);

    /**
     * @param hApi         Handle to valid NurApi object instance
     *                     <br>
     * @param antenna      Antenna to use. Value is 0...max antennas.
     *                     <br>
     * @param wideTune     If set to TRUE the tuning is done in wider range opposing to FALSE which 'fast tune'
     *                     <br>
     * @param bSaveResults If set to TRUE then the tuning results will be stored into the module's non-volatile memory.
     *                     <br>
     * @param dBmResults   Pointer to 6 integer values. The reflected power will be stored into these values in format dBm * 1000.
     *                     <br>
     *                     This parameter may be NULL.
     *                     <br>
     *                     <br>
     * @fn int NurApiTuneAntenna(HANDLE hApi, int antenna, BOOL wideTune, BOOL bSaveResults, int *dBmResults)
     * <br>
     * Executes an antenna tune.
     * <br>
     * <br>
     * @return Zero when succeeded, on error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiTuneAntenna(HANDLE, int, BOOL, BOOL, int*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3511</i>
     */
    public static int NurApiTuneAntenna(Pointer<?> hApi, int antenna, int wideTune, int bSaveResults, Pointer<Integer> dBmResults) {
        return NurApiTuneAntenna(Pointer.getPeer(hApi), antenna, wideTune, bSaveResults, Pointer.getPeer(dBmResults));
    }

    protected native static int NurApiTuneAntenna(@Ptr long hApi, int antenna, int wideTune, int bSaveResults, @Ptr long dBmResults);

    /**
     * @param hApi       Handle to valid NurApi object instance
     *                   <br>
     * @param code       Production tune code
     *                   <br>
     * @param dBmResults Pointer to 6 integer values. The reflected power will be stored into these values in format dBm * 1000.
     *                   <br>
     *                   This parameter may be NULL.
     *                   <br>
     *                   <br>
     * @fn int NurApiProductionTune(HANDLE hApi, BYTE *code, int *dBmResults)
     * <br>
     * Executes an production tune. NOTE: Only used at Nordic ID production.
     * <br>
     * <br>
     * @return Zero when succeeded, on error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiProductionTune(HANDLE, BYTE*, int*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3524</i>
     */
    public static int NurApiProductionTune(Pointer<?> hApi, Pointer<Byte> code, Pointer<Integer> dBmResults) {
        return NurApiProductionTune(Pointer.getPeer(hApi), Pointer.getPeer(code), Pointer.getPeer(dBmResults));
    }

    protected native static int NurApiProductionTune(@Ptr long hApi, @Ptr long code, @Ptr long dBmResults);

    /**
     * @param hApi         Handle to valid NurApi object instance
     *                     <br>
     * @param factoryReset If set to TRUE the tuning is restored from the factory defaults.
     *                     <br>
     *                     Otherwise it is from the last saved user tuning.
     *                     <br>
     *                     <br>
     * @fn int NurApiRestoreTuning(HANDLE hApi, BOOL factoryReset)
     * <br>
     * Executes an antenna tune.
     * <br>
     * <br>
     * @return Zero when succeeded, on error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiRestoreTuning(HANDLE, BOOL)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3536</i>
     */
    public static int NurApiRestoreTuning(Pointer<?> hApi, int factoryReset) {
        return NurApiRestoreTuning(Pointer.getPeer(hApi), factoryReset);
    }

    protected native static int NurApiRestoreTuning(@Ptr long hApi, int factoryReset);

    /**
     * @param hApi  Handle to valid NurApi object instance
     *              <br>
     * @param pCaps Pointer to NUR_DEVICECAPS structure.
     *              <br>
     *              <br>
     * @fn int NurApiGetDeviceCaps(HANDLE hApi, struct NUR_DEVICECAPS *pCaps)
     * <br>
     * Gets currently connected dewvice's capabilities.
     * <br>
     * <br>
     * @sa NUR_DEVICECAPS
     * <br>
     * <br>
     * @return Zero when succeeded, on error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetDeviceCaps(HANDLE, NUR_DEVICECAPS*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3549</i>
     */
    public static int NurApiGetDeviceCaps(Pointer<?> hApi, Pointer<NUR_DEVICECAPS> pCaps) {
        return NurApiGetDeviceCaps(Pointer.getPeer(hApi), Pointer.getPeer(pCaps));
    }

    protected native static int NurApiGetDeviceCaps(@Ptr long hApi, @Ptr long pCaps);

    /**
     * @param hApi       Handle to valid NurApi object instance
     *                   <br>
     * @param pMode      Current mode will be stored here ('A'=app, 'B'=loader) if valid pointer.
     *                   <br>
     * @param pPrimary   Pointer to the primary version string (in the loader the loader version and in the application the application version). Must be at least 16 characters long.
     *                   <br>
     * @param pSecondary Pointer to the secondary version string (in the loader the application version and in the application the loader version). Must be at least 16 characters long.
     *                   <br>
     *                   <br>
     * @fn int NurApiGetVersions(HANDLE hApi, BYTE *pMode, TCHAR *pPrimary, TCHAR *pSecondary)
     * <br>
     * Gets current mode and the versions store to the module.
     * <br>
     * <br>
     * @return Zero when succeeded, on error non-zero error code is returned. One of the pointer parameters must be non-null.<br>
     * Original signature : <code>int NurApiGetVersions(HANDLE, BYTE*, TCHAR*, TCHAR*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3562</i>
     */
    public static int NurApiGetVersions(Pointer<?> hApi, Pointer<Byte> pMode, Pointer<Byte> pPrimary, Pointer<Byte> pSecondary) {
        return NurApiGetVersions(Pointer.getPeer(hApi), Pointer.getPeer(pMode), Pointer.getPeer(pPrimary), Pointer.getPeer(pSecondary));
    }

    protected native static int NurApiGetVersions(@Ptr long hApi, @Ptr long pMode, @Ptr long pPrimary, @Ptr long pSecondary);

    /**
     * @param hApi Handle to valid NurApi object instance
     *             <br>
     * @param freq Frequency to use for the measurement in kHz. Use 0 to measure current region middle frequency.
     *             <br>
     * @param pdBm Pointer to the integer value of reflectedpower. Unit is dBm and the value is multiplied by 1000.
     *             <br>
     *             <br>
     * @fn int NurApiGetReflectedPowerValue(HANDLE hApi, DWORD freq, int *pdBm)
     * <br>
     * Returns the reflected power value for given frequency or current region middle frequency.
     * <br>
     * <br>
     * @note The value stored via the integer pointer should be casted to double and then divided by 1000.0 in order to get the actual value.
     * <br>
     * <br>
     * @return Zero when succeeded, on error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetReflectedPowerValue(HANDLE, DWORD, int*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3576</i>
     */
    public static int NurApiGetReflectedPowerValue(Pointer<?> hApi, int freq, Pointer<Integer> pdBm) {
        return NurApiGetReflectedPowerValue(Pointer.getPeer(hApi), freq, Pointer.getPeer(pdBm));
    }

    protected native static int NurApiGetReflectedPowerValue(@Ptr long hApi, int freq, @Ptr long pdBm);

    /**
     * @param hApi  Handle to valid NurApi object instance
     *              <br>
     * @param pInfo Pointer to the NUR_EPCENUMINFO that control how the enumeration is done.
     *              <br>
     *              <br>
     * @fn int NurApiStartEPCEnumeration(HANDLE hApi, struct NUR_EPCENUMINFO *pInfo)
     * <br>
     * Starts the TID content based EPC enumeration process (continuous function).
     * <br>
     * <br>
     * @sa NUR_EPCENUMINFO
     * <br>
     * <br>
     * @return Zero when succeeded, on error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiStartEPCEnumeration(HANDLE, NUR_EPCENUMINFO*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3589</i>
     */
    public static int NurApiStartEPCEnumeration(Pointer<?> hApi, Pointer<NUR_EPCENUMINFO> pInfo) {
        return NurApiStartEPCEnumeration(Pointer.getPeer(hApi), Pointer.getPeer(pInfo));
    }

    protected native static int NurApiStartEPCEnumeration(@Ptr long hApi, @Ptr long pInfo);

    /**
     * @param hApi Handle to valid NurApi object instance
     *             <br>
     *             <br>
     * @fn int NurApiStopEPCEnumeration(HANDLE hApi)
     * <br>
     * Stops the currently ongoing TID based EPC enumeration process.
     * <br>
     * <br>
     * @sa NUR_EPCENUMINFO
     * <br>
     * <br>
     * @return Zero when succeeded, on error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiStopEPCEnumeration(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3601</i>
     */
    public static int NurApiStopEPCEnumeration(Pointer<?> hApi) {
        return NurApiStopEPCEnumeration(Pointer.getPeer(hApi));
    }

    protected native static int NurApiStopEPCEnumeration(@Ptr long hApi);

    /**
     * @param hApi Handle to valid NurApi object instance
     *             <br>
     *             <br>
     * @fn int NurApiIsEPCEnumRunning(HANDLE hApi)
     * <br>
     * Returns whether the EPC enumeration is currently running or not.
     * <br>
     * <br>
     * @sa NurApiStartEPCEnumeration, NurApiStopEPCEnumeration
     * <br>
     * <br>
     * @return TRUE if API handle is valid and stream running, FALSE otherwise.<br>
     * Original signature : <code>BOOL NurApiIsEPCEnumRunning(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3613</i>
     */
    public static int NurApiIsEPCEnumRunning(Pointer<?> hApi) {
        return NurApiIsEPCEnumRunning(Pointer.getPeer(hApi));
    }

    protected native static int NurApiIsEPCEnumRunning(@Ptr long hApi);

    /**
     * @param hApi   Handle to valid NurApi object instance
     *               <br>
     * @param buf    Pointer to string buffer
     *               <br>
     * @param buflen Length of 'buf' in characters
     *               <br>
     *               <br>
     * @fn int NurApiGetFWINFO(HANDLE hApi, TCHAR *buf, DWORD buflen)
     * <br>
     * Get current FW information string.
     * <br>
     * <br>
     * @return Zero when succeeded, on error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetFWINFO(HANDLE, TCHAR*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3625</i>
     */
    public static int NurApiGetFWINFO(Pointer<?> hApi, Pointer<Byte> buf, int buflen) {
        return NurApiGetFWINFO(Pointer.getPeer(hApi), Pointer.getPeer(buf), buflen);
    }

    protected native static int NurApiGetFWINFO(@Ptr long hApi, @Ptr long buf, int buflen);

    /**
     * @param hApi Handle to valid NurApi object instance
     *             <br>
     * @param on   If TRUE, then the carrier is left on after next command. When set to FALSE the carrier is shut down immediately.
     *             <br>
     *             <br>
     * @fn int NurApiSetExtCarrier(HANDLE hApi, BOOL on)
     * <br>
     *
     * <br>
     * Causes the module to leave carrier on after a command and not to jump to new frequency.
     * <br>
     * The carrier on time is limited by the maximum channel time.
     * <br>
     * <br>
     * @return Zero when successful. A non-zero error code otherwise.<br>
     * Original signature : <code>int NurApiSetExtCarrier(HANDLE, BOOL)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3638</i>
     */
    public static int NurApiSetExtCarrier(Pointer<?> hApi, int on) {
        return NurApiSetExtCarrier(Pointer.getPeer(hApi), on);
    }

    protected native static int NurApiSetExtCarrier(@Ptr long hApi, int on);

    /**
     * @param hApi       Handle to valid NurApi object instance
     *                   <br>
     * @param channelIdx Channel index to use in current hop table. Set -1 to restore normal channel hopping.
     *                   <br>
     *                   <br>
     * @fn int NurApiSetConstantChannelIndex(HANDLE hApi, int channelIdx)
     * <br>
     *
     * <br>
     * Set channel index to use in current hop table.
     * <br>
     * This prevents NUR from hopping in different channel.
     * <br>
     * Use with care: RF frequency is locked as long as this is set.
     * <br>
     * Restore normal channel hopping with parameter -1
     * <br>
     * <br>
     * @return Zero when successful. A non-zero error code otherwise.<br>
     * Original signature : <code>int NurApiSetConstantChannelIndex(HANDLE, int)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3653</i>
     */
    public static int NurApiSetConstantChannelIndex(Pointer<?> hApi, int channelIdx) {
        return NurApiSetConstantChannelIndex(Pointer.getPeer(hApi), channelIdx);
    }

    protected native static int NurApiSetConstantChannelIndex(@Ptr long hApi, int channelIdx);

    /**
     * @param hApi         Handle to valid NurApi object instance
     *                     <br>
     * @param antennaMap   Pointer to a struct NUR_ANTENNA_MAPPING array where the results are stored into.
     *                     <br>
     * @param nrMappings   The number physical antenna mappings retrieved is stored here.
     *                     <br>
     * @param maxnMappings Number of mapping to retrieve, the range is 1...NUR_MAX_ANTENNAS_EX.
     *                     <br>
     * @param szMapping    Size of single antenna mapping, use sizeof(struct NUR_ANTENNA_MAPPING).
     *                     <br>
     *                     <br>
     * @fn int NurApiGetAntennaMap(HANDLE hApi, struct NUR_ANTENNA_MAPPING *antennaMap, int *nrMappings, int maxnMappings, DWORD szMapping)
     * <br>
     *
     * <br>
     * This function retrieves the antenna mapping from the device i.e. the physical names of the antennas.
     * <br>
     * <br>
     * @return Zero when successful. A non-zero error code otherwise.
     * <br>
     * <br>
     * @remark The parameters @sa antennaMap, @sa nrMappings and @sa szMapping can be seto to zero in which case the API refreshes its internal antenna mapping.
     * <br>
     * <br>
     * @sa MAX_MAPPINGLEN, NUR_MAX_ANTENNAS_EX, struct NUR_ANTENNA_MAPPING<br>
     * Original signature : <code>int NurApiGetAntennaMap(HANDLE, NUR_ANTENNA_MAPPING*, int*, int, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3672</i>
     */
    public static int NurApiGetAntennaMap(Pointer<?> hApi, Pointer<NUR_ANTENNA_MAPPING> antennaMap, Pointer<Integer> nrMappings, int maxnMappings, int szMapping) {
        return NurApiGetAntennaMap(Pointer.getPeer(hApi), Pointer.getPeer(antennaMap), Pointer.getPeer(nrMappings), maxnMappings, szMapping);
    }

    protected native static int NurApiGetAntennaMap(@Ptr long hApi, @Ptr long antennaMap, @Ptr long nrMappings, int maxnMappings, int szMapping);

    /**
     * @param hApi           Handle to valid NurApi object instance
     *                       <br>
     * @param commaSeparated Comma-separated physical antenna specifier.
     *                       <br>
     * @param disableOthers  If set to TRUE, antennas that are not specified in comma separated string will be disabled. If set to FALSE, antennas that are already enabled will remain enabled.
     *                       <br>
     *                       <br>
     * @fn int NurApiEnablePhysicalAntenna(HANDLE hApi, const TCHAR *commaSeparated, BOOL disableOthers)
     * <br>
     *
     * <br>
     * This function enables the physical antennas that are specified as comma separated string parameter.
     * <br>
     * <br>
     * @return Zero when successful. A non-zero error code otherwise.
     * <br>
     * <br>
     * @remark The specifier string can be e.g. "Beam1,Beam2.X": specifies that Beam1 both polarities and Beam2 X-polarity are enabled.
     * <br>
     * @remark If only "ALL" is passed to this function it will then enable all antennas.
     * <br>
     * <br>
     * @sa NurApiDisableAntennasEx<br>
     * Original signature : <code>int NurApiEnablePhysicalAntenna(HANDLE, const TCHAR*, BOOL)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3690</i>
     */
    public static int NurApiEnablePhysicalAntenna(Pointer<?> hApi, Pointer<Byte> commaSeparated, int disableOthers) {
        return NurApiEnablePhysicalAntenna(Pointer.getPeer(hApi), Pointer.getPeer(commaSeparated), disableOthers);
    }

    protected native static int NurApiEnablePhysicalAntenna(@Ptr long hApi, @Ptr long commaSeparated, int disableOthers);

    /**
     * @param hApi           Handle to valid NurApi object instance
     *                       <br>
     * @param commaSeparated Comma-separated physical antenna specifier.
     *                       <br>
     *                       <br>
     * @fn int NurApiDisablePhysicalAntenna(HANDLE hApi, const TCHAR *commaSeparated)
     * <br>
     *
     * <br>
     * This function disables the physical antennas that are specified as comma separated string parameter.
     * <br>
     * <br>
     * @return Zero when successful. A non-zero error code otherwise.
     * <br>
     * <br>
     * @remark The specifier string can be e.g. "Beam1,Beam2,Beam3": specifies that Beam1...3 will be disabled.
     * <br>
     * @sa NurApiEnableAntennasEx<br>
     * Original signature : <code>int NurApiDisablePhysicalAntenna(HANDLE, const TCHAR*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3705</i>
     */
    public static int NurApiDisablePhysicalAntenna(Pointer<?> hApi, Pointer<Byte> commaSeparated) {
        return NurApiDisablePhysicalAntenna(Pointer.getPeer(hApi), Pointer.getPeer(commaSeparated));
    }

    protected native static int NurApiDisablePhysicalAntenna(@Ptr long hApi, @Ptr long commaSeparated);

    /**
     * @param hApi       Handle to valid NurApi object instance
     *                   <br>
     * @param antennaId  Logical antenna number (identifier) to be looked up.
     *                   <br>
     * @param name       The name of the antenna (if ound) is stored here. Allocate a minimum of MAX_MAPPINGLEN + 1 characters.
     *                   <br>
     * @param maxNameLen Maximum number of characters in "name". Minimum required is MAX_MAPPINGLEN.
     *                   <br>
     *                   <br>
     * @fn int NurApiAntennaIdToPhysicalAntenna(HANDLE hApi, int antennaId, TCHAR *name, int maxNameLen)
     * <br>
     * <br>
     * This function maps given logical antenna identifier to a physical name of an antenna.
     * <br>
     *
     * <br>
     * @return Zero when successful. A non-zero error code otherwise.
     * <br>
     * <br>
     * @remark When the function return NUR_ERROR_GENERAL it means that the antenna mapping is present, but ID was not found.
     * <br>
     * <br>
     * @sa MAX_MAPPINGLEN, NUR_MAX_ANTENNAS_EX<br>
     * Original signature : <code>int NurApiAntennaIdToPhysicalAntenna(HANDLE, int, TCHAR*, int)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3723</i>
     */
    public static int NurApiAntennaIdToPhysicalAntenna(Pointer<?> hApi, int antennaId, Pointer<Byte> name, int maxNameLen) {
        return NurApiAntennaIdToPhysicalAntenna(Pointer.getPeer(hApi), antennaId, Pointer.getPeer(name), maxNameLen);
    }

    protected native static int NurApiAntennaIdToPhysicalAntenna(@Ptr long hApi, int antennaId, @Ptr long name, int maxNameLen);

    /**
     * @param hApi      Handle to valid NurApi object instance
     *                  <br>
     * @param name      The name of the antenna (physical) to look up.
     *                  <br>
     * @param antennaId Logical antenna number will be stored here.
     *                  <br>
     *                  <br>
     * @fn int NurApiPhysicalAntennaToAntennaId(HANDLE hApi, const TCHAR *name, int *antennaId)
     * <br>
     * <br>
     * This function maps given physical antenna name to an logical antenna identifier.
     * <br>
     *
     * <br>
     * @return Zero when successful. A non-zero error code otherwise.
     * <br>
     * <br>
     * @remark When the function return NUR_ERROR_GENERAL it means that the antenna mapping is present, but name was not found.<br>
     * Original signature : <code>int NurApiPhysicalAntennaToAntennaId(HANDLE, const TCHAR*, int*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3738</i>
     */
    public static int NurApiPhysicalAntennaToAntennaId(Pointer<?> hApi, Pointer<Byte> name, Pointer<Integer> antennaId) {
        return NurApiPhysicalAntennaToAntennaId(Pointer.getPeer(hApi), Pointer.getPeer(name), Pointer.getPeer(antennaId));
    }

    protected native static int NurApiPhysicalAntennaToAntennaId(@Ptr long hApi, @Ptr long name, @Ptr long antennaId);

    /**
     * @param hApi           Handle to valid NurApi object instance
     *                       <br>
     * @param commaSeparated Comma-separated physical antenna specifier.
     *                       <br>
     * @param antMask        Pointer to the antennaMask
     *                       <br>
     *                       <br>
     * @fn int NurApiGetPhysicalAntennaMask(HANDLE hApi, const TCHAR *commaSeparated, DWORD *antMask)
     * <br>
     * <br>
     * This function generates the antennaMask separated by a comma in the parameter commaSeparated and returns NUR_NO_ERROR when generating the mask succeeds
     * <br>
     *
     * <br>
     * @return Zero when successfully retrieves the antennaMask for the antennas listed in commaSeparated
     * <br>
     * <br>
     * @remark The function return NUR_NO_ERROR if all the queried antennas are enabled.
     * <br>
     * @remark If the connection is OK, the antenna mapping is present and atleast one valid antenna is listed in the commaSeparated parameter
     * <br>
     * <br>
     * @sa NUR_NO_ERROR, NUR_ERROR_GENERAL, NUR_ERROR_NOT_READY, NUR_ERROR_TR_NOT_CONNECTED, NUR_ERROR_INVALID_HANDLE<br>
     * Original signature : <code>int NurApiGetPhysicalAntennaMask(HANDLE, const TCHAR*, DWORD*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3756</i>
     */
    public static int NurApiGetPhysicalAntennaMask(Pointer<?> hApi, Pointer<Byte> commaSeparated, Pointer<Integer> antMask) {
        return NurApiGetPhysicalAntennaMask(Pointer.getPeer(hApi), Pointer.getPeer(commaSeparated), Pointer.getPeer(antMask));
    }

    protected native static int NurApiGetPhysicalAntennaMask(@Ptr long hApi, @Ptr long commaSeparated, @Ptr long antMask);

    /**
     * @param hApi           Handle to valid NurApi object instance
     *                       <br>
     * @param commaSeparated Comma-separated physical antenna specifier.
     *                       <br>
     *                       <br>
     * @fn int NurApiIsPhysicalAntennaEnabled(HANDLE hApi, const TCHAR *commaSeparated)
     * <br>
     * <br>
     * This function return NUR_NO_ERROR if all physical antennas specified in comma separated string are enabled, otherwise error is returned.
     * <br>
     *
     * <br>
     * @return Zero when successful (and all are enabled). A non-zero error code otherwise.
     * <br>
     * <br>
     * @remark The function return NUR_NO_ERROR if all the queried antennas are enabled.
     * <br>
     * @remark If the connection is OK, the antenna mapping is present and one or more of the antennass are not enabled then NUR_ERROR_GENERAL is returned.
     * <br>
     * <br>
     * @sa NUR_SUCCESS, NUR_NO_ERROR, NUR_ERROR_GENERAL<br>
     * Original signature : <code>int NurApiIsPhysicalAntennaEnabled(HANDLE, const TCHAR*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3773</i>
     */
    public static int NurApiIsPhysicalAntennaEnabled(Pointer<?> hApi, Pointer<Byte> commaSeparated) {
        return NurApiIsPhysicalAntennaEnabled(Pointer.getPeer(hApi), Pointer.getPeer(commaSeparated));
    }

    protected native static int NurApiIsPhysicalAntennaEnabled(@Ptr long hApi, @Ptr long commaSeparated);

    /**
     * @param hApi          Handle to valid NurApi object instance
     *                      <br>
     * @param page          Into what page the data is written to.
     *                      <br>
     * @param offset        The data offset within the page, byte alignment.
     *                      <br>
     * @param scratchData   Pointer to the byte data to be written.
     *                      <br>
     * @param szScratchData Size of the data to be written.
     *                      <br>
     *                      <br>
     * @fn int NurApiWriteScratchArea(HANDLE hApi, int page, int offset, BYTE *scratchData, int szScratchData)
     * <br>
     * <br>
     * Write scratch area data into the module. In the module's non-volatile memory there is 2 x 256 bytes reserved for the user defined data.
     * <br>
     * The user scratch data are behaves like EEPROM i.e. it can be written and read per byte basis.
     * <br>
     *
     * <br>
     * @return Zero when successful. A non-zero error code otherwise.
     * <br>
     * <br>
     * @remark The data size needs to fit into the 256-byte are of the given page.
     * <br>
     * <br>
     * @sa NUR_SUCCESS, NUR_ERROR_INVALID_PARAMETER, MIN_SCRATCHPAGE, MAX_SCRATCHPAGE, MIN_SCRATCHBYTES, MAX_SCRATCHBYTES<br>
     * Original signature : <code>int NurApiWriteScratchArea(HANDLE, int, int, BYTE*, int)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3793</i>
     */
    public static int NurApiWriteScratchArea(Pointer<?> hApi, int page, int offset, Pointer<Byte> scratchData, int szScratchData) {
        return NurApiWriteScratchArea(Pointer.getPeer(hApi), page, offset, Pointer.getPeer(scratchData), szScratchData);
    }

    protected native static int NurApiWriteScratchArea(@Ptr long hApi, int page, int offset, @Ptr long scratchData, int szScratchData);

    /**
     * @param hApi          Handle to valid NurApi object instance
     *                      <br>
     * @param page          The page to read from.
     *                      <br>
     * @param offset        The data offset within the page, byte alignment.
     *                      <br>
     * @param scratchData   Pointer to where the read data is stored into.
     *                      <br>
     * @param szScratchData Number of bytes to read.
     *                      <br>
     *                      <br>
     * @fn int NurApiReadScratchArea(HANDLE hApi, int page, int offset, BYTE *scratchData, int szScratchData)
     * <br>
     * <br>
     * Read scratch area data from the module. In the module's non-volatile memory there is 2 x 256 bytes reserved for the user defined data.
     * <br>
     * The user scratch data are behaves like EEPROM i.e. it can be written and read per byte basis.
     * <br>
     *
     * <br>
     * @return Zero when successful. A non-zero error code otherwise.
     * <br>
     * <br>
     * @remark The data size needs to fit into the 256-byte are of the given page.
     * <br>
     * <br>
     * @sa NUR_SUCCESS, NUR_ERROR_INVALID_PARAMETER, MIN_SCRATCHPAGE, MAX_SCRATCHPAGE, MIN_SCRATCHBYTES, MAX_SCRATCHBYTES<br>
     * Original signature : <code>int NurApiReadScratchArea(HANDLE, int, int, BYTE*, int)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3813</i>
     */
    public static int NurApiReadScratchArea(Pointer<?> hApi, int page, int offset, Pointer<Byte> scratchData, int szScratchData) {
        return NurApiReadScratchArea(Pointer.getPeer(hApi), page, offset, Pointer.getPeer(scratchData), szScratchData);
    }

    protected native static int NurApiReadScratchArea(@Ptr long hApi, int page, int offset, @Ptr long scratchData, int szScratchData);

    /**
     * @param hApi   Valid NUR API handle.
     *               <br>
     * @param enable TRUE = WLan module up running, FALSE = Wlan module not in use.
     *               <br>
     *               <br>
     * @fn int NURAPICONV NurApiWLanEnable(HANDLE hApi, BOOL enable)
     * <br>
     * <br>
     * Enable/Disable WLan module.
     * <br>
     *
     * <br>
     * @return Zero when successful. A non-zero error code otherwise.
     * <br>
     * <br>
     * @remark When WLan disabled, module is in hibernate state.<br>
     * Original signature : <code>int NurApiWLanEnable(HANDLE, BOOL)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3827</i>
     */
    public static int NurApiWLanEnable(Pointer<?> hApi, int enable) {
        return NurApiWLanEnable(Pointer.getPeer(hApi), enable);
    }

    protected native static int NurApiWLanEnable(@Ptr long hApi, int enable);

    /**
     * @param hApi   Valid NUR API handle.
     *               <br>
     * @param enable TRUE = enable network scan, FALSE to disable.
     *               <br>
     *               <br>
     * @fn int NURAPICONV NurApiWLanScanEnable(HANDLE hApi, BOOL enable)
     * <br>
     * <br>
     * Enable/Disable Network scan functionality. When enabled, network scan will be performed between 30 sec.
     * <br>
     * Use NurApiWLanGetNetworkList for getting list of network nodes found. (SSID, Security type, RSSI)
     * <br>
     *
     * <br>
     * @return Zero when successful. A non-zero error code otherwise.
     * <br>
     * <br>
     * @remark By default, scan is disabled.<br>
     * Original signature : <code>int NurApiWLanScanEnable(HANDLE, BOOL)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3842</i>
     */
    public static int NurApiWLanScanEnable(Pointer<?> hApi, int enable) {
        return NurApiWLanScanEnable(Pointer.getPeer(hApi), enable);
    }

    protected native static int NurApiWLanScanEnable(@Ptr long hApi, int enable);

    /**
     * @fn int NurApiWLanGetStatus(HANDLE hApi, struct NUR_WLANSTATUS *status, DWORD statusSize)
     * <br>
     * <br>
     * Get current status from WLAN module.
     * <br>
     * <br>
     * @sa NUR_WLANSTATUS
     * <br>
     *
     * <br>
     * @param    hApi        Handle to valid NurApi object instance.
     * <br>
     * @param    status        Pointer to a buffer that receives WLan module current status.
     * <br>
     * @param    statusSize    Size of the <i>status</i> structure in bytes. Usually: sizeof(struct NUR_WLANSTATUS).
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiWLanGetStatus(HANDLE, NUR_WLANSTATUS*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3857</i>
     */
    public static int NurApiWLanGetStatus(Pointer<?> hApi, Pointer<NUR_WLANSTATUS> status, int statusSize) {
        return NurApiWLanGetStatus(Pointer.getPeer(hApi), Pointer.getPeer(status), statusSize);
    }

    protected native static int NurApiWLanGetStatus(@Ptr long hApi, @Ptr long status, int statusSize);

    /**
     * @fn int NURAPICONV NurApiWLanGetProfile(HANDLE hApi, struct NUR_WLANPROFILE *profile, BYTE profileIndex)
     * <br>
     * <br>
     * Get connection profile from WLAN module.
     * <br>
     * If profile not found based on profileIndex, function return NUR_WLANPROFILE struct where index member = 0.
     * <br>
     * <br>
     * @sa NUR_WLANPROFILE, NurApiWLanDelProfile, NurApiWLanAddProfile
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    profile            Pointer to a buffer that receives WLan module current status.
     * <br>
     * @param    profileIndex    Index of profile to get (1-7). If profile not found, NUR_WLANPROFILE-->index = 0.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiWLanGetProfile(HANDLE, NUR_WLANPROFILE*, BYTE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3873</i>
     */
    public static int NurApiWLanGetProfile(Pointer<?> hApi, Pointer<NUR_WLANPROFILE> profile, byte profileIndex) {
        return NurApiWLanGetProfile(Pointer.getPeer(hApi), Pointer.getPeer(profile), profileIndex);
    }

    protected native static int NurApiWLanGetProfile(@Ptr long hApi, @Ptr long profile, byte profileIndex);

    /**
     * @fn int NURAPICONV NurApiWLanAddEnterpriseProfile(HANDLE hApi, TCHAR *ssid,TCHAR *seckey, TCHAR *user, TCHAR *anonuser, BYTE eapmethod, BYTE priority)
     * <br>
     * <br>
     * Add enterprise connection profile to WLAN module.
     * <br>
     * the device connects to a station from the profiles table. Only one enterprise profile is supported.
     * <br>
     * <br>
     * @sa NurApiWLanGetProfile, NurApiWLanDelProfile
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    ssid            Pointer to a string buffer containing SSID name.
     * <br>
     * @param    seckey            Pointer buffer containing security key string. (hexadecimal digits 0-9, a-f and A-F)
     * <br>
     * @param    user            The enterprise user name
     * <br>
     * @param    anonuser        The anonymous user name (optional) for two phase enterprise connections.
     * <br>
     * @param    eapmethod        EAP Method
     * <br>
     * @param    priority        0-7 (0=lowest) If several profiles configured the device chose the highest priority profile, within each priority group, device will chose profile based on security policy, signal strength, etc parameters
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiWLanAddEnterpriseProfile(HANDLE, TCHAR*, TCHAR*, TCHAR*, TCHAR*, BYTE, BYTE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3893</i>
     */
    public static int NurApiWLanAddEnterpriseProfile(Pointer<?> hApi, Pointer<Byte> ssid, Pointer<Byte> seckey, Pointer<Byte> user, Pointer<Byte> anonuser, byte eapmethod, byte priority) {
        return NurApiWLanAddEnterpriseProfile(Pointer.getPeer(hApi), Pointer.getPeer(ssid), Pointer.getPeer(seckey), Pointer.getPeer(user), Pointer.getPeer(anonuser), eapmethod, priority);
    }

    protected native static int NurApiWLanAddEnterpriseProfile(@Ptr long hApi, @Ptr long ssid, @Ptr long seckey, @Ptr long user, @Ptr long anonuser, byte eapmethod, byte priority);

    /**
     * @fn int NURAPICONV NurApiWLanAddProfile(HANDLE hApi, TCHAR *ssid, BYTE secType, TCHAR *seckey, BYTE priority)
     * <br>
     * <br>
     * Add connection profile to WLAN module.
     * <br>
     * the device connects to a station from the profiles table. Up to 7 profiles are supported.
     * <br>
     * <br>
     * @sa NurApiWLanGetProfile, NurApiWLanDelProfile
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    ssid            Pointer to a string buffer containing SSID name.
     * <br>
     * @param    secType            OPEN=0, WEP=1, WPA=2, WPA2=3, WPA_ENT=6
     * <br>
     * @param    seckey            Pointer buffer containing security key string. (hexadecimal digits 0-9, a-f and A-F)
     * <br>
     * @param    priority        0-7 (0=lowest) If several profiles configured the device chose the highest priority profile, within each priority group, device will chose profile based on security policy, signal strength, etc parameters
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiWLanAddProfile(HANDLE, TCHAR*, BYTE, TCHAR*, BYTE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3911</i>
     */
    public static int NurApiWLanAddProfile(Pointer<?> hApi, Pointer<Byte> ssid, byte secType, Pointer<Byte> seckey, byte priority) {
        return NurApiWLanAddProfile(Pointer.getPeer(hApi), Pointer.getPeer(ssid), secType, Pointer.getPeer(seckey), priority);
    }

    protected native static int NurApiWLanAddProfile(@Ptr long hApi, @Ptr long ssid, byte secType, @Ptr long seckey, byte priority);

    /**
     * @fn int NURAPICONV NurApiWLanDelProfile(HANDLE hApi, BYTE index)
     * <br>
     * <br>
     * Deleting a certain stored profile, or for deleting all profiles at once.
     * <br>
     * <br>
     * @sa NurApiWLanGetProfile, NurApiWLanAddProfile.
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    index            Index of profile to delete (1-7) 0 = Delete all profiles.
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiWLanDelProfile(HANDLE, BYTE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3924</i>
     */
    public static int NurApiWLanDelProfile(Pointer<?> hApi, byte index) {
        return NurApiWLanDelProfile(Pointer.getPeer(hApi), index);
    }

    protected native static int NurApiWLanDelProfile(@Ptr long hApi, byte index);

    /**
     * @fn int NURAPICONV NurApiWLanFileWrite(HANDLE hApi, TCHAR *name, DWORD length, BYTE *data)
     * <br>
     * <br>
     * Write file to file system of WLAN module.
     * <br>
     * <br>
     * @sa NurApiWLanFileDelete.
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    name            Name/path of file where to store in the module.
     * <br>
     * @param    length            Length of file in bytes.
     * <br>
     * @param    data            Pointer to file data buffer.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiWLanFileWrite(HANDLE, TCHAR*, DWORD, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3940</i>
     */
    public static int NurApiWLanFileWrite(Pointer<?> hApi, Pointer<Byte> name, int length, Pointer<Byte> data) {
        return NurApiWLanFileWrite(Pointer.getPeer(hApi), Pointer.getPeer(name), length, Pointer.getPeer(data));
    }

    protected native static int NurApiWLanFileWrite(@Ptr long hApi, @Ptr long name, int length, @Ptr long data);

    /**
     * @fn int NURAPICONV NurApiWLanFileDelete(HANDLE hApi, TCHAR *name)
     * <br>
     * <br>
     * Delete file from file system of WLAN module
     * <br>
     * <br>
     * @sa NurApiWLanFileWrite.
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    name            name/path of file to delete.
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiWLanFileDelete(HANDLE, TCHAR*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3953</i>
     */
    public static int NurApiWLanFileDelete(Pointer<?> hApi, Pointer<Byte> name) {
        return NurApiWLanFileDelete(Pointer.getPeer(hApi), Pointer.getPeer(name));
    }

    protected native static int NurApiWLanFileDelete(@Ptr long hApi, @Ptr long name);

    /**
     * @fn int NURAPICONV NurApiGen2v2Untraceable(HANDLE hApi, DWORD passwd, struct NUR_UNTRACEABLE_PARAM *pUtrace, DWORD szParam)
     * <br>
     * <br>
     * Performs the Gen2 version 2 "Untraceable" command without explicitly selecting a tag.
     * <br>
     * <br>
     * @sa NurApiGen2v2UntraceableByEPC, NurApiGen2v2Untraceable32, NUR_UNTRACEABLE_PARAM
     * <br>
     * @sa NUR_UTRACE_RANGE_NORMAL, NUR_UTRACE_RANGE_REDUCE
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    passwd            Untraceable always executes in secured state; must be valid.
     * <br>
     * @param    pUtrace            Pointer to a valid untraceable command's parameter structure.
     * <br>
     * @param    szParam            Size of the parameter structure.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGen2v2Untraceable(HANDLE, DWORD, NUR_UNTRACEABLE_PARAM*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3970</i>
     */
    public static int NurApiGen2v2Untraceable(Pointer<?> hApi, int passwd, Pointer<NUR_UNTRACEABLE_PARAM> pUtrace, int szParam) {
        return NurApiGen2v2Untraceable(Pointer.getPeer(hApi), passwd, Pointer.getPeer(pUtrace), szParam);
    }

    protected native static int NurApiGen2v2Untraceable(@Ptr long hApi, int passwd, @Ptr long pUtrace, int szParam);

    /**
     * @fn int NURAPICONV NurApiGen2v2UntraceableByEPC(HANDLE hApi, DWORD passwd, BYTE *epcBuffer, DWORD epcBufferLen, struct NUR_UNTRACEABLE_PARAM *pUtrace, DWORD szParam)
     * <br>
     * <br>
     * Performs the Gen2 version 2 "Untraceable" command using the tag's EPC as selection parameter.
     * <br>
     * <br>
     * @sa NurApiGen2v2Untraceable, NurApiGen2v2Untraceable32, NUR_UNTRACEABLE_PARAM
     * <br>
     * @sa NUR_UTRACE_RANGE_NORMAL, NUR_UTRACE_RANGE_REDUCE
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    passwd            Untraceable always executes in secured state; must be valid.
     * <br>
     * @param    epcBuffer        Pointer to the tag's expected EPC constents starting from bit addresss 32 (word addres 2) in the EPC bank.
     * <br>
     * @param    epcBufferLen    Length, in bytes, of the EPC buffer.
     * <br>
     * @param    pUtrace            Pointer to a valid untraceable command's parameter structure.
     * <br>
     * @param    szParam            Size of the parameter structure.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGen2v2UntraceableByEPC(HANDLE, DWORD, BYTE*, DWORD, NUR_UNTRACEABLE_PARAM*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:3989</i>
     */
    public static int NurApiGen2v2UntraceableByEPC(Pointer<?> hApi, int passwd, Pointer<Byte> epcBuffer, int epcBufferLen, Pointer<NUR_UNTRACEABLE_PARAM> pUtrace, int szParam) {
        return NurApiGen2v2UntraceableByEPC(Pointer.getPeer(hApi), passwd, Pointer.getPeer(epcBuffer), epcBufferLen, Pointer.getPeer(pUtrace), szParam);
    }

    protected native static int NurApiGen2v2UntraceableByEPC(@Ptr long hApi, int passwd, @Ptr long epcBuffer, int epcBufferLen, @Ptr long pUtrace, int szParam);

    /**
     * @fn int NURAPICONV NurApiGen2v2Untraceable32(HANDLE hApi, DWORD passwd, BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask, struct NUR_UNTRACEABLE_PARAM *pUtrace, DWORD szParam)
     * <br>
     * <br>
     * Performs the Gen2 version 2 "Untraceable" command with explicit selection criteria.
     * <br>
     * <br>
     * @sa NurApiGen2v2Untraceable, NurApiGen2v2UntraceableByEPC, NUR_UNTRACEABLE_PARAM
     * <br>
     * @sa NUR_UTRACE_RANGE_NORMAL, NUR_UTRACE_RANGE_REDUCE
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    passwd            Untraceable always executes in secured state; must be valid.
     * <br>
     * @param    sBank            Bank where the selection is applied to (EPC, TID or user memory).
     * <br>
     * @param    sAddress        Selection mask's bit address.
     * <br>
     * @param    sMaskBitLength    Selection mask's length in bits.
     * <br>
     * @param    sMask            Pointer to the selection mask data.
     * <br>
     * @param    pUtrace            Pointer to a valid untraceable command's parameter structure.
     * <br>
     * @param    szParam            Size of the parameter structure.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGen2v2Untraceable32(HANDLE, DWORD, BYTE, DWORD, int, BYTE*, NUR_UNTRACEABLE_PARAM*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4010</i>
     */
    public static int NurApiGen2v2Untraceable32(Pointer<?> hApi, int passwd, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, Pointer<NUR_UNTRACEABLE_PARAM> pUtrace, int szParam) {
        return NurApiGen2v2Untraceable32(Pointer.getPeer(hApi), passwd, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), Pointer.getPeer(pUtrace), szParam);
    }

    protected native static int NurApiGen2v2Untraceable32(@Ptr long hApi, int passwd, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, @Ptr long pUtrace, int szParam);

    /**
     * @fn int NURAPICONV NurApiGen2v2Authenticate32(HANDLE hApi, BOOL secured, DWORD passwd, BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask, struct NUR_AUTHENTICATE_PARAM *pAuth, DWORD szParam, struct NUR_AUTHENTICATE_RESP *pResp)
     * <br>
     * <br>
     * Performs the Gen2 version 2 "Authenticate" command with specific selection parameters.
     * <br>
     * <br>
     * @sa NurApiGen2v2AuthenticateByEPC, NurApiGen2v2Authenticate
     * <br>
     * @sa NUR_AUTHENTICATE_PARAM, NUR_AUTHENTICATE_RESP
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    secured            If TRUE then the operation is done in secured state (NOT RECOMMENDED).
     * <br>
     * @param    passwd            Password to use in the secured state.
     * <br>
     * @param    sBank            Bank where the selection is applied to (EPC, TID or user memory).
     * <br>
     * @param    sAddress        Selection mask's bit address.
     * <br>
     * @param    sMaskBitLength    Selection mask's length in bits.
     * <br>
     * @param    sMask            Pointer to the selection mask data.
     * <br>
     * @param    pAuth            Authentication parameters.
     * <br>
     * @param    szParam            Size of the parameter structure.
     * <br>
     * @param    pResp            Response to the authentication (tag's reply if present).
     * <br>
     *
     * <br>
     * @return Zero when succeeded, on error non-zero error code is returned if the error is due to invalid parameters or communication failure.
     * <br>
     * @remarks The function may return zero also when the authentication itself failed; the there is additional information in the response structure.<br>
     * Original signature : <code>int NurApiGen2v2Authenticate32(HANDLE, BOOL, DWORD, BYTE, DWORD, int, BYTE*, NUR_AUTHENTICATE_PARAM*, DWORD, NUR_AUTHENTICATE_RESP*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4034</i>
     */
    public static int NurApiGen2v2Authenticate32(Pointer<?> hApi, int secured, int passwd, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, Pointer<NUR_AUTHENTICATE_PARAM> pAuth, int szParam, Pointer<NUR_AUTHENTICATE_RESP> pResp) {
        return NurApiGen2v2Authenticate32(Pointer.getPeer(hApi), secured, passwd, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), Pointer.getPeer(pAuth), szParam, Pointer.getPeer(pResp));
    }

    protected native static int NurApiGen2v2Authenticate32(@Ptr long hApi, int secured, int passwd, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, @Ptr long pAuth, int szParam, @Ptr long pResp);

    /**
     * @fn int NURAPICONV NurApiGen2v2AuthenticateByEPC(HANDLE hApi, BOOL secured, DWORD passwd, BYTE *epcBuffer, DWORD epcBufferLen, struct NUR_AUTHENTICATE_PARAM *pAuth, DWORD szParam, struct NUR_AUTHENTICATE_RESP *pResp)
     * <br>
     * <br>
     * Performs the Gen2 version 2 "Authenticate" command using the tag's EPC as selection parameter.
     * <br>
     * <br>
     * @sa NurApiGen2v2Authenticate32, NurApiGen2v2Authenticate
     * <br>
     * @sa NUR_AUTHENTICATE_PARAM, NUR_AUTHENTICATE_RESP
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    secured            If TRUE then the operation is done in secured state (NOT RECOMMENDED).
     * <br>
     * @param    passwd            Password to use in the secured state.
     * <br>
     * @param    epcBuffer        Pointer to the tag's expected EPC constents starting from bit addresss 32 (word addres 2) in the EPC bank.
     * <br>
     * @param    epcBufferLen    Length, in bytes, of the EPC buffer.
     * <br>
     * @param    pAuth            Authentication parameters.
     * <br>
     * @param    szParam            Size of the parameter structure.
     * <br>
     * @param    pResp            Response to the authentication (tag's reply if present).
     * <br>
     *
     * <br>
     * @return Zero when succeeded, on error non-zero error code is returned if the error is due to invalid parameters or communication failure.
     * <br>
     * @remarks The function may return zero also when the authentication itself failed; the there is additional information in the response structure.<br>
     * Original signature : <code>int NurApiGen2v2AuthenticateByEPC(HANDLE, BOOL, DWORD, BYTE*, DWORD, NUR_AUTHENTICATE_PARAM*, DWORD, NUR_AUTHENTICATE_RESP*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4056</i>
     */
    public static int NurApiGen2v2AuthenticateByEPC(Pointer<?> hApi, int secured, int passwd, Pointer<Byte> epcBuffer, int epcBufferLen, Pointer<NUR_AUTHENTICATE_PARAM> pAuth, int szParam, Pointer<NUR_AUTHENTICATE_RESP> pResp) {
        return NurApiGen2v2AuthenticateByEPC(Pointer.getPeer(hApi), secured, passwd, Pointer.getPeer(epcBuffer), epcBufferLen, Pointer.getPeer(pAuth), szParam, Pointer.getPeer(pResp));
    }

    protected native static int NurApiGen2v2AuthenticateByEPC(@Ptr long hApi, int secured, int passwd, @Ptr long epcBuffer, int epcBufferLen, @Ptr long pAuth, int szParam, @Ptr long pResp);

    /**
     * @fn int NURAPICONV NurApiGen2v2Authenticate(HANDLE hApi, BOOL secured, DWORD passwd, struct NUR_AUTHENTICATE_PARAM *pAuth, DWORD szParam, struct NUR_AUTHENTICATE_RESP *pResp)
     * <br>
     * <br>
     * Performs the Gen2 version 2 "Authenticate" command without explicitly selecting a tag.
     * <br>
     * <br>
     * @sa NurApiGen2v2AuthenticateByEPC, NurApiGen2v2Authenticate32
     * <br>
     * @sa NUR_AUTHENTICATE_PARAM, NUR_AUTHENTICATE_RESP
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    secured            If TRUE then the operation is done in secured state (NOT RECOMMENDED).
     * <br>
     * @param    passwd            Password to use in the secured state.
     * <br>
     * @param    pAuth            Authentication parameters.
     * <br>
     * @param    szParam            Size of the parameter structure.
     * <br>
     * @param    pResp            Response to the authentication (tag's reply if present).
     * <br>
     *
     * <br>
     * @return Zero when succeeded, on error non-zero error code is returned if the error is due to invalid parameters or communication failure.
     * <br>
     * @remarks The function may return zero also when the authentication itself failed; the there is additional information in the response structure.<br>
     * Original signature : <code>int NurApiGen2v2Authenticate(HANDLE, BOOL, DWORD, NUR_AUTHENTICATE_PARAM*, DWORD, NUR_AUTHENTICATE_RESP*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4076</i>
     */
    public static int NurApiGen2v2Authenticate(Pointer<?> hApi, int secured, int passwd, Pointer<NUR_AUTHENTICATE_PARAM> pAuth, int szParam, Pointer<NUR_AUTHENTICATE_RESP> pResp) {
        return NurApiGen2v2Authenticate(Pointer.getPeer(hApi), secured, passwd, Pointer.getPeer(pAuth), szParam, Pointer.getPeer(pResp));
    }

    protected native static int NurApiGen2v2Authenticate(@Ptr long hApi, int secured, int passwd, @Ptr long pAuth, int szParam, @Ptr long pResp);

    /**
     * @fn int NURAPICONV NurApiGen2v2ReadBuffer(HANDLE hApi, BOOL secured, DWORD passwd, WORD bitAddress, WORD bitCount, BYTE *buffer, int *actualBits)
     * <br>
     * <br>
     * Performs the Gen2 version 2 "ReadBuffer" command without tag singulation.
     * <br>
     * <br>
     * @sa NurApiGen2v2ReadBuffer32, NurApiGen2v2ReadBufferByEPC, MAX_V2_RDBUFBITS, VER2_RDBUF_MAXADDR
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    secured            If TRUE then the operation is done in secured state.
     * <br>
     * @param    passwd            Password to use in the secured state.
     * <br>
     * @param    bitAddress        Bit address to start the read from. Range is 0...0xFFF.
     * <br>
     * @param    bitCount        Number of bits to read from the tag's internal buffer. Range is 1...1000.
     * <br>
     * @param    buffer            The tag's reply is stored here.
     * <br>
     * @param    actualBits        Pointer to WORD variable where the number of bits actually received from the tag is stored into.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, on error non-zero error code is returned if the error is due to invalid parameters or communication failure.<br>
     * Original signature : <code>int NurApiGen2v2ReadBuffer(HANDLE, BOOL, DWORD, WORD, WORD, BYTE*, int*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4095</i>
     */
    public static int NurApiGen2v2ReadBuffer(Pointer<?> hApi, int secured, int passwd, short bitAddress, short bitCount, Pointer<Byte> buffer, Pointer<Integer> actualBits) {
        return NurApiGen2v2ReadBuffer(Pointer.getPeer(hApi), secured, passwd, bitAddress, bitCount, Pointer.getPeer(buffer), Pointer.getPeer(actualBits));
    }

    protected native static int NurApiGen2v2ReadBuffer(@Ptr long hApi, int secured, int passwd, short bitAddress, short bitCount, @Ptr long buffer, @Ptr long actualBits);

    /**
     * @fn int NURAPICONV NurApiGen2v2ReadBuffer32(HANDLE hApi, BOOL secured, DWORD passwd, BYTE sBank, DWORD sAddress, DWORD sMaskBitLength, BYTE *sMask, WORD bitAddress, WORD bitCount, BYTE *buffer, int *actualBits)
     * <br>
     * <br>
     * Performs the Gen2 version 2 "ReadBuffer" command  with specific selection parameters.
     * <br>
     * <br>
     * @sa NurApiGen2v2ReadBuffer, NurApiGen2v2ReadBufferByEPC, MAX_V2_RDBUFBITS, VER2_RDBUF_MAXADDR
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    secured            If TRUE then the operation is done in secured state.
     * <br>
     * @param    passwd            Password to use in the secured state.
     * <br>
     * @param    sBank            Bank where the selection is applied to (EPC, TID or user memory).
     * <br>
     * @param    sAddress        Selection mask's bit address.
     * <br>
     * @param    sMaskBitLength    Selection mask's length in bits.
     * <br>
     * @param    sMask            Pointer to the selection mask data.
     * <br>
     * @param    bitAddress        Bit address to start the read from. Range is 0...0xFFF.
     * <br>
     * @param    bitCount        Number of bits to read from the tag's internal buffer. Range is 1...1000.
     * <br>
     * @param    buffer            The tag's reply is stored here.
     * <br>
     * @param    actualBits        Pointer to WORD variable where the number of bits actually received from the tag is stored into.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, on error non-zero error code is returned if the error is due to invalid parameters or communication failure.<br>
     * Original signature : <code>int NurApiGen2v2ReadBuffer32(HANDLE, BOOL, DWORD, BYTE, DWORD, DWORD, BYTE*, WORD, WORD, BYTE*, int*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4118</i>
     */
    public static int NurApiGen2v2ReadBuffer32(Pointer<?> hApi, int secured, int passwd, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, short bitAddress, short bitCount, Pointer<Byte> buffer, Pointer<Integer> actualBits) {
        return NurApiGen2v2ReadBuffer32(Pointer.getPeer(hApi), secured, passwd, sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), bitAddress, bitCount, Pointer.getPeer(buffer), Pointer.getPeer(actualBits));
    }

    protected native static int NurApiGen2v2ReadBuffer32(@Ptr long hApi, int secured, int passwd, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, short bitAddress, short bitCount, @Ptr long buffer, @Ptr long actualBits);

    /**
     * @fn int NURAPICONV NurApiGen2v2ReadBufferByEPC(HANDLE hApi, BOOL secured, DWORD passwd, BYTE *epcBuffer, DWORD epcBufferLen, WORD bitAddress, WORD bitCount, BYTE *buffer, int *actualBits)
     * <br>
     * <br>
     * Performs the Gen2 version 2 "ReadBuffer" command by singulating the tag with its EPC contents.
     * <br>
     * <br>
     * @sa NurApiGen2v2ReadBuffer, NurApiGen2v2ReadBuffer32, MAX_V2_RDBUFBITS, VER2_RDBUF_MAXADDR
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    secured            If TRUE then the operation is done in secured state.
     * <br>
     * @param    passwd            Password to use in the secured state.
     * <br>
     * @param    epcBuffer        Pointer to the tag's expected EPC constents starting from bit addresss 32 (word addres 2) in the EPC bank.
     * <br>
     * @param    epcBufferLen    Length, in bytes, of the EPC buffer.
     * <br>
     * @param    bitAddress        Bit address to start the read from. Range is 0...0xFFF.
     * <br>
     * @param    bitCount        Number of bits to read from the tag's internal buffer. Range is 1...1000.
     * <br>
     * @param    buffer            The tag's reply is stored here.
     * <br>
     * @param    actualBits        Pointer to WORD variable where the number of bits actually received from the tag is stored into.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, on error non-zero error code is returned if the error is due to invalid parameters or communication failure.<br>
     * Original signature : <code>int NurApiGen2v2ReadBufferByEPC(HANDLE, BOOL, DWORD, BYTE*, DWORD, WORD, WORD, BYTE*, int*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4139</i>
     */
    public static int NurApiGen2v2ReadBufferByEPC(Pointer<?> hApi, int secured, int passwd, Pointer<Byte> epcBuffer, int epcBufferLen, short bitAddress, short bitCount, Pointer<Byte> buffer, Pointer<Integer> actualBits) {
        return NurApiGen2v2ReadBufferByEPC(Pointer.getPeer(hApi), secured, passwd, Pointer.getPeer(epcBuffer), epcBufferLen, bitAddress, bitCount, Pointer.getPeer(buffer), Pointer.getPeer(actualBits));
    }

    protected native static int NurApiGen2v2ReadBufferByEPC(@Ptr long hApi, int secured, int passwd, @Ptr long epcBuffer, int epcBufferLen, short bitAddress, short bitCount, @Ptr long buffer, @Ptr long actualBits);

    /**
     * @fn int NURAPICONV NurApiAES128_ECBEncrypt(BYTE* input, const BYTE* key, BYTE *output)
     * <br>
     * <br>
     * Performs one 16-byte (128-bit) block AES ECB encryption.
     * <br>
     * <br>
     * @sa NurApiAES128_ECBDecrypt, NurApiAES128_CBCEncrypt, NurApiAES128_CBCDecrypt
     * <br>
     *
     * <br>
     * @param    input        Input data. Must not be NULL and length is 16 bytes (128 bits).
     * <br>
     * @param    output        Output is stored here. Must not be NULL and minimum required allocation is 16 bytes (128 bits).
     * <br>
     * @param    key            Key to use. Must be 16 bytes (128 bits) long.
     * <br>
     *
     * <br>
     * @return Zero when succeeded. Error can only be parameter error.<br>
     * Original signature : <code>int NurApiAES128_ECBEncrypt(BYTE*, const BYTE*, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4154</i>
     */
    public static int NurApiAES128_ECBEncrypt(Pointer<Byte> input, Pointer<Byte> key, Pointer<Byte> output) {
        return NurApiAES128_ECBEncrypt(Pointer.getPeer(input), Pointer.getPeer(key), Pointer.getPeer(output));
    }

    protected native static int NurApiAES128_ECBEncrypt(@Ptr long input, @Ptr long key, @Ptr long output);

    /**
     * @fn int NURAPICONV NurApiAES128_ECBDecrypt(BYTE *input, const BYTE *key, BYTE *output)
     * <br>
     * <br>
     * Performs one 16-byte (128-bit) block AES ECB decryption.
     * <br>
     * <br>
     * @sa NurApiAES128_ECBEncrypt, NurApiAES128_CBCEncrypt, NurApiAES128_CBCDecrypt
     * <br>
     *
     * <br>
     * @param    input        Input data. Must not be NULL and length is 16 bytes (128 bits).
     * <br>
     * @param    output        Output is stored here. Must not be NULL and minimum required allocation is 16 bytes (128 bits).
     * <br>
     * @param    key            Key to use. Must not be NULL and length is 16 bytes (128 bits).
     * <br>
     *
     * <br>
     * @return Zero when succeeded. Error can only be parameter error.<br>
     * Original signature : <code>int NurApiAES128_ECBDecrypt(BYTE*, const BYTE*, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4169</i>
     */
    public static int NurApiAES128_ECBDecrypt(Pointer<Byte> input, Pointer<Byte> key, Pointer<Byte> output) {
        return NurApiAES128_ECBDecrypt(Pointer.getPeer(input), Pointer.getPeer(key), Pointer.getPeer(output));
    }

    protected native static int NurApiAES128_ECBDecrypt(@Ptr long input, @Ptr long key, @Ptr long output);

    /**
     * @fn int NURAPICONV NurApiAES128_CBCEncrypt(BYTE *input, DWORD length, const BYTE *key, const BYTE *iv, BYTE *output)
     * <br>
     * <br>
     * Performs AES CBC encryption. There may be several 16-byte (128-bit) blocks as an input.
     * <br>
     * <br>
     * @sa NurApiAES128_ECBEncrypt, NurApiAES128_ECBDecrypt, NurApiAES128_CBCDecrypt
     * <br>
     *
     * <br>
     * @param    input    Input data. Must not be NULL, minimum length is 16 bytes (128 bits) and total length is aligned by 16.
     * <br>
     * @param    length    Minimum value is 16 and with larger values the alignment must be 16.
     * <br>
     * @param    key        Key to use. Must not be NULL and length is 16 bytes (128 bits).
     * <br>
     * @param    iv        The Initialization Vector (IV) to use. Must not be NULL and length is 16 bytes (128 bits).
     * <br>
     * @param    output    Output is stored here. Must not be NULL and minimum required allocation is 16 bytes (128 bits).
     * <br>
     *
     * <br>
     * @return Zero when succeeded. Error can only be parameter error.<br>
     * Original signature : <code>int NurApiAES128_CBCEncrypt(BYTE*, DWORD, const BYTE*, const BYTE*, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4186</i>
     */
    public static int NurApiAES128_CBCEncrypt(Pointer<Byte> input, int length, Pointer<Byte> key, Pointer<Byte> iv, Pointer<Byte> output) {
        return NurApiAES128_CBCEncrypt(Pointer.getPeer(input), length, Pointer.getPeer(key), Pointer.getPeer(iv), Pointer.getPeer(output));
    }

    protected native static int NurApiAES128_CBCEncrypt(@Ptr long input, int length, @Ptr long key, @Ptr long iv, @Ptr long output);

    /**
     * @fn int NURAPICONV NurApiAES128_CBCDecrypt(BYTE *input, DWORD length, const BYTE *key, const BYTE *iv, BYTE *output)
     * <br>
     * <br>
     * Performs AES CBC decryption. There may be several 16-byte (128-bit) blocks as an input.
     * <br>
     * <br>
     * @sa NurApiAES128_ECBEncrypt, NurApiAES128_ECBDecrypt, NurApiAES128_CBCEncrypt
     * <br>
     *
     * <br>
     * @param    input    Input data. Must not be NULL, minimum length is 16 bytes (128 bits) and total length is aligned by 16.
     * <br>
     * @param    length    Minimum value is 16 and with larger values the alignment must be 16.
     * <br>
     * @param    key        Key to use. Must not be NULL and length is 16 bytes (128 bits).
     * <br>
     * @param    iv        The Initialization Vector (IV) to use. Must not be NULL and length is 16 bytes (128 bits).
     * <br>
     * @param    output    Output is stored here. Must not be NULL and minimum required allocation is 16 bytes (128 bits).
     * <br>
     *
     * <br>
     * @return Zero when succeeded. Error can only be parameter error.<br>
     * Original signature : <code>int NurApiAES128_CBCDecrypt(BYTE*, DWORD, const BYTE*, const BYTE*, BYTE*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4203</i>
     */
    public static int NurApiAES128_CBCDecrypt(Pointer<Byte> input, int length, Pointer<Byte> key, Pointer<Byte> iv, Pointer<Byte> output) {
        return NurApiAES128_CBCDecrypt(Pointer.getPeer(input), length, Pointer.getPeer(key), Pointer.getPeer(iv), Pointer.getPeer(output));
    }

    protected native static int NurApiAES128_CBCDecrypt(@Ptr long input, int length, @Ptr long key, @Ptr long iv, @Ptr long output);

    /**
     * @fn int NURAPICONV NurApiISO29167_10_TAM32(HANDLE hApi, BYTE sBank, DWORD sAddress, int sMaskBitLength, BYTE *sMask, struct NUR_TAM_PARAM *pTAM, struct NUR_TAM_RESP *pTAMResp)
     * <br>
     * <br>
     * Performs the ISO29167-10 Tag Authentication Method (TAM) 1 or 2 specified by the parameters using specific tag selection parameters.
     * <br>
     * <br>
     * @sa NurApiISO29167_10_TAM32, NurApiISO29167_10_TAMByEPC, NurApiISO29167_10_TAM, NUR_TAM_PARAM, NUR_TAM_RESP
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    sBank            Bank where the selection is applied to (EPC, TID or user memory).
     * <br>
     * @param    sAddress        Selection mask's bit address.
     * <br>
     * @param    sMaskBitLength    Selection mask's length in bits.
     * <br>
     * @param    sMask            Pointer to the selection mask data.
     * <br>
     * @param    pTAM            Pointer to the TAM parameter structure.
     * <br>
     * @param    pTAMResp        Pointer to the TAM response structure.
     * <br>
     *
     * <br>
     * @return Zero when succeeded. If an error occurs then an error code is returned and the response may contain additional information about the error.<br>
     * Original signature : <code>int NurApiISO29167_10_TAM32(HANDLE, BYTE, DWORD, int, BYTE*, NUR_TAM_PARAM*, NUR_TAM_RESP*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4222</i>
     */
    public static int NurApiISO29167_10_TAM32(Pointer<?> hApi, byte sBank, int sAddress, int sMaskBitLength, Pointer<Byte> sMask, Pointer<NUR_TAM_PARAM> pTAM, Pointer<NUR_TAM_RESP> pTAMResp) {
        return NurApiISO29167_10_TAM32(Pointer.getPeer(hApi), sBank, sAddress, sMaskBitLength, Pointer.getPeer(sMask), Pointer.getPeer(pTAM), Pointer.getPeer(pTAMResp));
    }

    protected native static int NurApiISO29167_10_TAM32(@Ptr long hApi, byte sBank, int sAddress, int sMaskBitLength, @Ptr long sMask, @Ptr long pTAM, @Ptr long pTAMResp);

    /**
     * @fn int NURAPICONV NurApiISO29167_10_TAMByEPC(HANDLE hApi, BYTE *epcBuffer, DWORD epcBufferLen, struct NUR_TAM_PARAM *pTAM, struct NUR_TAM_RESP *pTAMResp)
     * <br>
     * <br>
     * Performs the ISO29167-10 Tag Authentication Method (TAM) 1 or 2 specified by the parameters using EPC singulation.
     * <br>
     * <br>
     * @sa NurApiISO29167_10_TAM32, NurApiISO29167_10_TAM, NUR_TAM_PARAM, NUR_TAM_RESP
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    epcBuffer        Pointer to the tag's expected EPC constents starting from bit addresss 32 (word addres 2) in the EPC bank.
     * <br>
     * @param    epcBufferLen    Length, in bytes, of the EPC buffer.
     * <br>
     * @param    pTAM            Pointer to the TAM parameter structure.
     * <br>
     * @param    pTAMResp        Pointer to the TAM response structure.
     * <br>
     *
     * <br>
     * @return Zero when succeeded. If an error occurs then an error code is returned and the response may contain additional information about the error.<br>
     * Original signature : <code>int NurApiISO29167_10_TAMByEPC(HANDLE, BYTE*, DWORD, NUR_TAM_PARAM*, NUR_TAM_RESP*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4239</i>
     */
    public static int NurApiISO29167_10_TAMByEPC(Pointer<?> hApi, Pointer<Byte> epcBuffer, int epcBufferLen, Pointer<NUR_TAM_PARAM> pTAM, Pointer<NUR_TAM_RESP> pTAMResp) {
        return NurApiISO29167_10_TAMByEPC(Pointer.getPeer(hApi), Pointer.getPeer(epcBuffer), epcBufferLen, Pointer.getPeer(pTAM), Pointer.getPeer(pTAMResp));
    }

    protected native static int NurApiISO29167_10_TAMByEPC(@Ptr long hApi, @Ptr long epcBuffer, int epcBufferLen, @Ptr long pTAM, @Ptr long pTAMResp);

    /**
     * @fn int NURAPICONV NurApiISO29167_10_TAM(HANDLE hApi, struct NUR_TAM_PARAM *pTAM, struct NUR_TAM_RESP *pTAMResp)
     * <br>
     * <br>
     * Performs the ISO29167-10 Tag Authentication Method (TAM) 1 or 2 specified by the parameters using specific tag selection parameters.
     * <br>
     * <br>
     * @sa NurApiISO29167_10_TAM32, NurApiISO29167_10_TAMByEPC, NUR_TAM_PARAM, NUR_TAM_RESP
     * <br>
     *
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    pTAM            Pointer to the TAM parameter structure.
     * <br>
     * @param    pTAMResp        Pointer to the TAM response structure.
     * <br>
     *
     * <br>
     * @return Zero when succeeded. If an error occurs then an error code is returned and the response may contain additional information about the error.<br>
     * Original signature : <code>int NurApiISO29167_10_TAM(HANDLE, NUR_TAM_PARAM*, NUR_TAM_RESP*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4254</i>
     */
    public static int NurApiISO29167_10_TAM(Pointer<?> hApi, Pointer<NUR_TAM_PARAM> pTAM, Pointer<NUR_TAM_RESP> pTAMResp) {
        return NurApiISO29167_10_TAM(Pointer.getPeer(hApi), Pointer.getPeer(pTAM), Pointer.getPeer(pTAMResp));
    }

    protected native static int NurApiISO29167_10_TAM(@Ptr long hApi, @Ptr long pTAM, @Ptr long pTAMResp);

    /**
     * @fn int NurApiStartTagTracking(HANDLE hApi, struct NUR_TAGTRACKING_CONFIG *cfg, DWORD cfgSize)
     * <br>
     * <br>
     * Start tag tracking streaming on module.
     * <br>
     * Module will start tag tracking on the module and send tag tracking events to host as notification.
     * <br>
     * The notifications are configured in the parameter NUR_TAGTRACKING_CONFIG flags.
     * <br>
     * <br>
     * @sa NurApiStopTagTracking(), NUR_TAGTRACKING_CONFIG, NUR_TAGTRACKING_FLAGS
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance.
     * <br>
     * @param    cfg                Pointer to NUR_TAGTRACKING_CONFIG parameters.
     * <br>
     * @param    cfgSize            Size of <i>cfg</i> structure in bytes.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiStartTagTracking(HANDLE, NUR_TAGTRACKING_CONFIG*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4271</i>
     */
    public static int NurApiStartTagTracking(Pointer<?> hApi, Pointer<NUR_TAGTRACKING_CONFIG> cfg, int cfgSize) {
        return NurApiStartTagTracking(Pointer.getPeer(hApi), Pointer.getPeer(cfg), cfgSize);
    }

    protected native static int NurApiStartTagTracking(@Ptr long hApi, @Ptr long cfg, int cfgSize);

    /**
     * @fn int NurApiStopTagTracking(HANDLE hApi)
     * <br>
     * <br>
     * Stop tag tracking streaming on module.
     * <br>
     * <br>
     * @param    hApi    Handle to valid NurApi object instance
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiStopTagTracking(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4282</i>
     */
    public static int NurApiStopTagTracking(Pointer<?> hApi) {
        return NurApiStopTagTracking(Pointer.getPeer(hApi));
    }

    protected native static int NurApiStopTagTracking(@Ptr long hApi);

    /**
     * @fn BOOL NurApiIsTagTrackingRunning(HANDLE hApi)
     * <br>
     * <br>
     * Return TRUE if tag tracking stream routine is running on module.
     * <br>
     * <br>
     * @param    hApi    Handle to valid NurApi object instance
     * <br>
     * <br>
     * @return TRUE if tag tracking stream routine is running. FALSE otherwise.<br>
     * Original signature : <code>BOOL NurApiIsTagTrackingRunning(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4293</i>
     */
    public static int NurApiIsTagTrackingRunning(Pointer<?> hApi) {
        return NurApiIsTagTrackingRunning(Pointer.getPeer(hApi));
    }

    protected native static int NurApiIsTagTrackingRunning(@Ptr long hApi);

    /**
     * @param tagDataBuffer Pointer to a NUR_TT_TAG structures. Must contain at least <i>tagDataCount</i> entries of NUR_TT_TAG.
     *                      <br>
     * @fn int NurApiTagTrackingGetTags(HANDLE hApi, DWORD events, struct NUR_TT_TAG *tagDataBuffer, int *tagDataCount, DWORD szSingleEntry)
     * <br>
     * <br>
     * Get tag tracking tags.
     * <br>
     *
     * <br>
     * @sa NurApiGetTagCount(), NurApiClearTags(), NUR_TT_TAG
     * <br>
     *
     * <br>
     * @param    hApi                Handle to valid NurApi object instance.
     * <br>
     * @param    events                Which tags to include to the return value. For values to input @sa NUR_TAGTRACKING_EVENTS
     * <br>
     * @param    tagDataCount        Number of entries in <i>tagDataBuffer</i>. On return number of valid entries is received in this pointer.
     * <br>
     * @param    szSingleEntry        Size of one NUR_TT_TAG entry.
     * <br>
     *
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiTagTrackingGetTags(HANDLE, DWORD, NUR_TT_TAG*, int*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4310</i>
     */
    public static int NurApiTagTrackingGetTags(Pointer<?> hApi, int events, Pointer<NUR_TT_TAG> tagDataBuffer, Pointer<Integer> tagDataCount, int szSingleEntry) {
        return NurApiTagTrackingGetTags(Pointer.getPeer(hApi), events, Pointer.getPeer(tagDataBuffer), Pointer.getPeer(tagDataCount), szSingleEntry);
    }

    protected native static int NurApiTagTrackingGetTags(@Ptr long hApi, int events, @Ptr long tagDataBuffer, @Ptr long tagDataCount, int szSingleEntry);

    /**
     * @fn int NurApiSetHostFlags(HANDLE hApi, TCHAR* resp, DWORD hostFlags)
     * <br>
     * <br>
     * Set module host flags. Uses NurApiPing to send the selected flags to the device.
     * <br>
     * <br>
     * @param    hApi    Handle to valid NurApi object instance.
     * <br>
     * @param    resp    Pointer to a buffer that receives ping response. This parameter can be NULL. <b>NOTE: If not NULL, buffer must be atleast 16 TCHARs long</b>.
     * <br>
     * @param    hostFlags Host configuration flags. See NUR_HOSTFLAGS
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @sa enum NUR_HOSTFLAGS<br>
     * Original signature : <code>int NurApiSetHostFlags(HANDLE, TCHAR*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4323</i>
     */
    public static int NurApiSetHostFlags(Pointer<?> hApi, Pointer<Byte> resp, int hostFlags) {
        return NurApiSetHostFlags(Pointer.getPeer(hApi), Pointer.getPeer(resp), hostFlags);
    }

    protected native static int NurApiSetHostFlags(@Ptr long hApi, @Ptr long resp, int hostFlags);

    /**
     * @fn int NurApiGetMode(HANDLE hApi, char *mode)
     * <br>
     * <br>
     * Get NUR module running mode.
     * <br>
     * @param    hApi    Handle to valid NurApi object instance
     * <br>
     * @param    mode    Mode character is stored here. 'A' for application and 'B' for bootloader.
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiGetMode(HANDLE, char*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4333</i>
     */
    public static int NurApiGetMode(Pointer<?> hApi, Pointer<Byte> mode) {
        return NurApiGetMode(Pointer.getPeer(hApi), Pointer.getPeer(mode));
    }

    protected native static int NurApiGetMode(@Ptr long hApi, @Ptr long mode);

    /**
     * @fn int NurApiEnterBoot(HANDLE hApi)
     * <br>
     * <br>
     * Enter bootloader or application. If in bootloader mode, application entered. If in application mode, bootloader is entered.
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiEnterBoot(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4343</i>
     */
    public static int NurApiEnterBoot(Pointer<?> hApi) {
        return NurApiEnterBoot(Pointer.getPeer(hApi));
    }

    protected native static int NurApiEnterBoot(@Ptr long hApi);

    /**
     * @param enableEvents TRUE to enable, FALSE to disable
     *                     <br>
     *                     <br>
     * @fn int NurApiSetHopEvents(HANDLE hApi, BOOL enableEvents)
     * <br>
     * <br>
     * Enable NUR_NOTIFICATION_HOPEVENT generation.
     * <br>
     * NUR_NOTIFICATION_HOPEVENT is generated when ever RFID module hops to new operating frequency.
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @sa struct NUR_HOPEVENT_DATA<br>
     * Original signature : <code>int NurApiSetHopEvents(HANDLE, BOOL)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4357</i>
     */
    public static int NurApiSetHopEvents(Pointer<?> hApi, int enableEvents) {
        return NurApiSetHopEvents(Pointer.getPeer(hApi), enableEvents);
    }

    protected native static int NurApiSetHopEvents(@Ptr long hApi, int enableEvents);

    /**
     * @fn int NurApiProgramSmartFile(HANDLE hApi, const TCHAR *fname)
     * <br>
     * <br>
     * Program a new update file for Nordic ID Smart Devices
     * <br>
     * @sa NUR_NOTIFICATION_PRGPRGRESS in enum NUR_NOTIFICATION
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance
     * <br>
     * @param    fname            Path to smart device update file
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiProgramSmartFile(HANDLE, const TCHAR*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4370</i>
     */
    public static int NurApiProgramSmartFile(Pointer<?> hApi, Pointer<Byte> fname) {
        return NurApiProgramSmartFile(Pointer.getPeer(hApi), Pointer.getPeer(fname));
    }

    protected native static int NurApiProgramSmartFile(@Ptr long hApi, @Ptr long fname);

    /**
     * @fn int NurApiProgramAppFile(HANDLE hApi, const TCHAR *fname)
     * <br>
     * <br>
     * Program new firmware to NUR module.
     * <br>
     * @sa NUR_NOTIFICATION_PRGPRGRESS in enum NUR_NOTIFICATION
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance
     * <br>
     * @param    fname            Path to firmware
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remarks This command is available only in bootloader mode
     * <br>
     * @sa NurApiEnterBoot(), NurApiGetMode(), NurApiProgramBootloaderFile()<br>
     * Original signature : <code>int NurApiProgramAppFile(HANDLE, const TCHAR*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4385</i>
     */
    public static int NurApiProgramAppFile(Pointer<?> hApi, Pointer<Byte> fname) {
        return NurApiProgramAppFile(Pointer.getPeer(hApi), Pointer.getPeer(fname));
    }

    protected native static int NurApiProgramAppFile(@Ptr long hApi, @Ptr long fname);

    /**
     * @fn int NurApiProgramBootloaderFile(HANDLE hApi, const TCHAR *fname)
     * <br>
     * <br>
     * Program new bootloader to NUR module.
     * <br>
     * @sa NUR_NOTIFICATION_PRGPRGRESS in enum NUR_NOTIFICATION
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance
     * <br>
     * @param    fname            Path to bootloader
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.
     * <br>
     * @remarks This command is available only in bootloader mode
     * <br>
     * @sa NurApiEnterBoot(), NurApiGetMode(), NurApiProgramAppFile()<br>
     * Original signature : <code>int NurApiProgramBootloaderFile(HANDLE, const TCHAR*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4400</i>
     */
    public static int NurApiProgramBootloaderFile(Pointer<?> hApi, Pointer<Byte> fname) {
        return NurApiProgramBootloaderFile(Pointer.getPeer(hApi), Pointer.getPeer(fname));
    }

    protected native static int NurApiProgramBootloaderFile(@Ptr long hApi, @Ptr long fname);

    /**
     * @fn int NurApiContCarrier(HANDLE hApi, BYTE *params, DWORD paramsLen)
     * <br>
     * <br>
     * Set test modes with NUR module
     * <br>
     * <br>
     * After sending this command the module will continue sending / receiving data
     * <br>
     * as described below until NurApiStopContCarrier() is called.
     * <br>
     * <br>
     * For parameter description, please refer to external document NUR_carrier.pdf
     * <br>
     * or conact Nordic ID support.
     * <br>
     * <br>
     * @sa NurApiStopContCarrier()
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance
     * <br>
     * @param    params            Parameter bytes to send
     * <br>
     * @param    paramsLen        Length of params in bytes
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiContCarrier(HANDLE, BYTE*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4421</i>
     */
    public static int NurApiContCarrier(Pointer<?> hApi, Pointer<Byte> params, int paramsLen) {
        return NurApiContCarrier(Pointer.getPeer(hApi), Pointer.getPeer(params), paramsLen);
    }

    protected native static int NurApiContCarrier(@Ptr long hApi, @Ptr long params, int paramsLen);

    /**
     * @fn int NurApiStopContCarrier(HANDLE hApi)
     * <br>
     * <br>
     * Stop continuous carrier setting
     * <br>
     * <br>
     * @sa NurApiContCarrier()
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiStopContCarrier(HANDLE)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4434</i>
     */
    public static int NurApiStopContCarrier(Pointer<?> hApi) {
        return NurApiStopContCarrier(Pointer.getPeer(hApi));
    }

    protected native static int NurApiStopContCarrier(@Ptr long hApi);

    /**
     * @fn int NurApiDiagGetReport(HANDLE hApi, DWORD flags, struct NUR_DIAG_REPORT *report, DWORD reportSize)
     * <br>
     * <br>
     * Get diagnostics report from module.
     * <br>
     * <br>
     * @sa struct NUR_DIAG_REPORT
     * <br>
     * @sa enum NUR_DIAG_GETREPORT_FLAGS
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance
     * <br>
     * @param    flags            Bit flags to send with request. One or more of enum NUR_DIAG_GETREPORT_FLAGS.
     * <br>
     * @param    report            Pointer to struct NUR_DIAG_REPORT parameters. Result is stored in this struct.
     * <br>
     * @param    reportSize        Size of <i>report</i> structure in bytes.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiDiagGetReport(HANDLE, DWORD, NUR_DIAG_REPORT*, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4451</i>
     */
    public static int NurApiDiagGetReport(Pointer<?> hApi, int flags, Pointer<NUR_DIAG_REPORT> report, int reportSize) {
        return NurApiDiagGetReport(Pointer.getPeer(hApi), flags, Pointer.getPeer(report), reportSize);
    }

    protected native static int NurApiDiagGetReport(@Ptr long hApi, int flags, @Ptr long report, int reportSize);

    /**
     * @fn int NurApiDiagGetConfig(HANDLE hApi, DWORD *flags, DWORD *interval)
     * <br>
     * <br>
     * Get current diagnostics configuration.
     * <br>
     * <br>
     * @sa NurApiDiagSetConfig
     * <br>
     * @sa struct NUR_DIAG_REPORT
     * <br>
     * @sa enum NUR_DIAG_GETREPORT_FLAGS
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance
     * <br>
     * @param    flags            Pointer to DWORD. Current flags. One or more of enum NUR_DIAG_CFG_FLAGS.
     * <br>
     * @param    interval        Pointer to DWORD. Current report interval in seconds.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiDiagGetConfig(HANDLE, DWORD*, DWORD*)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4468</i>
     */
    public static int NurApiDiagGetConfig(Pointer<?> hApi, Pointer<Integer> flags, Pointer<Integer> interval) {
        return NurApiDiagGetConfig(Pointer.getPeer(hApi), Pointer.getPeer(flags), Pointer.getPeer(interval));
    }

    protected native static int NurApiDiagGetConfig(@Ptr long hApi, @Ptr long flags, @Ptr long interval);

    /**
     * @fn int NurApiDiagSetConfig(HANDLE hApi, DWORD flags, DWORD interval)
     * <br>
     * <br>
     * Set new diagnostics configuration.
     * <br>
     * <br>
     * @sa NurApiDiagGetConfig
     * <br>
     * @sa struct NUR_DIAG_REPORT
     * <br>
     * @sa enum NUR_DIAG_GETREPORT_FLAGS
     * <br>
     * <br>
     * @param    hApi            Handle to valid NurApi object instance
     * <br>
     * @param    flags            Bit flags to send with request. One or more of enum NUR_DIAG_CFG_FLAGS.
     * <br>
     * @param    interval        Report interval in seconds. Only valid if NUR_DIAG_CFG_NOTIFY_PERIODIC is set in flags. Set to 0 if NUR_DIAG_CFG_NOTIFY_PERIODIC is not set.
     * <br>
     * <br>
     * @return Zero when succeeded, On error non-zero error code is returned.<br>
     * Original signature : <code>int NurApiDiagSetConfig(HANDLE, DWORD, DWORD)</code><br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:4485</i>
     */
    public static int NurApiDiagSetConfig(Pointer<?> hApi, int flags, int interval) {
        return NurApiDiagSetConfig(Pointer.getPeer(hApi), flags, interval);
    }

    protected native static int NurApiDiagSetConfig(@Ptr long hApi, int flags, int interval);

    /**
     * NUR module baudrate indices.
     * <br>
     *
     * @sa NurApiGetBaudrate(), NurApiSetBaudrate()<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:12</i>
     */
    public enum NUR_BAUDRATE implements IntValuedEnum<NUR_BAUDRATE> {
        /**
         * < 115200 bps.
         */
        NUR_BR_115200(0),
        /**
         * < 230400 bps.
         */
        NUR_BR_230400(1),
        /**
         * < 500000 bps.
         */
        NUR_BR_500000(2),
        /**
         * < 1000000 bps.
         */
        NUR_BR_1000000(3),
        /**
         * < 1500000 bps (use with care).
         */
        NUR_BR_1500000(4),
        /**
         * < 38400 bps.
         */
        NUR_BR_38400(5),
        /**
         * < 9600 bps.
         */
        NUR_BR_9600(6);
        public final long value;

        NUR_BAUDRATE(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_BAUDRATE> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_BAUDRATE> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Tag tracking event configuration. Defines which type of tracking events the routine will trigger to generate NUR_NOTIFICATION_TT_CHANGED event<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:23</i>
     */
    public enum NUR_TAGTRACKING_EVENTS implements IntValuedEnum<NUR_TAGTRACKING_EVENTS> {
        /**
         * < None.
         */
        NUR_TTEV_NONE(0),
        /**
         * < When tag comes visible or is lost. Tag will be lost according to visibilityTimeout specified in NUR_TAGTRACKING_CONFIG
         */
        NUR_TTEV_VISIBILITY((1 << 0)),
        /**
         * < When tag changes antenna
         */
        NUR_TTEV_ANTENNA((1 << 1)),
        /**
         * < When tag rssi changes the amount specified in the rssiDeltaFilter in NUR_TAGTRACKING_CONFIG
         */
        NUR_TTEV_RSSI((1 << 2)),
        /**
         * < When tag position changes the amount specified in the positionDeltaFilter in NUR_TAGTRACKING_CONFIG
         */
        NUR_TTEV_POSITION((1 << 3)),
        /**
         * < When tag sector changes
         */
        NUR_TTEV_SECTOR((1 << 4)),
        /**
         * < When module starts/stops scanning each antenna/beam
         */
        NUR_TTEV_SCAN((1 << 5)),
        /**
         * < When tag moves between in/out antennas or sectors. InAntennaMask & OutAntennaMask need to be configured in NUR_TAGTRACKING_CONFIG
         */
        NUR_TTEV_INOUT((1 << 6));
        public final long value;

        NUR_TAGTRACKING_EVENTS(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_TAGTRACKING_EVENTS> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_TAGTRACKING_EVENTS> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Tag tracking routine configuration flags. Defines whether to use a filter(simple or complex version) and that should the routine perform a full round(i.e. read with all antennas) before reporting the changed events.<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:30</i>
     */
    public enum NUR_TAGTRACKING_FLAGS implements IntValuedEnum<NUR_TAGTRACKING_FLAGS> {
        /**
         * < No specific configuration
         */
        NUR_TTFL_NONE(0),
        /**
         * <  Trigger NUR_NOTIFICATION_TT_CHANGED when all antennas have been read
         */
        NUR_TTFL_FULLROUNDREPORT((1 << 0)),
        /**
         * < Use the simple filter parameters passed in NUR_TAGTRACKING_CONFIG selectMask, selectMaskBitLength, selectAddress and selectBank
         */
        NUR_TTFL_USESIMPLEFILTER((1 << 1)),
        /**
         * < Use the complex filter parameters passed in NUR_TAGTRACKING_CONFIG complexFilters, complexFilterParams and complexFilterCnt @sa NUR_INVEX_FILTER and @sa NUR_INVEX_PARAMS
         */
        NUR_TTFL_USECOMPLEXFILTER((1 << 2));
        public final long value;

        NUR_TAGTRACKING_FLAGS(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_TAGTRACKING_FLAGS> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_TAGTRACKING_FLAGS> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * TTIO direction of the tag. Indicates whether the tag has moved from inAntennaMask to outAntennaMask or vice versa as defined in NUR_TAGTRACKING_CONFIG.<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:36</i>
     */
    public enum NUR_TAGTRACKING_INOUT_DIRECTION implements IntValuedEnum<NUR_TAGTRACKING_INOUT_DIRECTION> {
        /**
         * < No specific tag direction set
         */
        NUR_TTIO_DIRECTION_NONE(0),
        /**
         * < Tag has moved from in to out
         */
        NUR_TTIO_DIRECTION_INTOOUT((1 << 0)),
        /**
         * < Tag has moved from out to in
         */
        NUR_TTIO_DIRECTION_OUTTOIN((1 << 1));
        public final long value;

        NUR_TAGTRACKING_INOUT_DIRECTION(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_TAGTRACKING_INOUT_DIRECTION> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_TAGTRACKING_INOUT_DIRECTION> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Notification types you can receive in NotificationCallback.
     * <br>
     * See function NurApiSetNotificationCallback()<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:70</i>
     */
    public enum NUR_NOTIFICATION implements IntValuedEnum<NUR_NOTIFICATION> {
        /**
         * < None.
         */
        NUR_NOTIFICATION_NONE(0),
        /**
         * < New log string available.
         */
        NUR_NOTIFICATION_LOG(1),
        /**
         * < Periodic inventory data. see NUR_PERIODIC_INVENTORY_DATA, NurApiStartPeriodicInventory()
         */
        NUR_NOTIFICATION_PERIODIC_INVENTORY(2),
        /**
         * < Programming progress. see NUR_PRGPROGRESS_DATA, NurApiProgramAppFile(), NurApiProgramApp()
         */
        NUR_NOTIFICATION_PRGPRGRESS(3),
        /**
         * < Transport disconnected.
         */
        NUR_NOTIFICATION_TRDISCONNECTED(4),
        /**
         * < Module booted.
         */
        NUR_NOTIFICATION_MODULEBOOT(5),
        /**
         * < Transport connected.
         */
        NUR_NOTIFICATION_TRCONNECTED(6),
        /**
         * < Trace tag.
         */
        NUR_NOTIFICATION_TRACETAG(7),
        /**
         * < IO Change.
         */
        NUR_NOTIFICATION_IOCHANGE(8),
        /**
         * < IO triggered tag read.
         */
        NUR_NOTIFICATION_TRIGGERREAD(9),
        /**
         * < Channel hopping event.
         */
        NUR_NOTIFICATION_HOPEVENT(10),
        /**
         * < Tag data from inventory stream.
         */
        NUR_NOTIFICATION_INVENTORYSTREAM(11),
        /**
         * < Tag data from extended inventory stream.
         */
        NUR_NOTIFICATION_INVENTORYEX(12),
        /**
         * < Ethernet device info founded from network (Ethernet Sampo devices) see NurApiSendBroadcast()
         */
        NUR_NOTIFICATION_DEVSEARCH(13),
        /**
         * < Client device connected to Server
         */
        NUR_NOTIFICATION_CLIENTCONNECTED(14),
        /**
         * < Client Disconnected from Server
         */
        NUR_NOTIFICATION_CLIENTDISCONNECTED(15),
        /**
         * < NXP EAS Alarm state change
         */
        NUR_NOTIFICATION_EASALARM(16),
        /**
         * < New EPC was programmed by the EPC enumeration stream.
         */
        NUR_NOTIFICATION_EPCENUM(17),
        /**
         * < State change in Ext input port 0-3
         */
        NUR_NOTIFICATION_EXTIN(18),
        /**
         * < General data from device. first byte indicates data content. 1=Tag deactivated 2=HealtCheckReport
         */
        NUR_NOTIFICATION_GENERAL(19),
        /**
         * < Antenna tuning event.
         */
        NUR_NOTIFICATION_TUNEEVENT(20),
        /**
         * < WLan network search result
         */
        NUR_NOTIFICATION_WLAN_SEARCH(21),
        /**
         * < internal event
         */
        NUR_NOTIFICATION_TT_STREAM(22),
        /**
         * < Tag tracking event
         */
        NUR_NOTIFICATION_TT_CHANGED(23),
        /**
         * < Tag tracking scan start/stop event
         */
        NUR_NOTIFICATION_TT_SCANEVENT(24),
        /**
         * < Diagnostics report
         */
        NUR_NOTIFICATION_DIAG_REPORT(25),
        /**
         * < Accessory event
         */
        NUR_NOTIFICATION_ACCESSORY(26),
        NUR_NOTIFICATION_LAST(27);
        public final long value;

        NUR_NOTIFICATION(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_NOTIFICATION> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_NOTIFICATION> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Log levels
     * <br>
     *
     * @sa NurApiSetLogLevel(), NurApiGetLogLevel()<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:81</i>
     */
    public enum NUR_LOG implements IntValuedEnum<NUR_LOG> {
        /**
         * < Verbose log.
         */
        NUR_LOG_VERBOSE((1 << 0)),
        /**
         * < Error log.
         */
        NUR_LOG_ERROR((1 << 1)),
        /**
         * < User log.
         */
        NUR_LOG_USER((1 << 2)),
        /**
         * < Data log.
         */
        NUR_LOG_DATA((1 << 3)),
        /**
         * < All flags log combined.
         */
        NUR_LOG_ALL((1 << 0 | 1 << 1 | 1 << 2 | 1 << 3));
        public final long value;

        NUR_LOG(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_LOG> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_LOG> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Filter types for Broadcast messaging
     * <br>
     *
     * @sa NurApiSendBroadcast()<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:97</i>
     */
    public enum NUR_BC_FILTER_TYPE implements IntValuedEnum<NUR_BC_FILTER_TYPE> {
        /**
         * < No filter
         */
        NUR_BC_FILTER_TYPE_NONE(0),
        /**
         * < Broadcast filter type MAC address (12 hexstring like: "0021ad0a0007)"
         */
        NUR_BC_FILTER_TYPE_MAC(1),
        /**
         * < IP address (x.x.x.x)
         */
        NUR_BC_FILTER_TYPE_IP(2),
        /**
         * < Version (Numeric)
         */
        NUR_BC_FILTER_TYPE_VERSION(3),
        /**
         * < Server port(Numeric)
         */
        NUR_BC_FILTER_TYPE_SERVERPORT(4),
        /**
         * < Address type (0=DHCP 1=static)
         */
        NUR_BC_FILTER_TYPE_ADDRTYPE(5),
        /**
         * < Host mode (0=server 1=client)
         */
        NUR_BC_FILTER_TYPE_MODE(6),
        /**
         * < Nur version (Numeric)
         */
        NUR_BC_FILTER_TYPE_NURVER(7),
        /**
         * < Status (0=Disconnected 1=Connected)
         */
        NUR_BC_FILTER_TYPE_STATUS(8),
        /**
         * < Name (part of name string for filtering with device name)
         */
        NUR_BC_FILTER_TYPE_NAME(9);
        public final long value;

        NUR_BC_FILTER_TYPE(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_BC_FILTER_TYPE> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_BC_FILTER_TYPE> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Filter operations for Broadcast messaging
     * <br>
     *
     * @sa NurApiSendBroadcast()<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:106</i>
     */
    public enum NUR_BC_FILTER_OP implements IntValuedEnum<NUR_BC_FILTER_OP> {
        /**
         * < EQUAL
         */
        NUR_BC_FILTER_OP_EQUAL(0),
        /**
         * < HIGHER
         */
        NUR_BC_FILTER_OP_HIGHER(1),
        /**
         * < LOWER
         */
        NUR_BC_FILTER_OP_LOWER(2);
        public final long value;

        NUR_BC_FILTER_OP(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_BC_FILTER_OP> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_BC_FILTER_OP> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Broadcast commands.
     * <br>
     *
     * @sa NurApiSendBroadcast(), NUR_NOTIFICATION_DEVSEARCH, NUR_NETDEV_INFO<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:117</i>
     */
    public enum NUR_BC_CMD implements IntValuedEnum<NUR_BC_CMD> {
        /**
         * < Request for device info. Sampo response with notification NUR_NOTIFICATION_DEVSEARCH
         */
        NUR_BC_GET_DEV_INFO(1),
        /**
         * < NOT USED
         */
        NUR_BC_GET_ETHCONFIG(2),
        /**
         * < NOT USED
         */
        NUR_BC_GET_GPIO(3),
        /**
         * < Set Ethernet configuration
         */
        NUR_BC_SET_ETHCONFIG(4),
        /**
         * < Generates beep
         */
        NUR_BC_BEEP(5);
        public final long value;

        NUR_BC_CMD(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_BC_CMD> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_BC_CMD> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Transport method when sending ethernet configuration to device.
     * <br>
     * See Struct NUR_ETHDEV_CONFIG<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:125</i>
     */
    public enum NUR_SETCONFIG_TRANSPORT_METHOD implements IntValuedEnum<NUR_SETCONFIG_TRANSPORT_METHOD> {
        /**
         * < Transport will be via currently connected NUR device
         */
        NUR_TRANSPORT_NUR(0),
        /**
         * < Transport is Broadcast and filtering is set to MAC address
         */
        NUR_TRANSPORT_BROADCAST(1);
        public final long value;

        NUR_SETCONFIG_TRANSPORT_METHOD(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_SETCONFIG_TRANSPORT_METHOD> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_SETCONFIG_TRANSPORT_METHOD> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * EPC memory banks for singulation, read and write operations.<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:132</i>
     */
    public enum NUR_BANK implements IntValuedEnum<NUR_BANK> {
        /**
         * < Password memory bank.
         */
        NUR_BANK_PASSWD(0),
        /**
         * < EPC memory bank.
         */
        NUR_BANK_EPC(1),
        /**
         * < TID memory bank.
         */
        NUR_BANK_TID(2),
        /**
         * < User memory bank.
         */
        NUR_BANK_USER(3);
        public final long value;

        NUR_BANK(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_BANK> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_BANK> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Action parameter for NurApiSetLock() and NurApiSetLockByEPC() functions.
     * <br>
     *
     * @sa NurApiSetLock(), NurApiSetLockByEPC()<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:142</i>
     */
    public enum NUR_LOCKACTION implements IntValuedEnum<NUR_LOCKACTION> {
        /**
         * < Associated memory bank is readable from open/secured states.
         */
        NUR_LOCK_OPEN(0),
        /**
         * < Associated memory bank is permanently writable from open/secured states and may never be locked.
         */
        NUR_LOCK_PERMAWRITE(1),
        /**
         * < Associated memory bank is writable only from secured state.
         */
        NUR_LOCK_SECURED(2),
        /**
         * < Associated memory bank is not writable from any state. If locked memory is AccessPwd or KillPwd memory is not readable from any state.
         */
        NUR_LOCK_PERMALOCK(3);
        public final long value;

        NUR_LOCKACTION(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_LOCKACTION> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_LOCKACTION> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Memory mask parameter for NurApiSetLock() and NurApiSetLockByEPC() functions.
     * <br>
     *
     * @sa NurApiSetLock(), NurApiSetLockByEPC()<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:153</i>
     */
    public enum NUR_LOCKMEM implements IntValuedEnum<NUR_LOCKMEM> {
        /**
         * < User memory bank lock mask.
         */
        NUR_LOCK_USERMEM((1 << 0)),
        /**
         * < TID memory bank lock mask.
         */
        NUR_LOCK_TIDMEM((1 << 1)),
        /**
         * < EPC memory bank lock mask.
         */
        NUR_LOCK_EPCMEM((1 << 2)),
        /**
         * < Access password memory lock mask.
         */
        NUR_LOCK_ACCESSPWD((1 << 3)),
        /**
         * < Kill password memory lock mask.
         */
        NUR_LOCK_KILLPWD((1 << 4));
        public final long value;

        NUR_LOCKMEM(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_LOCKMEM> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_LOCKMEM> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Flags parameter for NurApiTraceTag32() function.
     * <br>
     *
     * @sa NurApiTraceTag32(), NUR_NOTIFICATION_TRACETAG<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:162</i>
     */
    public enum NUR_TRACETAG implements IntValuedEnum<NUR_TRACETAG> {
        /**
         * < Do not transfer EPC back from trace tag function.
         */
        NUR_TRACETAG_NO_EPC((1 << 0)),
        /**
         * < Start continuous tag tracing.
         */
        NUR_TRACETAG_START_CONTINUOUS((1 << 1)),
        /**
         * < Stop continuous tag tracing.
         */
        NUR_TRACETAG_STOP_CONTINUOUS((1 << 3));
        public final long value;

        NUR_TRACETAG(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_TRACETAG> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_TRACETAG> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Flags parameter for custom bit stream command.
     * <br>
     *
     * @sa NurApiCustomBitStreamSingulated32(), NurApiCustomBitStreamByEPC, NurApiCustomBitStream32<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:178</i>
     */
    public enum NUR_CUSTXCHGFLAGS implements IntValuedEnum<NUR_CUSTXCHGFLAGS> {
        /**
         * < "Act if this was a write operation"
         */
        CXF_ASWRITE((1 << 0)),
        /**
         * < RN16 resulting from sinulation shall be appended to the bit stream
         */
        CXF_USEHANDLE((1 << 1)),
        /**
         * < if CXF_ASWRITE == '1' and TX bit length == 16, XOR the TX data with RN16 received from the tag access.
         */
        CXF_XORRN16((1 << 2)),
        /**
         * < Transmit only. No response is expected.
         */
        CXF_TXONLY((1 << 3)),
        /**
         * < No TX CRC.
         */
        CXF_NOTXCRC((1 << 4)),
        /**
         * < Do not decode RX CRC, return the response as is.
         */
        CXF_NORXCRC((1 << 5)),
        /**
         * < TX uses CRC-5 instead of CRC-16.
         */
        CXF_CRC5((1 << 6)),
        /**
         * < Unknown RX length. RX length is ignored.
         */
        CXF_NORXLEN((1 << 7)),
        /**
         * < Leave out the bacscattered handle in the response.
         */
        CXF_STRIPHND((1 << 8)),
        /**
         * < Skip tag re-selection during the custom exchange.
         */
        CXF_SKIPRESEL((1 << 9));
        public final long value;

        NUR_CUSTXCHGFLAGS(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_CUSTXCHGFLAGS> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_CUSTXCHGFLAGS> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Action field for struct NUR_GPIO_ENTRY or NUR_SENSOR_CONFIG.
     * <br>
     *
     * @sa struct NUR_GPIO_ENTRY, NUR_GPIO_CONFIG, NUR_SENSOR_CONFIG, NurApiSetGPIOConfig(), NurApiGetGPIOConfig(), NUR_NOTIFICATION_IOCHANGE, NUR_NOTIFICATION_TRIGGERREAD<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:188</i>
     */
    public enum NUR_GPIO_ACTION implements IntValuedEnum<NUR_GPIO_ACTION> {
        /**
         * < No action. GPIO state can be read manually.
         */
        NUR_GPIO_ACT_NONE(0),
        /**
         * < Send NUR_NOTIFICATION_IOCHANGE notification on GPIO/sensor change.
         */
        NUR_GPIO_ACT_NOTIFY(1),
        /**
         * < Start single tag scan on GPIO/sensor change. Tag result is received with NUR_NOTIFICATION_TRIGGERREAD notification.
         */
        NUR_GPIO_ACT_SCANTAG(2),
        /**
         * < Start inventory on GPIO/sensor change. Result is received with NUR_NOTIFICATION_INVENTORYSTREAM notification.
         */
        NUR_GPIO_ACT_INVENTORY(3);
        public final long value;

        NUR_GPIO_ACTION(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_GPIO_ACTION> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_GPIO_ACTION> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Edge field for struct NUR_GPIO_ENTRY
     * <br>
     *
     * @sa struct NUR_GPIO_ENTRY, NUR_GPIO_CONFIG, NurApiSetGPIOConfig(), NurApiGetGPIOConfig()<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:197</i>
     */
    public enum NUR_GPIO_EDGE implements IntValuedEnum<NUR_GPIO_EDGE> {
        /**
         * < Trigger IO's configured action on falling edge of IO
         */
        NUR_GPIO_EDGE_FALLING(0),
        /**
         * < Trigger IO's configured action on rising edge of IO
         */
        NUR_GPIO_EDGE_RISING(1),
        /**
         * < Trigger IO's configured action on both edges of IO
         */
        NUR_GPIO_EDGE_BOTH(2);
        public final long value;

        NUR_GPIO_EDGE(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_GPIO_EDGE> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_GPIO_EDGE> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Type of the GPIO
     * <br>
     *
     * @sa struct NUR_GPIO_ENTRY, NUR_GPIO_CONFIG, NurApiSetGPIOConfig(), NurApiGetGPIOConfig()<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:210</i>
     */
    public enum NUR_GPIO_TYPE implements IntValuedEnum<NUR_GPIO_TYPE> {
        /**
         * < GPIO is configured as output pin.
         */
        NUR_GPIO_TYPE_OUTPUT(0),
        /**
         * < GPIO is configured as input pin.
         */
        NUR_GPIO_TYPE_INPUT(1),
        /**
         * < GPIO will act as a Sampo S1 RFID on led (high active)
         */
        NUR_GPIO_TYPE_RFIDON(2),
        /**
         * < GPIO will act as a Sampo S1 RFID read led (high active)
         */
        NUR_GPIO_TYPE_RFIDREAD(3),
        /**
         * < GPIO will act as a beeper (high active)
         */
        NUR_GPIO_TYPE_BEEPER(4),
        /**
         * < GPIO is configured as antenna control 1 (bit0)
         */
        NUR_GPIO_TYPE_ANTCTL1(5),
        /**
         * < GPIO is configured as antenna control 2 (bit1)
         */
        NUR_GPIO_TYPE_ANTCTL2(6);
        public final long value;

        NUR_GPIO_TYPE(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_GPIO_TYPE> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_GPIO_TYPE> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Module General Purpose IO (GPIO) numbers
     * <br>
     *
     * @sa struct NUR_GPIO_STATUS, NurApiSetGPIOStatus(), NurApiGetGPIOStatus()<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:221</i>
     */
    public enum NUR_GPIO implements IntValuedEnum<NUR_GPIO> {
        /**
         * < Module GPIO 1
         */
        NUR_GPIO1(0),
        /**
         * < Module GPIO 2
         */
        NUR_GPIO2(1),
        /**
         * < Module GPIO 3
         */
        NUR_GPIO3(2),
        /**
         * < Module GPIO 4
         */
        NUR_GPIO4(3),
        /**
         * < Module GPIO 5
         */
        NUR_GPIO5(4);
        public final long value;

        NUR_GPIO(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_GPIO> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_GPIO> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Region ID's indices
     * <br>
     *
     * @sa NurApiGetRegionInfo(), struct NUR_REGIONINFO, struct NUR_MODULESETUP<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:249</i>
     */
    public enum NUR_REGIONID implements IntValuedEnum<NUR_REGIONID> {
        /**
         * < Europe
         */
        NUR_REGIONID_EU(0),
        /**
         * < North-America
         */
        NUR_REGIONID_FCC(1),
        /**
         * < People's Republic of China (Upper Band)
         */
        NUR_REGIONID_PRC(2),
        /**
         * < Malaysia
         */
        NUR_REGIONID_MALAYSIA(3),
        /**
         * < Brazil
         */
        NUR_REGIONID_BRAZIL(4),
        /**
         * < Australia
         */
        NUR_REGIONID_AUSTRALIA(5),
        /**
         * < New Zealand
         */
        NUR_REGIONID_NEWZEALAND(6),
        /**
         * < Japan 250mW LBT (NUR Fw 2.4-A or later)
         */
        NUR_REGIONID_JA250MW(7),
        /**
         * < Japan 500mW DRM (NUR Fw 2.4-A or later)
         */
        NUR_REGIONID_JA500MW(8),
        /**
         * < Korea LBT (NUR Fw 2.7-A or later)
         */
        NUR_REGIONID_KOREA_LBT(9),
        /**
         * < India (NUR Fw 2.7-A or later)
         */
        NUR_REGIONID_INDIA(10),
        /**
         * < Russia (NUR Fw 3.0-A or later)
         */
        NUR_REGIONID_RUSSIA(11),
        /**
         * < Vietnam (NUR Fw 3.0-A or later)
         */
        NUR_REGIONID_VIETNAM(12),
        /**
         * < Singapore (NUR Fw 3.0-A or later)
         */
        NUR_REGIONID_SINGAPORE(13),
        /**
         * < Thailand (NUR Fw 3.0-A or later)
         */
        NUR_REGIONID_THAILAND(14),
        /**
         * < Philippines (NUR Fw 3.0-A or later)
         */
        NUR_REGIONID_PHILIPPINES(15),
        /**
         * < Morocco (NUR Fw 5.0-A or later)
         */
        NUR_REGIONID_MOROCCO(16),
        /**
         * < Peru (NUR Fw 5.0-A or later)
         */
        NUR_REGIONID_PERU(17),
        /**
         * < Israel (NUR Fw 5.6-A or later)
         */
        NUR_REGIONID_ISRAEL(18),
        /**
         * < Hong Kong (NUR Fw 5.7-A or later)
         */
        NUR_REGIONID_HONGKONG(19),
        /**
         * < Defines the last available region ID before the custom.
         */
        NUR_REGIONID_LAST(19),
        /**
         * < Custom hop table
         */
        NUR_REGIONID_CUSTOM(0xFE);
        public final long value;

        NUR_REGIONID(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_REGIONID> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_REGIONID> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * RX coding indices
     * <br>
     *
     * @sa struct NUR_MODULESETUP<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:260</i>
     */
    public enum NUR_RXDECODING implements IntValuedEnum<NUR_RXDECODING> {
        /**
         * < FM-0
         */
        NUR_RXDECODING_FM0(0),
        /**
         * < Miller-2
         */
        NUR_RXDECODING_M2(1),
        /**
         * < Miller-4
         */
        NUR_RXDECODING_M4(2),
        /**
         * < Miller-8
         */
        NUR_RXDECODING_M8(3),
        NUR_RXDECODING_LAST(4);
        public final long value;

        NUR_RXDECODING(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_RXDECODING> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_RXDECODING> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * TX modulation indices
     * <br>
     *
     * @sa struct NUR_MODULESETUP<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:269</i>
     */
    public enum NUR_TXMODULATION implements IntValuedEnum<NUR_TXMODULATION> {
        /**
         * < ASK
         */
        NUR_TXMODULATION_ASK(0),
        /**
         * < PR-ASK
         */
        NUR_TXMODULATION_PRASK(1),
        NUR_TXMODULATION_LAST(2);
        public final long value;

        NUR_TXMODULATION(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_TXMODULATION> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_TXMODULATION> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Zero based antenna ID definitions.
     * <br>
     *
     * @sa NurApiGetAntenna(), NurApiSetAntenna(), NurApiGetAntennaMask()<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:310</i>
     */
    public enum NUR_ANTENNAID implements IntValuedEnum<NUR_ANTENNAID> {
        /**
         * < Auto switch antenna based on supported antenna count.
         */
        NUR_ANTENNAID_AUTOSELECT(0xFFFFFFFFL),
        /**
         * < Antenna ID 1.
         */
        NUR_ANTENNAID_1(0),
        /**
         * < Antenna ID 2.
         */
        NUR_ANTENNAID_2(1),
        /**
         * < Antenna ID 3.
         */
        NUR_ANTENNAID_3(2),
        /**
         * < Antenna ID 4.
         */
        NUR_ANTENNAID_4(3),
        /**
         * < Antenna ID 5.
         */
        NUR_ANTENNAID_5(4),
        /**
         * < Antenna ID 6.
         */
        NUR_ANTENNAID_6(5),
        /**
         * < Antenna ID 7.
         */
        NUR_ANTENNAID_7(6),
        /**
         * < Antenna ID 8.
         */
        NUR_ANTENNAID_8(7),
        /**
         * < Antenna ID 9.
         */
        NUR_ANTENNAID_9(8),
        /**
         * < Antenna ID 10.
         */
        NUR_ANTENNAID_10(9),
        /**
         * < Antenna ID 11
         */
        NUR_ANTENNAID_11(10),
        /**
         * < Antenna ID 12.
         */
        NUR_ANTENNAID_12(11),
        /**
         * < Antenna ID 13.
         */
        NUR_ANTENNAID_13(12),
        /**
         * < Antenna ID 14.
         */
        NUR_ANTENNAID_14(13),
        /**
         * < Antenna ID 15.
         */
        NUR_ANTENNAID_15(14),
        /**
         * < Antenna ID 16.
         */
        NUR_ANTENNAID_16(15),
        /**
         * < Antenna ID 17.
         */
        NUR_ANTENNAID_17(16),
        /**
         * < Antenna ID 18.
         */
        NUR_ANTENNAID_18(17),
        /**
         * < Antenna ID 19.
         */
        NUR_ANTENNAID_19(18),
        /**
         * < Antenna ID 20.
         */
        NUR_ANTENNAID_20(19),
        /**
         * < Antenna ID 21.
         */
        NUR_ANTENNAID_21(20),
        /**
         * < Antenna ID 22.
         */
        NUR_ANTENNAID_22(21),
        /**
         * < Antenna ID 23.
         */
        NUR_ANTENNAID_23(22),
        /**
         * < Antenna ID 24.
         */
        NUR_ANTENNAID_24(23),
        /**
         * < Antenna ID 25.
         */
        NUR_ANTENNAID_25(24),
        /**
         * < Antenna ID 26.
         */
        NUR_ANTENNAID_26(25),
        /**
         * < Antenna ID 27.
         */
        NUR_ANTENNAID_27(26),
        /**
         * < Antenna ID 28.
         */
        NUR_ANTENNAID_28(27),
        /**
         * < Antenna ID 29.
         */
        NUR_ANTENNAID_29(28),
        /**
         * < Antenna ID 30.
         */
        NUR_ANTENNAID_30(29),
        /**
         * < Antenna ID 31.
         */
        NUR_ANTENNAID_31(30),
        /**
         * < Antenna ID 32.
         */
        NUR_ANTENNAID_32(31),
        /**
         * < Old maximum number of antennas. Provided for compatibility. Use NUR_MAX_ANTENNAS_EX instead
         */
        NUR_MAX_ANTENNAS(4),
        /**
         * < Maximum number of antennas.
         */
        NUR_MAX_ANTENNAS_EX(32);
        public final long value;

        NUR_ANTENNAID(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_ANTENNAID> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_ANTENNAID> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Bit masks for antenna mask.
     * <br>
     *
     * @sa NurApiGetAntenna(), NurApiSetAntenna(), NurApiGetAntennaMask()<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:349</i>
     */
    public enum NUR_ANTENNAMASK implements IntValuedEnum<NUR_ANTENNAMASK> {
        /**
         * < Mask for antenna ID 1.
         */
        NUR_ANTENNAMASK_1((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_1.value()))),
        /**
         * < Mask for antenna ID 2.
         */
        NUR_ANTENNAMASK_2((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_2.value()))),
        /**
         * < Mask for antenna ID 3.
         */
        NUR_ANTENNAMASK_3((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_3.value()))),
        /**
         * < Mask for antenna ID 4.
         */
        NUR_ANTENNAMASK_4((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_4.value()))),
        /**
         * < Mask for antenna ID 5.
         */
        NUR_ANTENNAMASK_5((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_5.value()))),
        /**
         * < Mask for antenna ID 6.
         */
        NUR_ANTENNAMASK_6((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_6.value()))),
        /**
         * < Mask for antenna ID 7.
         */
        NUR_ANTENNAMASK_7((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_7.value()))),
        /**
         * < Mask for antenna ID 8.
         */
        NUR_ANTENNAMASK_8((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_8.value()))),
        /**
         * < Mask for antenna ID 9.
         */
        NUR_ANTENNAMASK_9((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_9.value()))),
        /**
         * < Mask for antenna ID 10.
         */
        NUR_ANTENNAMASK_10((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_10.value()))),
        /**
         * < Mask for antenna ID 11.
         */
        NUR_ANTENNAMASK_11((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_11.value()))),
        /**
         * < Mask for antenna ID 12.
         */
        NUR_ANTENNAMASK_12((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_12.value()))),
        /**
         * < Mask for antenna ID 13.
         */
        NUR_ANTENNAMASK_13((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_13.value()))),
        /**
         * < Mask for antenna ID 14.
         */
        NUR_ANTENNAMASK_14((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_14.value()))),
        /**
         * < Mask for antenna ID 15.
         */
        NUR_ANTENNAMASK_15((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_15.value()))),
        /**
         * < Mask for antenna ID 16.
         */
        NUR_ANTENNAMASK_16((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_16.value()))),
        /**
         * < Mask for antenna ID 17.
         */
        NUR_ANTENNAMASK_17((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_17.value()))),
        /**
         * < Mask for antenna ID 18.
         */
        NUR_ANTENNAMASK_18((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_18.value()))),
        /**
         * < Mask for antenna ID 19.
         */
        NUR_ANTENNAMASK_19((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_19.value()))),
        /**
         * < Mask for antenna ID 20.
         */
        NUR_ANTENNAMASK_20((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_20.value()))),
        /**
         * < Mask for antenna ID 21.
         */
        NUR_ANTENNAMASK_21((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_21.value()))),
        /**
         * < Mask for antenna ID 22.
         */
        NUR_ANTENNAMASK_22((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_22.value()))),
        /**
         * < Mask for antenna ID 23.
         */
        NUR_ANTENNAMASK_23((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_23.value()))),
        /**
         * < Mask for antenna ID 24.
         */
        NUR_ANTENNAMASK_24((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_24.value()))),
        /**
         * < Mask for antenna ID 25.
         */
        NUR_ANTENNAMASK_25((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_25.value()))),
        /**
         * < Mask for antenna ID 26.
         */
        NUR_ANTENNAMASK_26((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_26.value()))),
        /**
         * < Mask for antenna ID 27.
         */
        NUR_ANTENNAMASK_27((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_27.value()))),
        /**
         * < Mask for antenna ID 28.
         */
        NUR_ANTENNAMASK_28((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_28.value()))),
        /**
         * < Mask for antenna ID 29.
         */
        NUR_ANTENNAMASK_29((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_29.value()))),
        /**
         * < Mask for antenna ID 30.
         */
        NUR_ANTENNAMASK_30((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_30.value()))),
        /**
         * < Mask for antenna ID 31.
         */
        NUR_ANTENNAMASK_31((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_31.value()))),
        /**
         * < Mask for antenna ID 32.
         */
        NUR_ANTENNAMASK_32((1 << (int) (NUR_ANTENNAID.NUR_ANTENNAID_32.value()))),
        /**
         * < All antenna mask ids combined.
         */
        NUR_ANTENNAMASK_ALL(0xFFFFFFFFL);
        public final long value;

        NUR_ANTENNAMASK(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_ANTENNAMASK> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_ANTENNAMASK> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * NUR_AUTOPERIOD defines how the periodic auto-inventory power saving is configured.
     * <br>
     *
     * @sa struct NUR_MODULESETUP<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:360</i>
     */
    public enum NUR_AUTOPERIOD implements IntValuedEnum<NUR_AUTOPERIOD> {
        /**
         * < Autoperiod not in use
         */
        NUR_AUTOPER_OFF(0),
        /**
         * < 25% cycle.
         */
        NUR_AUTOPER_25(1),
        /**
         * < 33% cycle.
         */
        NUR_AUTOPER_33(2),
        /**
         * < 50/50 cycle.
         */
        NUR_AUTOPER_50(3),
        NUR_AUTOPER_LAST(3);
        public final long value;

        NUR_AUTOPERIOD(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_AUTOPERIOD> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_AUTOPERIOD> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Setup flags for NurApiSetModuleSetup() function.
     * <br>
     *
     * @sa NurApiSetModuleSetup(), NurApiGetModuleSetup(), struct NUR_MODULESETUP<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:397</i>
     */
    public enum NUR_MODULESETUP_FLAGS implements IntValuedEnum<NUR_MODULESETUP_FLAGS> {
        /**
         * < linkFreq field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_LINKFREQ((1 << 0)),
        /**
         * < rxDecoding field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_RXDEC((1 << 1)),
        /**
         * < txLevel field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_TXLEVEL((1 << 2)),
        /**
         * < txModulation field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_TXMOD((1 << 3)),
        /**
         * < regionId field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_REGION((1 << 4)),
        /**
         * < inventoryQ field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_INVQ((1 << 5)),
        /**
         * < inventorySession field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_INVSESSION((1 << 6)),
        /**
         * < inventoryRounds field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_INVROUNDS((1 << 7)),
        /**
         * < antennaMask field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_ANTMASK((1 << 8)),
        /**
         * < scanSingleTriggerTimeout field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_SCANSINGLETO((1 << 9)),
        /**
         * < inventoryTriggerTimeout field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_INVENTORYTO((1 << 10)),
        /**
         * < selectedAntenna field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_SELECTEDANT((1 << 11)),
        /**
         * < opFlags field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_OPFLAGS((1 << 12)),
        /**
         * < inventoryTarget field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_INVTARGET((1 << 13)),
        /**
         * < inventoryEpcLength field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_INVEPCLEN((1 << 14)),
        /**
         * < readRssiFilter field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_READRSSIFILTER((1 << 15)),
        /**
         * < writeRssiFilter field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_WRITERSSIFILTER((1 << 16)),
        /**
         * < inventoryRssiFilter field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_INVRSSIFILTER((1 << 17)),
        /**
         * < readTO field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_READTIMEOUT((1 << 18)),
        /**
         * < writeTO field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_WRITETIMEOUT((1 << 19)),
        /**
         * < lockTO field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_LOCKTIMEOUT((1 << 20)),
        /**
         * < killTO field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_KILLTIMEOUT((1 << 21)),
        /**
         * < stixPeriod field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_AUTOPERIOD((1 << 22)),
        /**
         * < antPower field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_PERANTPOWER((1 << 23)),
        /**
         * < powerOffset field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_PERANTOFFSET((1 << 24)),
        /**
         * < antennaMaskEx field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_ANTMASKEX((1 << 25)),
        /**
         * < autotune field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_AUTOTUNE((1 << 26)),
        /**
         * < antPowerEx field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_PERANTPOWER_EX((1 << 27)),
        /**
         * < rxSensitivity field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_RXSENS((1 << 28)),
        /**
         * < rfProfile field in struct NUR_MODULESETUP is valid
         */
        NUR_SETUP_RFPROFILE((1 << 29)),
        /**
         * < All setup flags in the structure.
         */
        NUR_SETUP_ALL(((1 << 30) - 1));
        public final long value;

        NUR_MODULESETUP_FLAGS(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_MODULESETUP_FLAGS> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_MODULESETUP_FLAGS> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Possible inventory targets.
     * <br>
     *
     * @sa NurApiSetModuleSetup(), NurApiGetModuleSetup(), struct NUR_MODULESETUP<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:406</i>
     */
    public enum NUR_INVENTORY_TARGET implements IntValuedEnum<NUR_INVENTORY_TARGET> {
        /**
         * < Query tags with inventoried flag set to A
         */
        NUR_INVTARGET_A(0),
        /**
         * < Query tags with inventoried flag set to B
         */
        NUR_INVTARGET_B(1),
        /**
         * < Query tags with inventoried flag set to A or B
         */
        NUR_INVTARGET_AB(2);
        public final long value;

        NUR_INVENTORY_TARGET(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_INVENTORY_TARGET> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_INVENTORY_TARGET> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Possible G2 query command sel states. See UHF G2 standard section 6.3.2.11.2.1
     * <br>
     *
     * @sa NurApiInventoryEx(), NurApiStartInventoryEx(), struct NUR_INVEX_PARAMS<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:415</i>
     */
    public enum NUR_INVENTORY_SELSTATE implements IntValuedEnum<NUR_INVENTORY_SELSTATE> {
        /**
         * < All tags respond, ignoring SL flag
         */
        NUR_SELSTATE_ALL(0),
        /**
         * < Only tags with SL deasserted responds
         */
        NUR_SELSTATE_NOTSL(2),
        /**
         * < Only tags with SL asserted responds
         */
        NUR_SELSTATE_SL(3);
        public final long value;

        NUR_INVENTORY_SELSTATE(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_INVENTORY_SELSTATE> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_INVENTORY_SELSTATE> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Possible target sessions for inventory or inventory filters.<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:423</i>
     */
    public enum NUR_INVENTORY_SESSION implements IntValuedEnum<NUR_INVENTORY_SESSION> {
        /**
         * < Session 0
         */
        NUR_SESSION_S0(0),
        /**
         * < Session 1
         */
        NUR_SESSION_S1(1),
        /**
         * < Session 2
         */
        NUR_SESSION_S2(2),
        /**
         * < Session 3
         */
        NUR_SESSION_S3(3),
        /**
         * < SL flag
         */
        NUR_SESSION_SL(4);
        public final long value;

        NUR_INVENTORY_SESSION(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_INVENTORY_SESSION> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_INVENTORY_SESSION> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Possible filter actions for extended inventory.<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:434</i>
     */
    public enum NUR_FILTER_ACTION implements IntValuedEnum<NUR_FILTER_ACTION> {
        /**
         * < Matching tags: assert SL or inventoried session flag -> A. Non-matching: deassert SL or inventoried session flag -> B.
         */
        NUR_FACTION_0(0),
        /**
         * < Matching tags: assert SL or inventoried session flag -> A. Non-matching: do nothing.
         */
        NUR_FACTION_1(1),
        /**
         * < Matching tags: do nothing. Non-matching: deassert SL or inventoried session -> B.
         */
        NUR_FACTION_2(2),
        /**
         * < Matching tags: negate SL or invert inventoried session flag (A->B, B->A). Non-matching: do nothing.
         */
        NUR_FACTION_3(3),
        /**
         * < Matching tags: deassert SL or inventoried session flag -> B. Non-matching: assert SL or inventoried session flag -> A.
         */
        NUR_FACTION_4(4),
        /**
         * < Matching tags: deassert SL or inventoried session flag -> B. Non-matching: do nothing.
         */
        NUR_FACTION_5(5),
        /**
         * < Matching tags: do nothing. Non-matching: assert SL or inventoried session flag -> A.
         */
        NUR_FACTION_6(6),
        /**
         * < Matching tags: do nothing. Non-matching: negate SL or invert inventoried session flag (A->B, B->A).
         */
        NUR_FACTION_7(7);
        public final long value;

        NUR_FILTER_ACTION(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_FILTER_ACTION> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_FILTER_ACTION> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Defines inventory read type.
     * <br>
     *
     * @sa NurApiConfigInventoryRead()<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:445</i>
     */
    public enum NUR_IRTYPE implements IntValuedEnum<NUR_IRTYPE> {
        /**
         * < EPC + data combined, Duplicates are stripped by EPC
         */
        NUR_IR_EPCDATA(0),
        /**
         * < Duplicates are stripped based on data
         */
        NUR_IR_DATAONLY(1),
        /**
         * < XTID based read result is appended to the EPC.
         */
        NUR_IR_EPCXTID(2),
        /**
         * < Duplicates are stripped based on XTID read data
         */
        NUR_IR_XTIDONLY(3),
        NUR_IR_LAST(3);
        public final long value;

        NUR_IRTYPE(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_IRTYPE> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_IRTYPE> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Operation flags.
     * <br>
     *
     * @sa NurApiSetModuleSetup(), NurApiGetModuleSetup(), struct NUR_MODULESETUP<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:466</i>
     */
    public enum NUR_OPFLAGS implements IntValuedEnum<NUR_OPFLAGS> {
        /**
         * < Notification NUR_NOTIFICATION_HOPEVENT is enabled.
         */
        NUR_OPFLAGS_EN_HOPEVENTS((1 << 0)),
        /**
         * < Inventory stream frunction will report zero count inventory rounds also.
         */
        NUR_OPFLAGS_INVSTREAM_ZEROS((1 << 1)),
        /**
         * < DO NOT USE
         */
        NUR_OPFLAGS_INVENTORY_TID((1 << 2)),
        /**
         * < DO NOT USE
         */
        NUR_OPFLAGS_INVENTORY_READ((1 << 3)),
        /**
         * < DO NOT USE
         */
        NUR_OPFLAGS_SCANSINGLE_KBD((1 << 4)),
        /**
         * < DO NOT USE
         */
        NUR_OPFLAGS_STANDALONE_APP1((1 << 5)),
        /**
         * < DO NOT USE
         */
        NUR_OPFLAGS_STANDALONE_APP2((1 << 6)),
        NUR_OPFLAGS_EXTIN_EVENTS((1 << 7)),
        NUR_OPFLAGS_STATE_EXTOUT_0((1 << 8)),
        NUR_OPFLAGS_STATE_EXTOUT_1((1 << 9)),
        NUR_OPFLAGS_STATE_EXTOUT_2((1 << 10)),
        NUR_OPFLAGS_STATE_EXTOUT_3((1 << 11)),
        /**
         * < Notification NUR_NOTIFICATION_TUNEEVENT is enabled.
         */
        NUR_OPFLAGS_EN_TUNEEVENTS((1 << 12)),
        /**
         * < Return exact BLF in Hz in tag meta data frequency field. Supported only in NUR L2 modules.
         */
        NUR_OPFLAGS_EN_EXACT_BLF((1 << 13)),
        /**
         * < Return tag phase angle in units of tenths of degrees in tag meta data timestamp field. Supported only in NUR2 modules.
         */
        NUR_OPFLAGS_EN_TAG_PHASE((1 << 14));
        public final long value;

        NUR_OPFLAGS(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_OPFLAGS> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_OPFLAGS> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Host support flags. Reported to module with PING command<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:470</i>
     */
    public enum NUR_HOSTFLAGS implements IntValuedEnum<NUR_HOSTFLAGS> {
        /**
         * < When set, module sends ACK request with unsolicited packets.
         */
        NUR_HOSTFLAGS_EN_UNSOL_ACK((1 << 0));
        public final long value;

        NUR_HOSTFLAGS(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_HOSTFLAGS> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_HOSTFLAGS> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Defines which settings to store module internal non-volatile memory.
     * <br>
     *
     * @sa NurApiStoreCurrentSetupEx()<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:481</i>
     */
    public enum NUR_STORE_FLAGS implements IntValuedEnum<NUR_STORE_FLAGS> {
        /**
         * < Store RF settings
         */
        NUR_STORE_RF((1 << 0)),
        /**
         * < Store GPIO/Sensor settings
         */
        NUR_STORE_GPIO((1 << 1)),
        /**
         * < Store Baudrate setting
         */
        NUR_STORE_BAUDRATE((1 << 2)),
        /**
         * < Store OpFlags setting
         */
        NUR_STORE_OPFLAGS((1 << 3)),
        /**
         * < Store all settings
         */
        NUR_STORE_ALL((1 << 0 | 1 << 1 | 1 << 2 | 1 << 3));
        public final long value;

        NUR_STORE_FLAGS(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_STORE_FLAGS> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_STORE_FLAGS> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Defines error flags in the custom hoptable set command.
     * <br>
     *
     * @sa NurApiBuildCustomHoptable(), NurApiSetCustomHoptable(), NurApiSetCustomHoptableEx(), NurApiLoadHopTable()<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:496</i>
     */
    public enum NUR_CUSTHOP_ERROR implements IntValuedEnum<NUR_CUSTHOP_ERROR> {
        NUR_CHERR_COUNT((1 << 0)),
        NUR_CHERR_CHTIME((1 << 1)),
        NUR_CHERR_PAUSETIME((1 << 2)),
        NUR_CHERR_LF((1 << 3)),
        NUR_CHERR_TARI((1 << 4)),
        NUR_CHERR_SIZE((1 << 5)),
        NUR_CHERR_FREQ((1 << 6)),
        NUR_CHERR_TXLIMIT((1 << 7)),
        NUR_CHERR_LBT((1 << 8));
        public final long value;

        NUR_CUSTHOP_ERROR(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_CUSTHOP_ERROR> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_CUSTHOP_ERROR> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * How a NUR binary file was recognized.
     * <br>
     *
     * @sa NurApiGetImageInfo, struct NUR_IMAGE_INFO<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:509</i>
     */
    public enum NUR_BINFILEFORMAT implements IntValuedEnum<NUR_BINFILEFORMAT> {
        /**
         * < Not recognized at all
         */
        NUR_FILE_NONE(0),
        /**
         * < NUR05W L1 bootloader.
         */
        NUR_FILE_NURLDR(1),
        /**
         * < NUR05W L1 application.
         */
        NUR_FILE_NURAPP(2),
        /**
         * < XNUR bootloader.
         */
        NUR_FILE_XNURLDR(3),
        /**
         * < XNUR application.
         */
        NUR_FILE_XNURAPP(4),
        /**
         * < NUR05WL2 bootloader.
         */
        NUR_FILE_NUR05WL2LDR(5),
        /**
         * < NUR05WL2 application.
         */
        NUR_FILE_NUR05WL2APP(6);
        public final long value;

        NUR_BINFILEFORMAT(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_BINFILEFORMAT> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_BINFILEFORMAT> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * How the device capabilities are presented in the flag field 1.
     * <br>
     *
     * @sa NurApiGetDeviceCaps, struct NUR_DEVICECAPS<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:543</i>
     */
    public enum NUR_DEVCAPS_F1 implements IntValuedEnum<NUR_DEVCAPS_F1> {
        /**
         * < RX modulation FM0.
         */
        NUR_DC_RXDECFM0((1 << 0)),
        /**
         * < RX modulation Miller-2.
         */
        NUR_DC_RXDECM2((1 << 1)),
        /**
         * < RX modulation Miller-4.
         */
        NUR_DC_RXDECM4((1 << 2)),
        /**
         * < RX modulation Miller-8.
         */
        NUR_DC_RXDECM8((1 << 3)),
        /**
         * < Backscatter LF of 40kHz.
         */
        NUR_DC_RXLF40k((1 << 4)),
        /**
         * < Backscatter LF of 80kHz.
         */
        NUR_DC_RXLF80k((1 << 5)),
        /**
         * < Backscatter LF of 160kHz.
         */
        NUR_DC_RXLF160k((1 << 6)),
        /**
         * < Backscatter LF of 256kHz.
         */
        NUR_DC_RXLF256k((1 << 7)),
        /**
         * < Backscatter LF of 320kHz.
         */
        NUR_DC_RXLF320k((1 << 8)),
        /**
         * < Backscatter LF of 640kHz.
         */
        NUR_DC_RXLF640k((1 << 9)),
        /**
         * < Reserved LF 1.
         */
        NUR_DC_RXLFres1((1 << 10)),
        /**
         * < Reserved LF 2.
         */
        NUR_DC_RXLFres2((1 << 11)),
        /**
         * < The device has beeper available.
         */
        NUR_DC_HASBEEP((1 << 12)),
        /**
         * < The device has light sensor available.
         */
        NUR_DC_HASLIGHT((1 << 13)),
        /**
         * < The device has tap sensor available.
         */
        NUR_DC_HASTAP((1 << 14)),
        /**
         * < The antenna or antennas in this device can be tuned.
         */
        NUR_DC_ANTTUNE((1 << 15)),
        /**
         * < This module can run channel scan.
         */
        NUR_DC_CHSCANNER((1 << 16)),
        /**
         * < This module can run inventory + read.
         */
        NUR_DC_INVREAD((1 << 17)),
        /**
         * < This module supports per antenna power setting.
         */
        NUR_DC_ANTPOWER((1 << 18)),
        /**
         * < This module supports per antenna low power setting offset -1...1.
         */
        NUR_DC_POWEROFS((1 << 19)),
        /**
         * < This module supports beam forming antenna.
         */
        NUR_DC_BEAMANTENNA((1 << 20)),
        /**
         * < This module supports fetching tags one by one.
         */
        NUR_DC_FETCHSINGLE((1 << 21)),
        /**
         * < This module provides antenna mapping information.
         */
        NUR_DC_ANTENNAMAP((1 << 22)),
        /**
         * < The module FW supports Gen2 version 2 at some level.
         */
        NUR_DC_GEN2VER2((1 << 23)),
        /**
         * < The module FW supports RF profile setting.
         */
        NUR_DC_RFPROFILE((1 << 24)),
        /**
         * < This module FW supports diagnostics commands.
         */
        NUR_DC_DIAG((1 << 25)),
        /**
         * < This module FW supports tag phase info. see NUR_OPFLAGS_EN_TAG_PHASE
         */
        NUR_DC_TAGPHASE((1 << 26)),
        /**
         * < Next available bit for future extensions.
         */
        NUR_DC_LASTBITF1((1 << 27));
        public final long value;

        NUR_DEVCAPS_F1(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_DEVCAPS_F1> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_DEVCAPS_F1> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * RFID Chip version.
     * <br>
     *
     * @sa NurApiGetDeviceCaps, struct NUR_DEVICECAPS<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:552</i>
     */
    public enum NUR_CHIPVER implements IntValuedEnum<NUR_CHIPVER> {
        NUR_CHIPVER_AS3992(1),
        NUR_CHIPVER_AS3993(2),
        NUR_CHIPVER_R2000(3);
        public final long value;

        NUR_CHIPVER(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_CHIPVER> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_CHIPVER> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Module type.
     * <br>
     *
     * @sa NurApiGetDeviceCaps, struct NUR_DEVICECAPS<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:563</i>
     */
    public enum NUR_MODULETYPE implements IntValuedEnum<NUR_MODULETYPE> {
        NUR_MODULETYPE_NUR05W(1),
        NUR_MODULETYPE_NUR05WL(2),
        NUR_MODULETYPE_NUR05WL2(3),
        NUR_MODULETYPE_NUR10W(4),
        NUR_MODULETYPE_NUR2_1W(5);
        public final long value;

        NUR_MODULETYPE(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_MODULETYPE> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_MODULETYPE> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Types of grid antenna tuning.<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:569</i>
     */
    public enum NUR_GANT_TUNE implements IntValuedEnum<NUR_GANT_TUNE> {
        GANT_TUNE_FAST(0),
        GANT_TUNE_MEDIUM(1),
        GANT_TUNE_WIDE(2);
        public final long value;

        NUR_GANT_TUNE(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_GANT_TUNE> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_GANT_TUNE> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * WLAN status bits<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:577</i>
     */
    public enum WLAN_STATUS implements IntValuedEnum<WLAN_STATUS> {
        /**
         * < the device is connected to the AP
         */
        STATUS_BIT_CONNECTION((1 << 0)),
        /**
         * < client is connected to device
         */
        STATUS_BIT_STA_CONNECTED((1 << 1)),
        /**
         * < the device has acquired an IP
         */
        STATUS_BIT_IP_ACQUIRED((1 << 2)),
        /**
         * < the device has leased an IP
         */
        STATUS_BIT_IP_LEASED((1 << 3)),
        /**
         * < failed to connect to device
         */
        STATUS_BIT_CONNECTION_FAILED((1 << 4));
        public final long value;

        WLAN_STATUS(long value) {
            this.value = value;
        }

        public static IntValuedEnum<WLAN_STATUS> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<WLAN_STATUS> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Flags for diagnostics configuration.
     * <br>
     *
     * @sa NurApiDiagGetConfig
     * <br>
     * @sa NurApiDiagSetConfig
     * <br>
     * @sa NUR_NOTIFICATION_DIAG_REPORT<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:590</i>
     */
    public enum NUR_DIAG_CFG_FLAGS implements IntValuedEnum<NUR_DIAG_CFG_FLAGS> {
        /**
         * < Never send diagnostics report notification
         */
        NUR_DIAG_CFG_NOTIFY_NONE(0),
        /**
         * < Send diagnostics report notification periodically. @sa NurApiDiagSetConfig @sa NUR_NOTIFICATION_DIAG_REPORT
         */
        NUR_DIAG_CFG_NOTIFY_PERIODIC((1 << 0)),
        /**
         * < Send diagnostics report notification on warning/error. @sa NurApiDiagSetConfig @sa NUR_NOTIFICATION_DIAG_REPORT
         */
        NUR_DIAG_CFG_NOTIFY_WARN((1 << 1)),
        /**
         * < Module sends error log messages. Messages are prefixed with "FW:". @sa NUR_NOTIFICATION_LOG
         */
        NUR_DIAG_CFG_FW_ERROR_LOG((1 << 2)),
        /**
         * < Module sends verbose debug log messages. Messages are prefixed with "FW:". @sa NUR_NOTIFICATION_LOG
         */
        NUR_DIAG_CFG_FW_DEBUG_LOG((1 << 3));
        public final long value;

        NUR_DIAG_CFG_FLAGS(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_DIAG_CFG_FLAGS> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_DIAG_CFG_FLAGS> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Flags for NurApiDiagGetReport function.
     * <br>
     *
     * @sa NurApiDiagGetReport<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:598</i>
     */
    public enum NUR_DIAG_GETREPORT_FLAGS implements IntValuedEnum<NUR_DIAG_GETREPORT_FLAGS> {
        /**
         * < None
         */
        NUR_DIAG_GETREPORT_NONE(0),
        /**
         * < Reset all diagnostics statistics to zero.
         */
        NUR_DIAG_GETREPORT_RESET_STATS((1 << 0));
        public final long value;

        NUR_DIAG_GETREPORT_FLAGS(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_DIAG_GETREPORT_FLAGS> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_DIAG_GETREPORT_FLAGS> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * Flags for diagnostics report. see struct NUR_DIAG_REPORT.
     * <br>
     *
     * @sa struct NUR_DIAG_REPORT
     * <br>
     * @sa NurApiDiagGetReport<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIConstants.h:609</i>
     */
    public enum NUR_DIAG_REPORT_FLAGS implements IntValuedEnum<NUR_DIAG_REPORT_FLAGS> {
        /**
         * < Set in NUR_DIAG_REPORT.flags when module sends periodic report.
         */
        NUR_DIAG_REPORT_PERIODIC((1 << 0)),
        /**
         * < Set in NUR_DIAG_REPORT.flags if module temperature is high. Host application SHOULD stop performing RF operations for a while.
         */
        NUR_DIAG_REPORT_TEMP_HIGH((1 << 1)),
        /**
         * < Set in NUR_DIAG_REPORT.flags if module temperature is over limits. All RF operations will fail with error NUR_ERROR_OVER_TEMP in this stage.
         */
        NUR_DIAG_REPORT_TEMP_OVER((1 << 2)),
        /**
         * < Set in NUR_DIAG_REPORT.flags if low voltage is detected. All RF operations will fail with error NUR_ERROR_LOW_VOLTAGE in this stage.
         */
        NUR_DIAG_REPORT_LOWVOLT((1 << 3));
        public final long value;

        NUR_DIAG_REPORT_FLAGS(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_DIAG_REPORT_FLAGS> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_DIAG_REPORT_FLAGS> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * NurApi error codes<br>
     * enum values<br>
     * <i>native declaration : nur_sdk-master\native\include\NurAPIErrors.h:63</i>
     */
    public enum NUR_ERRORCODES implements IntValuedEnum<NUR_ERRORCODES> {
        NUR_SUCCESS(0),
        NUR_NO_ERROR(0),
        NUR_ERROR_INVALID_COMMAND((0 + 1)),
        NUR_ERROR_INVALID_LENGTH((0 + 2)),
        NUR_ERROR_PARAMETER_OUT_OF_RANGE((0 + 3)),
        NUR_ERROR_RECEIVE_TIMEOUT((0 + 4)),
        NUR_ERROR_INVALID_PARAMETER((0 + 5)),
        NUR_ERROR_PROGRAM_FAILED((0 + 6)),
        NUR_ERROR_PARAMETER_MISMATCH((0 + 7)),
        NUR_ERROR_HW_MISMATCH((0 + 8)),
        NUR_ERROR_RESERVED1((0 + 9)),
        NUR_ERROR_PAGE_PROGRAM((0 + 10)),
        NUR_ERROR_CRC_CHECK((0 + 11)),
        NUR_ERROR_CRC_MISMATCH((0 + 12)),
        NUR_ERROR_NOT_READY((0 + 13)),
        NUR_ERROR_APP_NOT_PRESENT((0 + 14)),
        NUR_ERROR_GENERAL(0x10),
        NUR_ERROR_NO_TAG(0x20),
        NUR_ERROR_RESP_AIR((0x20 + 1)),
        NUR_ERROR_G2_SELECT((0x20 + 2)),
        NUR_ERROR_MISSING_SELDATA((0x20 + 3)),
        NUR_ERROR_G2_ACCESS((0x20 + 4)),
        NUR_ERROR_G2_READ(0x30),
        NUR_ERROR_G2_RD_PART((0x30 + 1)),
        NUR_ERROR_G2_WRITE(0x40),
        NUR_ERROR_G2_WR_PART((0x40 + 1)),
        NUR_ERROR_G2_TAG_RESP((0x40 + 2)),
        NUR_ERROR_G2_SPECIAL(0x50),
        NUR_ERROR_READER_HW(0x60),
        NUR_ERROR_BAD_ANTENNA((0x60 + 1)),
        NUR_ERROR_LOW_VOLTAGE((0x60 + 2)),
        NUR_ERROR_OVER_TEMP((0x60 + 3)),
        NUR_ERROR_INVALID_HANDLE(0x1000),
        NUR_ERROR_TRANSPORT((0x1000 + 1)),
        NUR_ERROR_TR_NOT_CONNECTED((0x1000 + 2)),
        NUR_ERROR_TR_TIMEOUT((0x1000 + 3)),
        NUR_ERROR_BUFFER_TOO_SMALL((0x1000 + 4)),
        NUR_ERROR_NOT_SUPPORTED((0x1000 + 5)),
        NUR_ERROR_NO_PAYLOAD((0x1000 + 6)),
        NUR_ERROR_INVALID_PACKET((0x1000 + 7)),
        NUR_ERROR_PACKET_TOO_LONG((0x1000 + 8)),
        NUR_ERROR_PACKET_CS_ERROR((0x1000 + 9)),
        NUR_ERROR_NOT_WORD_BOUNDARY((0x1000 + 10)),
        NUR_ERROR_FILE_NOT_FOUND((0x1000 + 11)),
        NUR_ERROR_FILE_INVALID((0x1000 + 12)),
        NUR_ERROR_MCU_ARCH((0x1000 + 13)),
        NUR_ERROR_G2_TAG_MEM_OVERRUN((0x1000 + 14)),
        NUR_ERROR_G2_TAG_MEM_LOCKED((0x1000 + 15)),
        NUR_ERROR_G2_TAG_INSUF_POWER((0x1000 + 16)),
        NUR_ERROR_G2_TAG_NON_SPECIFIC((0x1000 + 17)),
        NUR_ERROR_TR_SUSPENDED((0x1000 + 18)),
        NUR_ERROR_SERVER((0x1000 + 19)),
        NUR_ERROR_QUERY_BUSY((0x1000 + 20)),
        NUR_ERROR_G2_TAG_OTHER_ERROR((0x1000 + 21)),
        NUR_ERROR_G2_TAG_NOT_SUPPORTED((0x1000 + 22)),
        NUR_ERROR_G2_TAG_INSUF_PRIVILEDGE((0x1000 + 23)),
        NUR_ERROR_G2_TAG_CRYPTO_SUITE((0x1000 + 24)),
        NUR_ERROR_G2_TAG_NOT_ENCAPSULATED((0x1000 + 25)),
        NUR_ERROR_G2_TAG_RESPBUFFER_OVF((0x1000 + 26)),
        NUR_ERROR_G2_TAG_SEC_TIMEOUT((0x1000 + 27));
        public final long value;

        NUR_ERRORCODES(long value) {
            this.value = value;
        }

        public static IntValuedEnum<NUR_ERRORCODES> fromValue(int value) {
            return FlagSet.fromValue(value, values());
        }

        public long value() {
            return this.value;
        }

        public Iterator<NUR_ERRORCODES> iterator() {
            return Collections.singleton(this).iterator();
        }
    }

    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:694</i>
     */
    public static abstract class NotificationCallback extends Callback<NotificationCallback> {
        public void apply(Pointer<?> hApi, int timestamp, int type, Pointer<?> data, int dataLen) {
            apply(Pointer.getPeer(hApi), timestamp, type, Pointer.getPeer(data), dataLen);
        }

        public void apply(@Ptr long hApi, int timestamp, int type, @Ptr long data, int dataLen) {
            apply(Pointer.pointerToAddress(hApi), timestamp, type, Pointer.pointerToAddress(data), dataLen);
        }
    }

    /**
     * <i>native declaration : nur_sdk-master\native\include\NurAPI.h:696</i>
     */
    public static abstract class NurUSBEnumDeviceFunction extends Callback<NurUSBEnumDeviceFunction> {
        public int apply(Pointer<Byte> path, Pointer<Byte> friendlyname, Pointer<?> arg) {
            return apply(Pointer.getPeer(path), Pointer.getPeer(friendlyname), Pointer.getPeer(arg));
        }

        public int apply(@Ptr long path, @Ptr long friendlyname, @Ptr long arg) {
            return apply((Pointer) Pointer.pointerToAddress(path, Byte.class), (Pointer) Pointer.pointerToAddress(friendlyname, Byte.class), Pointer.pointerToAddress(arg));
        }
    }
}
